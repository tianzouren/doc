<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-MYSQL/MYSQL-REVIEW" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.8.1">
<title data-rh="true">MYSQL-REVIEW | My Site</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://your-docusaurus-site.example.com/doc/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://your-docusaurus-site.example.com/doc/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://your-docusaurus-site.example.com/doc/docs/INTERVIEW/MYSQL/MYSQL-REVIEW"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="MYSQL-REVIEW | My Site"><meta data-rh="true" name="description" content="MYSQL-REVIEW"><meta data-rh="true" property="og:description" content="MYSQL-REVIEW"><link data-rh="true" rel="icon" href="/doc/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://your-docusaurus-site.example.com/doc/docs/INTERVIEW/MYSQL/MYSQL-REVIEW"><link data-rh="true" rel="alternate" href="https://your-docusaurus-site.example.com/doc/docs/INTERVIEW/MYSQL/MYSQL-REVIEW" hreflang="en"><link data-rh="true" rel="alternate" href="https://your-docusaurus-site.example.com/doc/docs/INTERVIEW/MYSQL/MYSQL-REVIEW" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"MYSQL-REVIEW","item":"https://your-docusaurus-site.example.com/doc/docs/INTERVIEW/MYSQL/MYSQL-REVIEW"}]}</script><link rel="alternate" type="application/rss+xml" href="/doc/blog/rss.xml" title="My Site RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/doc/blog/atom.xml" title="My Site Atom Feed"><link rel="stylesheet" href="/doc/assets/css/styles.8d5b4fe0.css">
<script src="/doc/assets/js/runtime~main.1f9c75d1.js" defer="defer"></script>
<script src="/doc/assets/js/main.01ab3953.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t="light";var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",e||t),document.documentElement.setAttribute("data-theme-choice",e||t)}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/doc/img/logo.svg"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/doc/"><div class="navbar__logo"><img src="/doc/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/doc/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">My Site</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/doc/docs/intro">Tutorial</a><a class="navbar__item navbar__link" href="/doc/blog">Blog</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="Switch between dark and light mode (currently system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/doc/docs/intro">Tutorial Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/doc/docs/category/tutorial---basics">Tutorial - Basics</a><button aria-label="Expand sidebar category &#x27;Tutorial - Basics&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/doc/docs/category/tutorial---extras">Tutorial - Extras</a><button aria-label="Expand sidebar category &#x27;Tutorial - Extras&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/doc/docs/JAVA/">java</a><button aria-label="Expand sidebar category &#x27;java&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/MQ">MQ</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" href="/doc/docs/INTERVIEW/MYSQL/MYSQL-REVIEW">MYSQL</a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/doc/docs/INTERVIEW/MYSQL/MYSQL-REVIEW">MYSQL-REVIEW</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/doc/docs/MYSQL/mysql-tmp">mysql-tmp</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/doc/docs/MYSQL/mysql常见命令查询">mysql常见命令查询</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/NGINX/NGINX-REVIEW">NGINX</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/intereview/redis">REDIS</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/SPRING/SPRING-REVIEW">SPRING</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/doc/docs/tmp">tmp</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/分布式/分布式-REVIEW">分布式</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/微服务/微服务-REVIEW">微服务</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/doc/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">MYSQL</span></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">MYSQL-REVIEW</span></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>MYSQL-REVIEW</h1></header><h2 class="anchor anchorWithStickyNavbar_LWe7" id="mysql-基础">mysql 基础<a href="#mysql-基础" class="hash-link" aria-label="Direct link to mysql 基础" title="Direct link to mysql 基础">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="mysql的date和timestamp的区别">mysql的date和timestamp的区别？<a href="#mysql的date和timestamp的区别" class="hash-link" aria-label="Direct link to mysql的date和timestamp的区别？" title="Direct link to mysql的date和timestamp的区别？">​</a></h3>
<p><strong>时区 ，存储空间 ，默认值 ，日期范围</strong>
DATETIME 直接存储日期和时间的完整值，与时区无关。<br>
<!-- -->TIMESTAMP 存储的是 Unix 时间戳，1970-01-01 00:00:01 UTC 以来的秒数，受时区影响。最大只能到2038年<br>
<!-- -->而DATETIME 的默认值为 null，占用 8 个字节；
TIMESTAMP 的默认值为当前时间——CURRENT_TIMESTAMP，占 4 个字节，实际开发中更常用，因为可以自动更新。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="sql-查询语句的执行顺序了解吗">SQL 查询语句的执行顺序了解吗？<a href="#sql-查询语句的执行顺序了解吗" class="hash-link" aria-label="Direct link to SQL 查询语句的执行顺序了解吗？" title="Direct link to SQL 查询语句的执行顺序了解吗？">​</a></h3>
<p>waitx
这里说的是逻辑过程
FROM
ON
JOIN
WHERE
GROUP BY
聚合函数
HAVING
SELECT
DISTINCT
ORDER BY
LIMIT</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="in-和-exists的差别">IN 和 EXISTS的差别<a href="#in-和-exists的差别" class="hash-link" aria-label="Direct link to IN 和 EXISTS的差别" title="Direct link to IN 和 EXISTS的差别">​</a></h3>
<p>当使用 IN 时，MySQL 会首先执行子查询，然后将子查询的结果集用于外部查询的条件。这意味着子查询的结果集需要全部加载到内存中。<br>
<!-- -->而 EXISTS 会对外部查询的每一行，执行一次子查询。如果子查询返回任何行，则 EXISTS 条件为真。EXISTS 关注的是子查询是否返回行，而不是返回的具体值。</p>
<ul>
<li>
<p>IN 的临时表可能成为性能瓶颈
IN 适用于子查询结果集较小的情况。如果子查询返回大量数据，IN 的性能可能会下降，因为它需要将整个结果集加载到内存。<br>
<!-- -->而 EXISTS 适用于子查询结果集可能很大的情况。由于 EXISTS 只需要判断子查询是否返回行，而不需要加载整个结果集，因此在某些情况下性能更好，特别是当子查询可以使用索引时。</p>
</li>
<li>
<p>NULL值陷了解吗？
IN: 如果子查询的结果集中包含 NULL 值，可能会导致意外的结果。例如，WHERE column IN (subquery)，如果 subquery 返回 NULL，则 column IN (subquery) 永远不会为真，除非 column 本身也为 NULL。<br>
<!-- -->EXISTS: 对 NULL 值的处理更加直接。EXISTS 只是检查子查询是否返回行，不关心行的具体值，因此不受 NULL 值的影响。</p>
</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="记录货币用什么类型比较好">记录货币用什么类型比较好？<a href="#记录货币用什么类型比较好" class="hash-link" aria-label="Direct link to 记录货币用什么类型比较好？" title="Direct link to 记录货币用什么类型比较好？">​</a></h3>
<p>如果是电商、交易、账单等涉及货币的场景，建议使用 DECIMAL 类型，因为 DECIMAL 类型是精确数值类型，不会出现浮点数计算误差。<br>
<!-- -->如果是银行，涉及到支付的场景，建议使用 BIGINT 类型。可以将货币金额乘以一个固定因子，比如 100，表示以“分”为单位，然后存储为 BIGINT。这种方式既避免了浮点数问题，同时也提供了不错的性能。但在展示的时候需要除以相应的因子。<br>
<!-- -->为什么不推荐使用 FLOAT 或 DOUBLE？</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="dropdelete-与-truncate-的区别">drop、delete 与 truncate 的区别？<a href="#dropdelete-与-truncate-的区别" class="hash-link" aria-label="Direct link to drop、delete 与 truncate 的区别？" title="Direct link to drop、delete 与 truncate 的区别？">​</a></h3>
<p>DROP 是物理删除，用来删除整张表，包括表结构，且不能回滚。<br>
<!-- -->DELETE 支持行级删除，可以带 WHERE 条件，可以回滚。<br>
<!-- -->TRUNCATE 用于清空表中的所有数据，但会保留表结构，不能回滚。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="用过哪些-mysql-函数补充">用过哪些 MySQL 函数？（补充）<a href="#用过哪些-mysql-函数补充" class="hash-link" aria-label="Direct link to 用过哪些 MySQL 函数？（补充）" title="Direct link to 用过哪些 MySQL 函数？（补充）">​</a></h3>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说-mysql-的基础架构">说说 MySQL 的基础架构？<a href="#说说-mysql-的基础架构" class="hash-link" aria-label="Direct link to 说说 MySQL 的基础架构？" title="Direct link to 说说 MySQL 的基础架构？">​</a></h3>
<p>架构层次</p>
<ol>
<li>连接器 ： 连接层主要负责客户端连接的管理，包括验证用户身份、权限校验、连接管理等。可以通过数据库连接池来提升连接的处理效率。</li>
<li>server ： 服务层是 MySQL 的核心，主要负责查询解析、优化、执行等操作。在这一层，SQL 语句会经过解析、优化器优化，然后转发到存储引擎执行，并返回结果。这一层包含查询解析器、优化器、执行计划生成器、日志模块等。</li>
<li>存储引擎 ： 存储引擎层负责数据的实际存储和提取。MySQL 支持多种存储引擎，如 InnoDB、MyISAM、Memory 等。</li>
</ol>
<ul>
<li>binlog写入在哪一层？
binlog 在服务层，负责记录 SQL 语句的变化。它记录了所有对数据库进行更改的操作，用于数据恢复、主从复制等。</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="数据库架构">数据库架构<a href="#数据库架构" class="hash-link" aria-label="Direct link to 数据库架构" title="Direct link to 数据库架构">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="一条查询语句是如何执行的">🌟一条查询语句是如何执行的？<a href="#一条查询语句是如何执行的" class="hash-link" aria-label="Direct link to 🌟一条查询语句是如何执行的？" title="Direct link to 🌟一条查询语句是如何执行的？">​</a></h3>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="一条更新语句是如何执行的">一条更新语句是如何执行的？<a href="#一条更新语句是如何执行的" class="hash-link" aria-label="Direct link to 一条更新语句是如何执行的？" title="Direct link to 一条更新语句是如何执行的？">​</a></h3>
<p>waitx
mysql—update执行流程图 waitx</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说-mysql-的段区页行补充">说说 MySQL 的段区页行（补充）<a href="#说说-mysql-的段区页行补充" class="hash-link" aria-label="Direct link to 说说 MySQL 的段区页行（补充）" title="Direct link to 说说 MySQL 的段区页行（补充）">​</a></h3>
<p>①、段：表空间由多个段组成，常见的段有数据段、索引段、回滚段等。<br>
<!-- -->创建索引时会创建两个段，数据段和索引段，数据段用来存储叶子节点中的数据；索引段用来存储非叶子节点的数据。<br>
<!-- -->回滚段包含了事务执行过程中用于数据回滚的旧数据。<br>
<!-- -->②、区：段由一个或多个区组成，区是一组连续的页，通常包含 64 个连续的页，也就是 1M 的数据。<br>
<strong>使用区而非单独的页进行数据分配可以优化磁盘操作，减少磁盘寻道时间，特别是在大量数据进行读写时。</strong></p>
<p>③、页：页是 InnoDB 存储数据的基本单元，标准大小为 16 KB，索引树上的一个节点就是一个页。<br>
<!-- -->也就意味着数据库每次读写都是以 16 KB 为单位的，一次最少从磁盘中读取 16KB 的数据到内存，一次最少写入 16KB 的数据到磁盘。</p>
<p>④、行：InnoDB 采用行存储方式，意味着数据按照行进行组织和管理，行数据可能有多个格式，比如说 COMPACT、REDUNDANT、DYNAMIC 等。<br>
<!-- -->MySQL 8.0 默认的行格式是 DYNAMIC，由COMPACT 演变而来，意味着这些数据如果超过了页内联存储的限制，则会被存储在溢出页中。</p>
<p>-----  不太重要 start  -----------------
MySQL 5.7 和 8.0 都支持以下四种行格式：
1.REDUNDANT: 冗余格式，MySQL 5.0 之前的老格式，用于向后兼容。存储效率较低，通常不推荐使用。<br>
<!-- -->2.COMPACT: 紧凑格式。比 REDUNDANT更高效地存储数据，但依然会存储部分 NULL 值的信息在行内（溢出页之前）。<br>
<!-- -->3.DYNAMIC: 动态格式（MySQL 5.7.9 及以后版本的默认格式）。这是 COMPACT格式的改进版。对于可能溢出的大字段（如 BLOB, TEXT, VARCHAR），它只在行中存储一个 20 字节的指针，而将实际数据完全存储在溢出页中。这使得行内能存储更多的数据，非常适合包含可变长大数据列的表。<br>
<!-- -->4.COMPRESSED: 压缩格式。基于 DYNAMIC格式，但增加了表级别的数据压缩功能（使用 zlib 压缩算法）。它会将数据和索引进行压缩，可以显著减少存储空间，但会带来额外的 CPU 开销。</p>
<p>Compact/Redundant的处理：在这些格式中，溢出的列会在当前页的真实数据部分存储该列数据的前 768 字节，剩余的数据则存储到单独的“溢出页”中，并在本记录中用一个 20 字节的指针指向溢出页 。<br>
<!-- -->Dynamic/Compressed的改进：这是它们的关键优势。对于溢出的列，它们不再存储 768 字节的前缀，而是只存储一个 20 字节的指针，将所有数据都存放在溢出页中。这使得数据页（B+树叶子节点）能容纳更多的记录，提高了缓存效率，对于包含 TEXT、BLOB 等大对象的表尤其有利<br>
<strong>行溢出</strong>：默认每个页大小是 16KB。如果一行数据非常大（例如，包含一个很长的 TEXT 或 VARCHAR 字段），导致一个页放不下整条记录，就会发生“行溢出”<br>
<!-- -->其中REDUNDANT 和 COMPACT
<img decoding="async" loading="lazy" alt="COMPACT" src="/doc/assets/images/COMPACT-bce97d8f2a251737078cf1b30b2bbf9e.png" width="744" height="164" class="img_ev3q">
差别：REDUNDANT格式没有专门的NULL值列表，通过在字段长度偏移列表的第一个比特位来标记NULL值
-----  不太重要 end  -----------------</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="存储引擎">存储引擎<a href="#存储引擎" class="hash-link" aria-label="Direct link to 存储引擎" title="Direct link to 存储引擎">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="mysql-有哪些常见存储引擎">🌟MySQL 有哪些常见存储引擎？<a href="#mysql-有哪些常见存储引擎" class="hash-link" aria-label="Direct link to 🌟MySQL 有哪些常见存储引擎？" title="Direct link to 🌟MySQL 有哪些常见存储引擎？">​</a></h3>
<p>MyISAM、InnoDB、MEMORY<br>
<!-- -->mysql存储引擎图片waitx<br>
<!-- -->①、MySQL 5.5 之前，默认存储引擎是 MyISAM，5.5 之后是 InnoDB。<br>
<!-- -->②、InnoDB 支持的哈希索引是<strong>自适应的，不能人为干预</strong>。<br>
<!-- -->③、InnoDB 从 MySQL 5.6 开始，支持全文索引。<br>
<!-- -->④、InnoDB 的最小表空间略小于 10M，最大表空间取决于页面大小。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="innodb-和-myisam-主要有什么区别">InnoDB 和 MyISAM 主要有什么区别？<a href="#innodb-和-myisam-主要有什么区别" class="hash-link" aria-label="Direct link to InnoDB 和 MyISAM 主要有什么区别？" title="Direct link to InnoDB 和 MyISAM 主要有什么区别？">​</a></h3>
<ol>
<li>InnoDB 和 MyISAM 的最大区别在于<strong>事务支持和锁机制</strong>。InnoDB 支持事务、行级锁，适合大多数业务系统；而 MyISAM 不支持事务，用的是表锁，查询快但写入性能差，适合读多写少的场景。</li>
<li>另外，从存储结构上来说：<br>
<!-- -->MyISAM 用三种格式的文件来存储，.frm 文件存储表的定义；.MYD 存储数据；.MYI 存储索引；<br>
<!-- -->而 InnoDB 用两种格式的文件来存储，.frm 文件存储表的定义；.ibd 存储数据和索引。</li>
<li>从索引类型上来说，MyISAM 为非聚簇索引，索引和数据分开存储，索引保存的是数据文件的指针。
InnoDB 为聚簇索引，索引和数据不分开。</li>
</ol>
<p>更细微的层面上来讲，MyISAM 不支持外键，可以没有主键，表的具体行数存储在表的属性中，查询时可以直接返回；
InnoDB 支持外键，必须有主键，具体行数需要扫描整个表才能返回，有索引的情况下会扫描索引。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="innodb的内存结构了解吗">InnoDB的内存结构了解吗？<a href="#innodb的内存结构了解吗" class="hash-link" aria-label="Direct link to InnoDB的内存结构了解吗？" title="Direct link to InnoDB的内存结构了解吗？">​</a></h3>
<p>InnoDB 的内存区域主要有两块，buffer pool 和 log buffer。<br>
<!-- -->buffer pool 用于缓存数据页和索引页，提升读写性能；<br>
<!-- -->log buffer 用于缓存 redo log，提升写入性能。<br>
<img decoding="async" loading="lazy" alt="InnoDB的内存结构" src="/doc/assets/images/InnoDB的内存结构-89237dccdda1477a07435faf4fac4fbc.png" width="1404" height="1136" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="数据页的结构了解吗-ps自己暂时不看">数据页的结构了解吗？ (ps:自己暂时不看)<a href="#数据页的结构了解吗-ps自己暂时不看" class="hash-link" aria-label="Direct link to 数据页的结构了解吗？ (ps:自己暂时不看)" title="Direct link to 数据页的结构了解吗？ (ps:自己暂时不看)">​</a></h3>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="innodb-的-buffer-pool了解吗补充">InnoDB 的 Buffer Pool了解吗？（补充）<a href="#innodb-的-buffer-pool了解吗补充" class="hash-link" aria-label="Direct link to InnoDB 的 Buffer Pool了解吗？（补充）" title="Direct link to InnoDB 的 Buffer Pool了解吗？（补充）">​</a></h3>
<p>Buffer Pool 是 InnoDB 存储引擎中的一个内存缓冲区，它会将经常使用的数据页、索引页加载进内存，读的时候先查询 Buffer Pool，如果命中就不用访问磁盘了。<br>
<!-- -->![Buffer Pool](image/mysql-review/Buffer Pool.png)
如果没有命中，就从磁盘读取，并加载到 Buffer Pool，此时可能会触发页淘汰，将不常用的页移出 Buffer Pool。<br>
<img decoding="async" loading="lazy" alt="mysql内存淘汰" src="/doc/assets/images/mysql内存淘汰-aa4b9c0a55d99e81e2f06ee213cadf20.png" width="1566" height="446" class="img_ev3q">
写操作时不会直接写入磁盘，而是先修改内存中的页，此时页被标记为脏页，后台线程会定期将脏页刷新到磁盘。<br>
<!-- -->Buffer Pool 可以显著减少磁盘的读写次数，从而提升 MySQL 的读写性能。<br>
<!-- -->Buffer Pool 的默认大小是多少？<br>
<!-- -->我本机上 InnoDB 的 Buffer Pool 默认大小是 128MB。一般调解成宿主机的70%</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="-innodb-对-lru-算法的优化了解吗">### <a href="https://javabetter.cn/sidebar/sanfene/mysql.html#innodb-%E5%AF%B9-lru-%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96%E4%BA%86%E8%A7%A3%E5%90%97" target="_blank" rel="noopener noreferrer">InnoDB 对 LRU 算法的优化了解吗？</a><a href="#-innodb-对-lru-算法的优化了解吗" class="hash-link" aria-label="Direct link to -innodb-对-lru-算法的优化了解吗" title="Direct link to -innodb-对-lru-算法的优化了解吗">​</a></h4>
<p>了解，InnoDB 对 LRU 算法进行了改良，最近访问的数据并不直接放到 LRU 链表的头部，而是放在一个叫 midpoiont 的位置。默认情况下，midpoint 位于 LRU 列表的 5/8 处。<br>
<img decoding="async" loading="lazy" alt="mysql-lru" src="data:image/png;base64,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" width="629" height="184" class="img_ev3q">
比如 Buffer Pool 有 100 页，新页插入的位置大概是在第 80 页；当页数据被频繁访问后，再将其移动到 young 区，这样做的好处是热点页能长时间保留在内存中，不容易被挤出去。<br>
<!-- -->在count(*) 也会进行全量数据的加载， 但如果有二级索引的情况下，会优先使用二级索引进行计数， 否则就只能扫描数据行到内存中。</p>
<p>----这部分是帮助大家理解 start，面试中可不背----
可以通过 <code>innodb_old_blocks_pct</code> 参数来调整 Buffer Pool 中 old 和 young 区的比例；通过 <code>innodb_old_blocks_time</code> 参数来调整页在 young 区的停留时间。<br>
<!-- -->默认情况下，LRU 链表中 old 区占 37%；同一页再次访问提升的最小时间间隔是 1000 毫秒。<br>
<!-- -->也就是说，如果某页在 1 秒内被多次访问，只会计算一次，不会立刻升级为热点页，防止短时间批量访问导致缓存污染。<br>
<!-- -->----这部分是帮助大家理解 end，面试中可不背----</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="日志">日志<a href="#日志" class="hash-link" aria-label="Direct link to 日志" title="Direct link to 日志">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="mysql-日志文件有哪些">🌟MySQL 日志文件有哪些？<a href="#mysql-日志文件有哪些" class="hash-link" aria-label="Direct link to 🌟MySQL 日志文件有哪些？" title="Direct link to 🌟MySQL 日志文件有哪些？">​</a></h3>
<p>有 6 大类，其中错误日志用于问题诊断，</p>
<ul>
<li><strong>慢查询</strong>日志用于 SQL 性能分析，</li>
<li>general log 用于记录所有的 SQL 语句，</li>
<li><strong>binlog</strong> 用于主从复制和数据恢复，</li>
<li><strong>redo log</strong> 用于保证事务持久性，</li>
<li><strong>undo log</strong> 用于事务回滚和 MVCC。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="请重点说说-binlog">请重点说说 binlog？<a href="#请重点说说-binlog" class="hash-link" aria-label="Direct link to 请重点说说 binlog？" title="Direct link to 请重点说说 binlog？">​</a></h3>
<p>binlog 是一种物理日志，会在磁盘上记录数据库的所有修改操作。<br>
<!-- -->如果误删了数据，就可以使用 binlog 进行回退到误删之前的状态。<br>
<!-- -->如果要搭建主从复制，就可以让从库定时读取主库的 binlog。<br>
<!-- -->MySQL 提供了三种格式的 binlog：Statement、Row 和 Mixed，分别对应 SQL 语句级别、行级别和混合级别，默认为行级别</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="binlog配置">binlog配置<a href="#binlog配置" class="hash-link" aria-label="Direct link to binlog配置" title="Direct link to binlog配置">​</a></h4>
<p><code>log_bin = mysql-bin</code> 用于启用 binlog，这样就可以在 MySQL 的数据目录中找到 db-bin.000001、db-bin.000002 等日志文件。<br>
<code>max_binlog_size=104857600</code> 用于设置每个 binlog 文件的大小，不建议设置太大，网络传送起来比较麻烦。</p>
<p>当 binlog 文件达到 max_binlog_size 时，MySQL 会关闭当前文件并创建一个新的 binlog 文件。<br>
<code>expire_logs_days = 7</code> 用于设置 binlog 文件的自动过期时间为 7 天。过期的 binlog 文件会被自动删除。防止长时间累积的 binlog 文件占用过多存储空间，<br>
<code>sync_binlog=0</code>，设置每多少次 binlog 写操作会触发一次磁盘同步操作。默认值为 0，表示 MySQL 不会主动触发同步操作，而是依赖操作系统的磁盘缓存策略。</p>
<p>即当执行写操作时，数据会先写入缓存，当缓存区满了再由操作系统将数据一次性刷入磁盘。<br>
<!-- -->如果设置为 1，表示每次 binlog 写操作后都会同步到磁盘，虽然可以保证数据能够及时写入磁盘，但会降低性能。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="有了binlog为什么还要undolog-redolog"><a href="https://javabetter.cn/sidebar/sanfene/mysql.html#%E6%9C%89%E4%BA%86binlog%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81undolog-redolog" target="_blank" rel="noopener noreferrer">有了binlog为什么还要undolog redolog？</a><a href="#有了binlog为什么还要undolog-redolog" class="hash-link" aria-label="Direct link to 有了binlog为什么还要undolog-redolog" title="Direct link to 有了binlog为什么还要undolog-redolog">​</a></h3>
<p>binlog 属于 Server 层，与存储引擎无关，无法直接操作物理数据页。
而 redo log 和 undo log 是 InnoDB 存储引擎实现 ACID 的基石。<br>
<!-- -->binlog 会记录整个 SQL 或行变化；redo log 是为了恢复“已提交但未刷盘”的数据，undo log 是为了撤销未提交的事务。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说-redo-log-的工作机制"><a href="https://javabetter.cn/sidebar/sanfene/mysql.html#%E8%AF%B4%E8%AF%B4-redo-log-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener noreferrer">说说 redo log 的工作机制？</a><a href="#说说-redo-log-的工作机制" class="hash-link" aria-label="Direct link to 说说-redo-log-的工作机制" title="Direct link to 说说-redo-log-的工作机制">​</a></h3>
<p>当事务启动时，MySQL 会为该事务分配一个唯一标识符。<br>
<!-- -->在事务执行过程中，每次对数据进行修改，MySQL 都会生成一条 Redo Log，记录修改前后的数据状态。<br>
<!-- -->这些 Redo Log 首先会被写入内存中的 Redo Log Buffer。<br>
<!-- -->当事务提交时，MySQL 再将 Redo Log Buffer 中的记录刷新到磁盘上的 Redo Log 文件中。<br>
<!-- -->只有当 Redo Log 成功写入磁盘，事务才算真正提交成功。<br>
<img decoding="async" loading="lazy" alt="redo写入" src="/doc/assets/images/redo写入-362296f7b85aafcbf69a40b823cacd5b.png" width="745" height="527" class="img_ev3q">
当 MySQL 崩溃重启时，会先检查 Redo Log。对于已提交的事务，MySQL 会重放 Redo Log 中的记录。<br>
<img decoding="async" loading="lazy" alt="redo崩溃恢复" src="/doc/assets/images/redo崩溃恢复-72d1108066d1fd3f808d040d7d752b2c.png" width="895" height="341" class="img_ev3q"></p>
<p>对于未提交的事务，MySQL 会通过 Undo Log 回滚这些修改，确保数据恢复到崩溃前的一致性状态。<br>
<!-- -->Redo Log 是循环使用的，当文件写满后会覆盖最早的记录。<br>
<!-- -->为避免覆盖未持久化的记录，MySQL 会定期执行 CheckPoint 操作，将内存中的数据页刷新到磁盘，并记录 CheckPoint 点。<br>
<img decoding="async" loading="lazy" alt="事务执行过程" src="/doc/assets/images/事务执行过程-f49374b95cb1a3822afe9361a2ed3263.png" width="1788" height="906" class="img_ev3q">
重启时，MySQL 只会重放 CheckPoint 之后的 Redo Log，从而提高恢复效率。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="redo-log-文件的大小是固定的吗"><a href="https://javabetter.cn/sidebar/sanfene/mysql.html#redo-log-%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%98%AF%E5%9B%BA%E5%AE%9A%E7%9A%84%E5%90%97" target="_blank" rel="noopener noreferrer">redo log 文件的大小是固定的吗？</a><a href="#redo-log-文件的大小是固定的吗" class="hash-link" aria-label="Direct link to redo-log-文件的大小是固定的吗" title="Direct link to redo-log-文件的大小是固定的吗">​</a></h4>
<p>redo log 文件是固定大小的，通常配置为一组文件，使用环形方式写入，旧的日志会在空间需要时被覆盖。<br>
<img decoding="async" loading="lazy" alt="redolog结构" src="/doc/assets/images/redolog结构-830d7ca1440042a244a7e0db680c6715.png" width="1080" height="364" class="img_ev3q">
命名方式为 <code>ib_logfile0、iblogfile1、、、iblogfilen</code>。默认 2 个文件，每个文件大小为 48MB。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="说说-wal"><a href="https://javabetter.cn/sidebar/sanfene/mysql.html#%E8%AF%B4%E8%AF%B4-wal" target="_blank" rel="noopener noreferrer">说说 WAL？</a><a href="#说说-wal" class="hash-link" aria-label="Direct link to 说说-wal" title="Direct link to 说说-wal">​</a></h4>
<blockquote>
<p>WAL——Write-Ahead Logging。
预写日志是 InnoDB 实现事务持久化的核心机制，
它的思想是：先写日志再刷磁盘。</p>
</blockquote>
<p><img decoding="async" loading="lazy" alt="数据写入到磁盘的过程" src="/doc/assets/images/数据写入到磁盘的过程-0f9a598bee302172835b72ac9c969d56.png" width="720" height="614" class="img_ev3q">
WAL 的好处是更新时不直接写数据页，而是先写一份变更记录到 redo log，后台再慢慢把真正的数据页刷盘，一举多得。<br>
<!-- -->redo log 是顺序写， 比刷盘随机写的效率更高</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="binlog-和-redo-log-有什么区别"><a href="https://javabetter.cn/sidebar/sanfene/mysql.html#_29-binlog-%E5%92%8C-redo-log-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener noreferrer">binlog 和 redo log 有什么区别？</a><a href="#binlog-和-redo-log-有什么区别" class="hash-link" aria-label="Direct link to binlog-和-redo-log-有什么区别" title="Direct link to binlog-和-redo-log-有什么区别">​</a></h3>
<p>binlog 由 MySQL 的 Server 层实现，与存储引擎无关；redo log 由 InnoDB 存储引擎实现。<br>
<img decoding="async" loading="lazy" alt="mysql日志和对应分层" src="/doc/assets/images/mysql日志和对应分层-61d1323cbd4b9ab38695eea782c0593b.png" width="621" height="621" class="img_ev3q">
binlog 记录的是逻辑日志，包括原始的 SQL 语句或者行数据变化，例如“将 id=2 这行数据的 age 字段+1”。<br>
<!-- -->redo log 记录物理日志，即数据页的具体修改，例如“将 page_id=123 上 offset=0x40 的数据从 18 修改为 26”。</p>
<p>binlog 是追加写入的，文件写满后会新建文件继续写入，不会覆盖历史日志，保存的是全量操作记录；redo log 是循环写入的，空间是固定的，写满后会覆盖旧的日志，仅保存未刷盘的脏页日志，已持久化的数据会被清除。<br>
<!-- -->另外，为保证两种日志的一致性，innodb 采用了两阶段提交策略，redo log 在事务执行过程中持续写入，并在事务提交前进入 prepare 状态；binlog 在事务提交的最后阶段写入，之后 redo log 会被标记为 commit 状态。<br>
<!-- -->可以通过回放 binlog 实现数据同步或者恢复到指定时间点；redo log 用来确保事务提交后即使系统宕机，数据仍然可以通过重放 redo log 恢复。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么要两阶段提交呢">🌟为什么要两阶段提交呢？<a href="#为什么要两阶段提交呢" class="hash-link" aria-label="Direct link to 🌟为什么要两阶段提交呢？" title="Direct link to 🌟为什么要两阶段提交呢？">​</a></h3>
<p>为了保证 redo log 和 binlog 中的数据一致性，防止主从复制和事务状态不一致。<br>
<!-- -->![mysql 二阶段提交](image/mysql-review/mysql 二阶段提交.png)</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="为什么-2pc-能保证-redo-log-和-binlog-的强致性">为什么 2PC 能保证 redo log 和 binlog 的强⼀致性？<a href="#为什么-2pc-能保证-redo-log-和-binlog-的强致性" class="hash-link" aria-label="Direct link to 为什么 2PC 能保证 redo log 和 binlog 的强⼀致性？" title="Direct link to 为什么 2PC 能保证 redo log 和 binlog 的强⼀致性？">​</a></h4>
<p>假如 MySQL 在预写 redo log 之后、写入 binlog 之前崩溃。那么 MySQL 重启后 InnoDB 会回滚该事务，因为 redo log 不是提交状态。并且由于 binlog 中没有写入数据，所以从库也不会有该事务的数据。<br>
<img decoding="async" loading="lazy" alt="redo-binlog之间crash" src="/doc/assets/images/redo-binlog之间crash-15ffd8976a8ebc9fdd695abb58797da4.png" width="902" height="554" class="img_ev3q">
假如 MySQL 在写入 binlog 之后、redo log 提交之前崩溃。那么 MySQL 重启后 InnoDB 会提交该事务，因为 redo log 是完整的 prepare 状态。并且由于 binlog 中有写入数据，所以从库也会同步到该事务的数据。t3</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="xid-了解吗">XID 了解吗？<a href="#xid-了解吗" class="hash-link" aria-label="Direct link to XID 了解吗？" title="Direct link to XID 了解吗？">​</a></h4>
<p>XID 是 binlog 中用来标识事务提交的唯一标识符。<br>
<!-- -->在事务提交时，会写入一个 XID_EVENT 到 binlog，表示这个事务真正完成了。<br>
<!-- -->它不仅用于主从复制中事务完整性的判断，也在崩溃恢复中对 redo log 和 binlog 的一致性校验起到关键作用。
XID 可以帮助 MySQL 判断哪些 redo log 是已提交的，哪些是未提交需要回滚的，是两阶段提交机制中非常关键的一环。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redo-log-的写入过程了解吗">🌟redo log 的写入过程了解吗？<a href="#redo-log-的写入过程了解吗" class="hash-link" aria-label="Direct link to 🌟redo log 的写入过程了解吗？" title="Direct link to 🌟redo log 的写入过程了解吗？">​</a></h3>
<p>InnoDB 会先将 Redo Log 写入内存中的 Redo Log Buffer，之后再以一定的频率刷入到磁盘的 Redo Log File 中。
<img decoding="async" loading="lazy" alt="redo-to-disk" src="/doc/assets/images/redo-to-disk-c7c55d752aaeae70a1603b95629d46c4.png" width="918" height="412" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="哪些场景会触发-redo-log-的刷盘动作">哪些场景会触发 redo log 的刷盘动作？<a href="#哪些场景会触发-redo-log-的刷盘动作" class="hash-link" aria-label="Direct link to 哪些场景会触发 redo log 的刷盘动作？" title="Direct link to 哪些场景会触发 redo log 的刷盘动作？">​</a></h4>
<ul>
<li>比如说 Redo Log Buffer 的空间不足时</li>
<li>事务提交时</li>
<li>触发 Checkpoint 时，后台线程定期刷盘时
不过，Redo Log Buffer 刷盘到 Redo Log File 还会涉及到操作系统的磁盘缓存策略，可能不会立即刷盘，而是等待一定时间后才刷盘。
<img decoding="async" loading="lazy" alt="刷盘" src="/doc/assets/images/刷盘-846d13fd0e7cd5efcaff9662554c263f.png" width="962" height="1262" class="img_ev3q"></li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="innodb_flush_log_at_trx_commit-参数你了解多少">innodb_flush_log_at_trx_commit 参数你了解多少？<a href="#innodb_flush_log_at_trx_commit-参数你了解多少" class="hash-link" aria-label="Direct link to innodb_flush_log_at_trx_commit 参数你了解多少？" title="Direct link to innodb_flush_log_at_trx_commit 参数你了解多少？">​</a></h4>
<p>innodb_flush_log_at_trx_commit 参数是用来控制事务提交时，Redo Log 的刷盘策略，一共有三种。<br>
<img decoding="async" loading="lazy" alt="innodb_flush_log_at_trx_commit参数的区别" src="/doc/assets/images/innodb_flush_log_at_trx_commit参数的区别-48976aa00f013d26ff3a9c479cb6453a.png" width="1069" height="265" class="img_ev3q"></p>
<ol>
<li>0 表示事务提交时不刷盘，而是交给后台线程每隔 1 秒执行一次。这种方式性能最好，但是在 MySQL 宕机时可能会丢失一秒内的事务。</li>
<li>1 表示事务提交时会立即刷盘，确保事务提交后数据就持久化到磁盘。这种方式是最安全的，也是 InnoDB 的默认值。</li>
<li>2 表示事务提交时只把 Redo Log Buffer 写入到 Page Cache，由操作系统决定什么时候刷盘。操作系统宕机时，可能会丢失一部分数据。</li>
</ol>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="一个没有提交事务的-redo-log会不会刷盘">一个没有提交事务的 redo log，会不会刷盘？<a href="#一个没有提交事务的-redo-log会不会刷盘" class="hash-link" aria-label="Direct link to 一个没有提交事务的 redo log，会不会刷盘？" title="Direct link to 一个没有提交事务的 redo log，会不会刷盘？">​</a></h4>
<p>InnoDB 有一个后台线程，每隔 1 秒会把 Redo Log Buffer 中的日志写入到文件系统的缓存中，然后调用刷盘操作。<br>
<img decoding="async" loading="lazy" alt="后台刷redo" src="/doc/assets/images/后台刷redo-ef3941fda0f2861e0c655237babb4d9f.png" width="915" height="487" class="img_ev3q">
因此，一个没有提交事务的 Redo Log 也可能会被刷新到磁盘中。<br>
<!-- -->另外，如果当 Redo Log Buffer 占用的空间即将达到 innodb_log_buffer_size 的一半时，也会触发刷盘操作。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="redo-log-buffer-是顺序写还是随机写">Redo Log Buffer 是顺序写还是随机写？<a href="#redo-log-buffer-是顺序写还是随机写" class="hash-link" aria-label="Direct link to Redo Log Buffer 是顺序写还是随机写？" title="Direct link to Redo Log Buffer 是顺序写还是随机写？">​</a></h4>
<p>MySQL 在启动后会向操作系统申请一块连续的内存空间作为 Redo Log Buffer，并将其分为若干个连续的 Redo Log Block。<br>
<!-- -->那为了提高写入效率，Redo Log Buffer 采用了顺序写入的方式，会先往前面的 Redo Log Block 中写入，当写满后再往后面的 Block 中写入。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="buf_next_to_write-了解吗">buf_next_to_write 了解吗？<a href="#buf_next_to_write-了解吗" class="hash-link" aria-label="Direct link to buf_next_to_write 了解吗？" title="Direct link to buf_next_to_write 了解吗？">​</a></h4>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="了解-mtr-吗">了解 MTR 吗？<a href="#了解-mtr-吗" class="hash-link" aria-label="Direct link to 了解 MTR 吗？" title="Direct link to 了解 MTR 吗？">​</a></h4>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="redo-log-block-的结构了解吗">Redo Log Block 的结构了解吗？<a href="#redo-log-block-的结构了解吗" class="hash-link" aria-label="Direct link to Redo Log Block 的结构了解吗？" title="Direct link to Redo Log Block 的结构了解吗？">​</a></h4>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="redo-log-block-为什么设计成-512-字节">Redo Log Block 为什么设计成 512 字节？<a href="#redo-log-block-为什么设计成-512-字节" class="hash-link" aria-label="Direct link to Redo Log Block 为什么设计成 512 字节？" title="Direct link to Redo Log Block 为什么设计成 512 字节？">​</a></h4>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="lsn-了解吗">LSN 了解吗？<a href="#lsn-了解吗" class="hash-link" aria-label="Direct link to LSN 了解吗？" title="Direct link to LSN 了解吗？">​</a></h4>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="checkpoint-了解多少waitx">Checkpoint 了解多少？waitx<a href="#checkpoint-了解多少waitx" class="hash-link" aria-label="Direct link to Checkpoint 了解多少？waitx" title="Direct link to Checkpoint 了解多少？waitx">​</a></h4>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是慢-sql">🌟什么是慢 SQL？<a href="#什么是慢-sql" class="hash-link" aria-label="Direct link to 🌟什么是慢 SQL？" title="Direct link to 🌟什么是慢 SQL？">​</a></h3>
<p>MySQL 中有一个叫 long_query_time 的参数，原则上执行时间超过该参数值的 SQL 就是慢 SQL，会被记录到慢查询日志中。</p>
<p><a href="https://juejin.cn/post/7048974570228809741" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/7048974570228809741</a></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="sql-的执行过程了解吗">SQL 的执行过程了解吗？<a href="#sql-的执行过程了解吗" class="hash-link" aria-label="Direct link to SQL 的执行过程了解吗？" title="Direct link to SQL 的执行过程了解吗？">​</a></h3>
<p>SQL 的执行过程大致可以分为六个阶段：连接管理、语法解析、语义分析、查询优化、执行器调度、存储引擎读写等。Server 层负责理解和规划 SQL 怎么执行，存储引擎层负责数据的真正读写</p>
<p>----这部分是帮助大家理解 start，面试中可不背----
来详细拆解一下：
客户端发送 SQL 语句给 MySQL 服务器。<br>
<!-- -->如果查询缓存打开则会优先查询缓存，缓存中有对应的结果就直接返回。不过，MySQL 8.0 已经移除了查询缓存。这部分的功能正在被 Redis 等缓存中间件取代。<br>
<!-- -->分析器对 SQL 语句进行语法分析，判断是否有语法错误。<br>
<!-- -->搞清楚 SQL 语句要干嘛后，MySQL 会通过优化器生成执行计划。<br>
<!-- -->执行器调用存储引擎的接口，执行 SQL 语句。<br>
<!-- -->SQL 执行过程中，优化器通过成本计算预估出执行效率最高的方式，基本的预估维度为：</p>
<p>IO 成本：从磁盘读取数据到内存的开销。<br>
<!-- -->CPU 成本：CPU 处理内存中数据的开销。<br>
<!-- -->基于这两个维度，可以得出影响 SQL 执行效率的因素有：</p>
<p>①、IO 成本，数据量越大，IO 成本越高。所以要尽量查询必要的字段；尽量分页查询；尽量通过索引加快查询。
②、CPU 成本，尽量避免复杂的查询条件，如有必要，考虑对子查询结果进行过滤。<br>
<!-- -->----这部分是帮助大家理解 end，面试中可不背----</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何优化慢-sql-呢">如何优化慢 SQL 呢？<a href="#如何优化慢-sql-呢" class="hash-link" aria-label="Direct link to 如何优化慢 SQL 呢？" title="Direct link to 如何优化慢 SQL 呢？">​</a></h3>
<p>首先，需要找到那些比较慢的 SQL，可以通过启用慢查询日志，记录那些超过指定执行时间的 SQL 查询。<br>
<!-- -->也可以使用 show processlist; 命令查看当前正在执行的 SQL 语句，找出执行时间较长的 SQL。<br>
<!-- -->或者在业务基建中加入对慢 SQL 的监控，常见的方案有字节码插桩、连接池扩展、ORM 框架扩展等。<br>
<!-- -->然后，使用 EXPLAIN 查看慢 SQL 的执行计划，看看有没有用索引，大部分情况下，慢 SQL 的原因都是因为没有用到索引。<br>
<!-- -->最后，根据分析结果，通过添加索引、优化查询条件、减少返回字段等方式进行优化。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="你知道哪些方法来优化-sql">🌟你知道哪些方法来优化 SQL？<a href="#你知道哪些方法来优化-sql" class="hash-link" aria-label="Direct link to 🌟你知道哪些方法来优化 SQL？" title="Direct link to 🌟你知道哪些方法来优化 SQL？">​</a></h3>
<p>SQL 优化的方法非常多，但本质上就一句话：尽可能少地扫描、尽快地返回结果。<br>
<!-- -->最常见的做法就是加索引、改写 SQL 让它用上索引，比如说使用覆盖索引、让联合索引遵守最左前缀原则等。<br>
<img decoding="async" loading="lazy" alt="sql优化" src="/doc/assets/images/sql优化-e85bebbff2bf9a3fd200a21a34e01059.png" width="1238" height="1426" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何利用覆盖索引">如何利用覆盖索引？<a href="#如何利用覆盖索引" class="hash-link" aria-label="Direct link to 如何利用覆盖索引？" title="Direct link to 如何利用覆盖索引？">​</a></h3>
<p>覆盖索引的核心是“查询所需的字段都在同一个索引里”，这样 MySQL 就不需要回表，直接从索引中返回结果。<br>
<img decoding="async" loading="lazy" alt="覆盖索引" src="/doc/assets/images/覆盖索引-355bb0b7c9175c8fab1e223630d25208.png" width="1789" height="654" class="img_ev3q">
----这部分是帮助大家理解 start，面试中可不背----
举个例子，现在要从 test 表中查询 city 为上海的 name 字段。
select name from test where city=&#x27;上海&#x27;
如果仅在 city 字段上添加索引，那么这条查询语句会先通过索引找到 city 为上海的行，然后再回表查询 name 字段。
为了避免回表查询，可以在 city 和 name 字段上建立联合索引，这样查询结果就可以直接从索引中获取。
alter table test add index index1(city,name);
----这部分是帮助大家理解 end，面试中可不背----</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何正确使用联合索引">如何正确使用联合索引？<a href="#如何正确使用联合索引" class="hash-link" aria-label="Direct link to 如何正确使用联合索引？" title="Direct link to 如何正确使用联合索引？">​</a></h3>
<p>使用联合索引最重要的一条是遵守最左前缀原则，也就是查询条件需要从索引的左侧字段开始。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何进行分页优化">如何进行分页优化？<a href="#如何进行分页优化" class="hash-link" aria-label="Direct link to 如何进行分页优化？" title="Direct link to 如何进行分页优化？">​</a></h3>
<p>分页优化的核心是避免深度偏移带来的全表扫描，可以通过两种方式来优化：</p>
<ol>
<li>延迟关联 : 通过使用覆盖索引（Covering Index）快速定位到需要的主键ID，然后再通过主键ID关联回原表，获取所需的全部行数据。</li>
<li>添加书签 : 也需要索引覆盖，需要有序且唯一的字段组合，不支持随机跳页</li>
</ol>
<p>延迟关联适用于需要从多个表中获取数据且主表行数较多的情况。它首先从索引表中检索出需要的行 ID，然后再根据这些 ID 去关联其他的表获取详细信息。</p>
<div class="language-mysql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-mysql codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">SELECT e.id, e.name, d.details</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">FROM employees e</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">JOIN department d ON e.department_id = d.id</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ORDER BY e.id</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LIMIT 1000, 20;</span><br></span></code></pre></div></div>
<p>延迟关联后，第一步只查主键，速度快，第二步只处理 20 条数据，效率高。</p>
<div class="language-mysql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-mysql codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">SELECT e.id, e.name, d.details</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">FROM (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SELECT id</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">FROM employees</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ORDER BY id</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LIMIT 1000, 20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) AS sub</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">JOIN employees e ON sub.id = e.id</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">JOIN department d ON e.department_id = d.id;</span><br></span></code></pre></div></div>
<p>假设需要对用户表进行分页。<br>
<!-- -->添加书签的方式是通过记住上一次查询返回的最后一行主键值，然后在下一次查询的时候从这个值开始，从而跳过偏移量计算，仅扫描目标数据，适合翻页、资讯流等场景。<br>
<!-- -->通过添加书签来优化后，查询不再使用OFFSET，而是从上一页最后一个用户的 ID 开始查询。这种方法可以有效避免不必要的数据扫描，提高了分页查询的效率。</p>
<div class="language-mysql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-mysql codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">-- 1. 获取第一页数据，按需要排序的字段（如 create_time 和 id）排序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SELECT id, name, create_time</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">FROM promo_feedback_rule</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ORDER BY create_time DESC, id DESC</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LIMIT 10;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-- 2. 获取下一页数据：将上一页最后一条记录的 create_time 和 id 作为“书签”带到下一页查询条件中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SELECT id, name, create_time</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">FROM promo_feedback_rule</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE (create_time &lt; &#x27;2024-01-01 12:00:00&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   OR (create_time = &#x27;2024-01-01 12:00:00&#x27; AND id &lt; 100)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ORDER BY create_time DESC, id DESC</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LIMIT 10;</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么分页会变慢">为什么分页会变慢？<a href="#为什么分页会变慢" class="hash-link" aria-label="Direct link to 为什么分页会变慢？" title="Direct link to 为什么分页会变慢？">​</a></h3>
<p>分页查询的效率问题主要是由于 OFFSET 的存在，OFFSET 会导致 MySQL 必须扫描和跳过 offset + limit 条数据，这个过程是非常耗时的。<br>
<!-- -->比如说，我们要查询第 100000 条数据，那么 MySQL 就必须扫描 100000 条数据，然后再返回 10 条数据。<br>
<!-- -->SELECT * FROM user ORDER BY id LIMIT 100000, 10;<br>
<!-- -->数据越多、偏移越大，就越慢！</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="join-代替子查询有什么好处">JOIN 代替子查询有什么好处？<a href="#join-代替子查询有什么好处" class="hash-link" aria-label="Direct link to JOIN 代替子查询有什么好处？" title="Direct link to JOIN 代替子查询有什么好处？">​</a></h3>
<p>第一，JOIN 的 ON 条件能更直接地触发索引，而子查询可能因嵌套导致索引失效。<br>
<!-- -->第二，JOIN 的一次连接操作替代了子查询的多次重复执行，尤其在大数据量的情况下性能差异明显。</p>
<p>----这部分是帮助大家理解 start，面试中可不背----
比如说我们有两个表 orders 和 customers。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">CREATE TABLE orders (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">order_id INT PRIMARY KEY,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">customer_id INT,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">amount DECIMAL(10,2),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">INDEX idx_customer_id (customer_id)  -- customer_id字段有索引</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CREATE TABLE customers (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">customer_id INT PRIMARY KEY,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">name VARCHAR(100)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">);</span><br></span></code></pre></div></div>
<p>子查询的写法：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">SELECT o.order_id, o.amount,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(SELECT c.name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">FROM customers c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE c.customer_id = o.customer_id) AS customer_name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">FROM orders o;</span><br></span></code></pre></div></div>
<p>JOIN 的写法：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">SELECT o.order_id, o.amount, c.name AS customer_name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">FROM orders o</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">JOIN customers c ON o.customer_id = c.customer_id;</span><br></span></code></pre></div></div>
<ol>
<li>索引使用
内层子查询 WHERE c.customer_id = o.customer_id 每次执行时，可能无法直接利用 orders 表的 customer_id 索引。
JOIN 的 ON 条件 o.customer_id = c.customer_id 可以直接利用 orders 的 idx_customer_id 索引，加速连接过程。</li>
<li>执行计划
子查询会被重复执行（每次外层 orders 行都会触发一次子查询），导致全表扫描。<br>
<!-- -->优化器可能选择通过索引快速关联两张表，减少数据扫描量。例如，先通过 orders 的索引找到 customer_id，再与 customers 主键快速匹配。</li>
<li>性能表现
当 orders 表数据量大时，子查询可能因重复执行导致性能急剧下降。
JOIN 的一次连接操作通常更高效，尤其在大数据量时。</li>
<li>对于子查询，执行流程是这样的：<br>
<!-- -->外层 orders 表的每一行都会触发一次子查询。<br>
<!-- -->如果 orders 表有 1000 条记录，则子查询会执行 1000 次。<br>
<!-- -->每次子查询都需要单独查询 customers 表（即使 customer_id 相同）。</li>
</ol>
<p>而 JOIN 的执行流程是这样的：<br>
<!-- -->数据库优化器会将两张表的连接操作合并为一次执行。
通过索引（如 orders.customer_id 和 customers.customer_id）快速关联数据。<br>
<!-- -->仅执行一次关联操作，而非多次子查询。<br>
<!-- -->来看一下子查询的执行计划：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">EXPLAIN SELECT o.order_id,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(SELECT c.name FROM customers c WHERE c.customer_id = o.customer_id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">FROM orders o;</span><br></span></code></pre></div></div>
<p>二哥的 Java 进阶之路：子查询的执行计划
子查询（DEPENDENT SUBQUERY）类型表明其依赖外层查询的每一行，导致重复执行。</p>
<p>再对比看一下 JOIN 的执行计划：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">EXPLAIN SELECT o.order_id,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(SELECT c.name FROM customers c WHERE c.customer_id = o.customer_id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">FROM orders o;</span><br></span></code></pre></div></div>
<p>二哥的 Java 进阶之路：JOIN 的执行计划<br>
<!-- -->JOIN 通过 eq_ref 类型直接利用主键（customers.customer_id）快速关联，减少扫描次数。<br>
<!-- -->----这部分是帮助大家理解 end，面试中可不背----</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="join操作为什么要小表驱动大表">JOIN操作为什么要小表驱动大表？<a href="#join操作为什么要小表驱动大表" class="hash-link" aria-label="Direct link to JOIN操作为什么要小表驱动大表？" title="Direct link to JOIN操作为什么要小表驱动大表？">​</a></h3>
<p>第一，如果大表的 JOIN 字段有索引，那么小表的每一行都可以通过索引快速匹配大表。<br>
<!-- -->时间复杂度为小表行数 N 乘以大表索引查找复杂度 log(大表行数 M)，总复杂度为 N<em>log(M)。<br>
<!-- -->显然小表做驱动表比大表做驱动表的时间复杂度 M</em>log(N) 更低。<br>
<img decoding="async" loading="lazy" alt="有索引join" src="/doc/assets/images/有索引join-5b97f33e36ac5d81c61e44dfdf9e639c.png" width="1182" height="902" class="img_ev3q"></p>
<p>第二，如果大表没有索引，需要将小表的数据加载到内存，再全表扫描大表进行匹配。<br>
<img decoding="async" loading="lazy" alt="无索引join" src="/doc/assets/images/无索引join-1a4778fe0a2d484710e1c04ac79db7ad.png" width="950" height="816" class="img_ev3q">
时间复杂度为小表分段数 K 乘以大表行数 M，其中 K = 小表行数 N / 内存大小 join_buffer_size。<br>
<!-- -->显然小表做驱动表的时候 K 的值更小，大表做驱动表的时候需要多次分段。</p>
<p>当使用 left join 时，左表是驱动表，右表是被驱动表。<br>
<!-- -->当使用 right join 时，刚好相反。<br>
<!-- -->当使用 join 时，MySQL 会选择数据量比较小的表作为驱动表，大表作为被驱动表。<br>
<!-- -->这里的小表指实际参与 JOIN 的数据量，而不是表的总行数。大表经过 where 条件过滤后也可能成为逻辑小表。<br>
<!-- -->也可以强制通过 STRAIGHT_JOIN 提示 MySQL 使用指定的驱动表。<br>
<!-- -->ps:  自己实验， left join 和right join不是绝对的，如果在where包含右边非空条件，可能会被优化为inner join 查询吗，使用 EXPLAIN命令查看执行计划确定</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么要避免使用-join-关联太多的表">为什么要避免使用 JOIN 关联太多的表？<a href="#为什么要避免使用-join-关联太多的表" class="hash-link" aria-label="Direct link to 为什么要避免使用 JOIN 关联太多的表？" title="Direct link to 为什么要避免使用 JOIN 关联太多的表？">​</a></h3>
<p>第一，多表 JOIN 的执行路径会随着表的数量呈现指数级增长，优化器需要估算所有路径的成本，有可能会导致出现大表驱动小表的情况。<br>
<!-- -->第二，多表 JOIN 需要缓存中间结果集，可能超出 join_buffer_size，这种情况下内存临时表就会转为磁盘临时表，性能也会急剧下降。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何进行排序优化">如何进行排序优化？<a href="#如何进行排序优化" class="hash-link" aria-label="Direct link to 如何进行排序优化？" title="Direct link to 如何进行排序优化？">​</a></h3>
<p>第一，对 ORDER BY 涉及的字段创建索引，避免 filesort。<br>
<!-- -->如果是多个字段，联合索引需要保证 ORDER BY 的列是索引的最左前缀。</p>
<p>第二，可以适当调整排序参数，如增大 sort_buffer_size、max_length_for_sort_data 等，让排序在内存中完成。<br>
<!-- -->----这部分是帮助大家理解 start，面试中可不背----
sort_buffer_size：用于控制排序缓冲区的大小，默认为 256KB。也就是说，如果排序的数据量小于 256KB，MySQL 会在内存中直接排序；否则就要在磁盘上进行 filesort。
max_length_for_sort_data：单行数据的最大长度，会影响排序算法选择。如果单行数据超过该值，MySQL 会使用双路排序，否则使用单路排序。
max_sort_length：限制字符串排序时比较的前缀长度。当 MySQL 不得不对 text、blob 字段进行排序时，会截取前 max_sort_length 个字符进行比较。
----这部分是帮助大家理解 end，面试中可不背----</p>
<p>第三，可以通过 where 和 limit 限制待排序的数据量，减少排序的开销。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是-filesort">什么是 filesort？<a href="#什么是-filesort" class="hash-link" aria-label="Direct link to 什么是 filesort？" title="Direct link to 什么是 filesort？">​</a></h3>
<p><a href="https://petrunia.net/2007/08/29/how-mysql-executes-order-by/" target="_blank" rel="noopener noreferrer">https://petrunia.net/2007/08/29/how-mysql-executes-order-by/</a>
当不能使用索引生成排序结果的时候，MySQL 需要自己进行排序，如果数据量比较小，会在内存中进行；如果数据量比较大就需要写临时文件到磁盘再排序，我们将这个过程称为文件排序。<br>
<img decoding="async" loading="lazy" alt="filesort_文件排序" src="/doc/assets/images/filesort_文件排序-d8bcb5810d2ecd49114ebb888812a4ec.png" width="1168" height="724" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="全字段排序和-rowid-排序了解多少">全字段排序和 rowid 排序了解多少？<a href="#全字段排序和-rowid-排序了解多少" class="hash-link" aria-label="Direct link to 全字段排序和 rowid 排序了解多少？" title="Direct link to 全字段排序和 rowid 排序了解多少？">​</a></h3>
<p>当排序字段是索引字段且满足最左前缀原则时，MySQL 可以直接利用索引的有序性完成排序。<br>
<img decoding="async" loading="lazy" alt="索引排序" src="/doc/assets/images/索引排序-f29298d7bc2268ff2de561e8651a5fa7.png" width="511" height="497" class="img_ev3q">
当无法使用索引排序时，MySQL 需要在内存或磁盘中进行排序操作，分为全字段排序和 rowid 排序两种算法。<br>
<img decoding="async" loading="lazy" alt="全字段排序" src="/doc/assets/images/全字段排序-0a99d6c0b4e0a35f0b9df98612c47bad.png" width="1142" height="856" class="img_ev3q">
全字段排序会一次性取出满足条件行的所有字段，然后在 sort buffer 中进行排序，排序后直接返回结果，无需回表。<br>
<!-- -->以 SELECT * FROM user WHERE name = &quot;王二&quot; ORDER BY age 为例：</p>
<p>从 name 索引中找到第一个满足 name=&#x27;张三&#x27; 的主键 id；根据主键 id 取出整行所有的字段，存入 sort buffer；<br>
<!-- -->重复上述过程直到处理完所有满足条件的行<br>
<!-- -->对 sort buffer 中的数据按 age 排序，返回结果。
优点是仅需要一次磁盘 IO，缺点是内存占用大，如果数量超过 sort buffer 的话，需要分片读取并借助临时文件合并排序，IO 次数反而会增加。
也无法处理包含 text 和 blob 类型的字段。<br>
<img decoding="async" loading="lazy" alt="rowId排序" src="/doc/assets/images/rowId排序-83b2861b82ddabfb4249b99c534a4ce2.png" width="1142" height="856" class="img_ev3q"></p>
<p>rowid 排序分为两个阶段：<br>
<!-- -->第一阶段：根据查询条件取出排序字段和主键 ID，存入 sort buffer 进行排序；<br>
<!-- -->第二阶段：根据排序后的主键 ID 回表取出其他需要的字段。<br>
<!-- -->同样以 SELECT * FROM user WHERE name = &quot;王二&quot; ORDER BY age 为例：</p>
<p>从 name 索引中找到第一个满足 name=&#x27;张三&#x27; 的主键 id；<br>
<!-- -->根据主键 id 取出排序字段 age，连同主键 id 一起存入 sort buffer；
重复上述过程直到处理完所有满足条件的行<br>
<!-- -->对 sort buffer 中的数据按 age 排序；<br>
<!-- -->遍历排序后的主键 id，回表取出其他所需字段，返回结果。<br>
<!-- -->优点是内存占用较少，适合字段多或者数据量大的场景，缺点是需要两次磁盘 IO。</p>
<p><strong>MySQL 会根据系统变量 max_length_for_sort_data 和查询字段的总大小来决定使用全字段排序还是 rowid 排序。</strong><br>
<strong><code>如果查询字段总长度 &lt;= max_length_for_sort_data，MySQL 会使用全字段排序；否则会使用 rowid 排序</code></strong></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="你对-sort_merge_passes-参数了解吗">你对 Sort_merge_passes 参数了解吗？<a href="#你对-sort_merge_passes-参数了解吗" class="hash-link" aria-label="Direct link to 你对 Sort_merge_passes 参数了解吗？" title="Direct link to 你对 Sort_merge_passes 参数了解吗？">​</a></h3>
<p>Sort_merge_passes 是一个状态变量，用于统计 MySQL 在执行排序操作时进行归并排序的次数。<br>
<!-- -->当 MySQL 需要进行排序但排序数据无法完全放入 sort_buffer_size 定义的内存缓冲区时，就会使用临时文件进行外部排序，这时就会产生 Sort_merge_passes。<br>
<!-- -->如果 Sort_merge_passes 在短时间内快速激增，说明排序操作的数据量较大，需要调整 sort_buffer_size 或者优化查询语句。</p>
<p>MySQL 在执行排序操作时，会经历两个过程：<br>
<!-- -->内存排序阶段，MySQL 首先尝试在 sort buffer 中进行排序。如果数据量小于 sort_buffer_size 缓冲区大小，会完全在内存中完成快速排序。<br>
<!-- -->外部排序阶段，如果数据量超过 sort_buffer_size，MySQL 会将数据分成多个块，每块单独排序后写入临时文件，然后对这些已排序的块进行归并排序。每次归并操作都会增加 Sort_merge_passes 的计数。<br>
<img decoding="async" loading="lazy" alt="mysql内存和文件排序" src="/doc/assets/images/mysql内存和文件排序-beaf3d764675000329bab58728f6946a.png" width="1126" height="1296" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="条件下推你了解多少">条件下推你了解多少？<a href="#条件下推你了解多少" class="hash-link" aria-label="Direct link to 条件下推你了解多少？" title="Direct link to 条件下推你了解多少？">​</a></h3>
<p>waitx-wait-vertify<br>
<!-- -->条件下推的核心思想是将外层的过滤条件，比如说 where、join 等，尽可能地下推到查询计划的更底层，比如说子查询、连接操作之前，从而减少中间结果的数据量。<br>
<!-- -->比如说原始查询是：</p>
<div class="language-mysql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-mysql codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">SELECT * FROM (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SELECT * FROM orders WHERE total &gt; 100</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) AS subquery</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE subquery.status = &#x27;shipped&#x27;;</span><br></span></code></pre></div></div>
<p>就可以将条件下推到子查询：</p>
<div class="language-mysql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-mysql codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">SELECT * FROM (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SELECT * FROM orders WHERE total &gt; 100 AND status = &#x27;shipped&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) AS subquery;</span><br></span></code></pre></div></div>
<p>这样就可以减少查询返回的数据量，避免外层再过滤。<br>
<!-- -->再比如说 union 中的原始查询是：</p>
<div class="language-mysql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-mysql codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(SELECT * FROM t1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">UNION ALL</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(SELECT * FROM t2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ORDER BY col LIMIT 10;</span><br></span></code></pre></div></div>
<p>就可以将条件下推到每个子查询：</p>
<div class="language-mysql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-mysql codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(SELECT * FROM t1 ORDER BY col LIMIT 10)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">UNION ALL</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(SELECT * FROM t2 ORDER BY col LIMIT 10);</span><br></span></code></pre></div></div>
<p>每个子查询仅返回前 10 条数据，减少临时表的数据量。</p>
<p>再比如说连接查询 join 中的原始查询是：</p>
<div class="language-mysql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-mysql codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">SELECT * FROM orders</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">JOIN customers ON orders.customer_id = customers.id</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE customers.country = &#x27;china&#x27;;</span><br></span></code></pre></div></div>
<p>就可以将条件下推到表扫描的时候：</p>
<div class="language-mysql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-mysql codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">SELECT * FROM orders</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">JOIN (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SELECT * FROM customers WHERE country = &#x27;china&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) AS filtered_customers</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ON orders.customer_id = filtered_customers.id;</span><br></span></code></pre></div></div>
<p>先过滤 customers 表，减少 join 时的数据量。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么要尽量避免使用-select-">为什么要尽量避免使用 select *？<a href="#为什么要尽量避免使用-select-" class="hash-link" aria-label="Direct link to 为什么要尽量避免使用 select *？" title="Direct link to 为什么要尽量避免使用 select *？">​</a></h3>
<p>SELECT * 会强制 MySQL 读取表中所有字段的数据，包括应用程序可能并不需要的，比如 text、blob 类型的大字段。<br>
<!-- -->在行内不存储实际内容而是指针的时候才有用
加载冗余数据会占用更多的缓存空间，从而挤占其他重要数据的缓存资源，降低整体系统的吞吐量。<br>
<!-- -->也会增加网络传输的开销，尤其是在大字段的情况下。<br>
<!-- -->最重要的是，SELECT * 可能会导致覆盖索引失效，本来可以走索引的查询最后变成了全表扫描。</p>
<div class="language-mysql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-mysql codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">-- 使用覆盖索引（假设索引为 idx_country）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SELECT id, country FROM users WHERE country = &#x27;china&#x27;;  -- 可能仅扫描索引</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-- 使用 SELECT *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SELECT * FROM users WHERE country = &#x27;china&#x27;;            -- 需回表读取所有列</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="你还知道哪些-sql-优化方法">你还知道哪些 SQL 优化方法？<a href="#你还知道哪些-sql-优化方法" class="hash-link" aria-label="Direct link to 你还知道哪些 SQL 优化方法？" title="Direct link to 你还知道哪些 SQL 优化方法？">​</a></h3>
<p>①、避免使用 != 或者 <code>&lt;&gt;</code> 操作符
!= 或者 <code>&lt;&gt;</code> 操作符会导致 MySQL 无法使用索引，从而导致全表扫描。
<code>可以把column&lt;&gt;&#x27;aaa&#x27;，改成column&gt;&#x27;aaa&#x27; or column&lt;&#x27;aaa&#x27;</code>。
②、使用前缀索引
比如，邮箱的后缀一般都是固定的@xxx.com，那么类似这种后面几位为固定值的字段就非常适合定义为前缀索引：<br>
<!-- -->需要注意的是，MySQL 无法利用前缀索引做 order by 和 group by 操作。<br>
<!-- -->③、避免在列上使用函数
在 where 子句中直接对列使用函数会导致索引失效，因为 MySQL 需要对每行的列应用函数后再进行比较。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="explain平常有用过吗">🌟explain平常有用过吗？<a href="#explain平常有用过吗" class="hash-link" aria-label="Direct link to 🌟explain平常有用过吗？" title="Direct link to 🌟explain平常有用过吗？">​</a></h3>
<p>经常用，explain 是 MySQL 提供的一个用于查看 SQL 执行计划的工具，可以帮助我们分析查询语句的性能问题。
<img decoding="async" loading="lazy" alt="img_1.png" src="/doc/assets/images/img_1-f205792ed85b4bd1173b23e6546adbad.png" width="968" height="1344" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="explain-输出结果中常见的字段含义理解吗">explain 输出结果中常见的字段含义理解吗？<a href="#explain-输出结果中常见的字段含义理解吗" class="hash-link" aria-label="Direct link to explain 输出结果中常见的字段含义理解吗？" title="Direct link to explain 输出结果中常见的字段含义理解吗？">​</a></h4>
<p>我会通过它们判断 SQL 有没有走索引、是否全表扫描、预估扫描行数是否太大，以及是否触发了 filesort 或临时表。一旦发现问题，比如 type=ALL 或者 Extra=Using filesort，我会考虑建索引、改写 SQL 或控制查询结果集来做优化。</p>
<p>----这部分是帮助大家理解 start，面试中可不背----</p>
<ol>
<li>①、id 列：查询的执行顺序编号。id 相同：同一执行层级，按 table 列从上到下顺序执行（如多表 JOIN）；id 递增：嵌套子查询，数值越大优先级越高，越先执行。</li>
<li>②、select_type 列：查询的类型。常见的类型有：</li>
</ol>
<ul>
<li>SIMPLE：简单查询，不包含子查询或者 UNION。</li>
<li>PRIMARY：查询中如果包含子查询，则最外层查询被标记为 PRIMARY。需要关注子查询或派生表性能。</li>
<li>SUBQUERY：子查询；需要避免多层嵌套，尽量改写为 JOIN。</li>
<li>DERIVED：派生表（FROM 子句中的子查询）。需要减少派生表数据量，或物化为临时表。</li>
</ul>
<ol start="2">
<li>③、table 列：查的哪个表。</li>
</ol>
<ul>
<li>derivedN：表示派生表（N 对应 id）。</li>
<li>unionNM,N：表示 UNION 合并的结果（M、N 为参与 UNION 的 id）。</li>
</ul>
<ol start="3">
<li>④、type 列：表示 MySQL 在表中找到所需行的方式。</li>
</ol>
<ul>
<li>system，表仅有一行（系统表或衍生表），无需优化。</li>
<li>const：通过主键或唯一索引找到一行（如 WHERE id = 1）。理想情况。</li>
<li>eq_ref：对主键/唯一索引 JOIN 匹配（如 A JOIN B ON A.id = B.id）。确保 JOIN 字段有索引。</li>
<li>ref：非唯一索引匹配（如 WHERE name = &#x27;王二&#x27;，name 有普通索引）。</li>
<li>range：只检索给定范围的行，使用索引来检索。在where语句中使用 <code>bettween...and、&lt;、&gt;、&lt;=、in</code> 等条件查询 type 都是 range。</li>
<li>index：全索引扫描，如果不需要回表，可接受；否则考虑覆盖索引。</li>
<li>ALL：全表扫描，效率最低。</li>
</ul>
<ol start="4">
<li>
<p>⑤、possible_keys 列：可能会用到的索引，但并不一定实际被使用。</p>
</li>
<li>
<p>⑥、key 列：实际使用的索引。如果为 NULL，则没有使用索引。如果为 PRIMARY，则使用了主键索引。</p>
</li>
<li>
<p>⑦、key_len 列：使用的索引字节数，反映索引列的利用率。使用联合索引 (a, b)，key_len 是 a 和 b 的字节总和（仅当查询条件用到 a 或 a+b 时有效）。</p>
</li>
</ol>
<p>⑧、ref 列：与索引列比较的值或列。</p>
<p>const：常量。例如 WHERE column = &#x27;value&#x27;。
func：函数。例如 WHERE column = func(column)。
⑨、rows 列：优化器估算的需要扫描的行数。数值越小越好，若与实际差距大，可能统计信息过期（需 ANALYZE TABLE）。结合 filtered 字段可以计算最终返回行数（rows × filtered）。</p>
<p>⑩、Extra 列：附加信息。</p>
<p>Using index：覆盖索引，无需回表。
Using where：存储引擎返回结果后，Server 层需要再次过滤（条件未完全下推）。
Using temporary ：使用临时表（常见于 GROUP BY、DISTINCT）。
Using filesort：文件排序（常见于 ORDER BY）。考虑为 ORDER BY 字段添加索引。
Select tables optimized away：优化器已优化（如 COUNT(*) 通过索引直接统计）。
Using join buffer：使用连接缓冲区（Block Nested Loop 或 Hash Join）。考虑增大 join_buffer_size。
----这部分是帮助大家理解 end，面试中可不背----</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="type的执行效率等级达到什么级别比较合适">type的执行效率等级，达到什么级别比较合适？<a href="#type的执行效率等级达到什么级别比较合适" class="hash-link" aria-label="Direct link to type的执行效率等级，达到什么级别比较合适？" title="Direct link to type的执行效率等级，达到什么级别比较合适？">​</a></h3>
<p>从高到低的效率排序是 system、const、eq_ref、ref、range、index 和 ALL。
一般情况下，建议 type 值达到 const、eq_ref 或 ref，因为这些类型表明查询使用了索引，效率较高。
如果是范围查询，range 类型也是可以接受的。
ALL 类型表示全表扫描，性能最差，往往不可接受，需要优化。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="索引">索引<a href="#索引" class="hash-link" aria-label="Direct link to 索引" title="Direct link to 索引">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="索引为什么能提高mysql查询效率">🌟索引为什么能提高MySQL查询效率？<a href="#索引为什么能提高mysql查询效率" class="hash-link" aria-label="Direct link to 🌟索引为什么能提高MySQL查询效率？" title="Direct link to 🌟索引为什么能提高MySQL查询效率？">​</a></h3>
<p>索引就像一本书的目录，能让 MySQL 快速定位数据，避免全表扫描。
它一般是 B+ 树结构，查找效率是 O(log n)，比从头到尾扫一遍数据要快得多。
<img decoding="async" loading="lazy" alt="img_2.png" src="/doc/assets/images/img_2-a1600620766806518205d004878ef8f9.png" width="1620" height="1032" class="img_ev3q">
除了查得快，索引还能加速排序、分组、连接等操作。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="能简单说一下索引的分类吗">🌟能简单说一下索引的分类吗？<a href="#能简单说一下索引的分类吗" class="hash-link" aria-label="Direct link to 🌟能简单说一下索引的分类吗？" title="Direct link to 🌟能简单说一下索引的分类吗？">​</a></h3>
<p>从功能上分类的话，有主键索引、唯一索引、全文索引；
从数据结构上分类的话，有 B+ 树索引、哈希索引；
从存储内容上分类的话，有聚簇索引、非聚簇索引。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="你对主键索引了解多少">你对主键索引了解多少？<a href="#你对主键索引了解多少" class="hash-link" aria-label="Direct link to 你对主键索引了解多少？" title="Direct link to 你对主键索引了解多少？">​</a></h3>
<p>主键索引用于唯一标识表中的每条记录，其列值必须唯一且非空。创建主键时，MySQL 会自动生成对应的唯一索引。
<img decoding="async" loading="lazy" alt="img_3.png" src="/doc/assets/images/img_3-98a7b9542fbe0e27158c52dfddc7524f.png" width="1642" height="538" class="img_ev3q">
每个表只能有一个主键索引，一般是表中的自增 id 字段。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="唯一索引和主键索引有什么区别">唯一索引和主键索引有什么区别？<a href="#唯一索引和主键索引有什么区别" class="hash-link" aria-label="Direct link to 唯一索引和主键索引有什么区别？" title="Direct link to 唯一索引和主键索引有什么区别？">​</a></h3>
<p>主键索引=唯一索引+非空。每个表只能有一个主键索引，但可以有多个唯一索引。
主键索引不允许插入 NULL 值，尝试插入 NULL 会报错；唯一索引允许插入多个 NULL 值。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="unique-key-和-unique-index-有什么区别">unique key 和 unique index 有什么区别？<a href="#unique-key-和-unique-index-有什么区别" class="hash-link" aria-label="Direct link to unique key 和 unique index 有什么区别？" title="Direct link to unique key 和 unique index 有什么区别？">​</a></h3>
<p>创建唯一键时，MySQL 会自动生成一个同名的唯一索引；反之，创建唯一索引也会隐式添加唯一性约束。
可通过 UNIQUE KEY uk_name 定义或者 CONSTRAINT uk_name UNIQUE 定义唯一键。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="普通索引和唯一索引有什么区别">普通索引和唯一索引有什么区别？<a href="#普通索引和唯一索引有什么区别" class="hash-link" aria-label="Direct link to 普通索引和唯一索引有什么区别？" title="Direct link to 普通索引和唯一索引有什么区别？">​</a></h3>
<p>普通索引仅用于加速查询，不限制字段值的唯一性；适用于高频写入的字段、范围查询的字段。
唯一索引强制字段值的唯一性，插入或更新时会触发唯一性检查；适用于业务唯一性约束的字段、防止数据重复插入的字段。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="你对全文索引了解多少">你对全文索引了解多少？<a href="#你对全文索引了解多少" class="hash-link" aria-label="Direct link to 你对全文索引了解多少？" title="Direct link to 你对全文索引了解多少？">​</a></h3>
<p>文索引是 MySQL 一种优化文本数据检索的特殊类型索引，适用于 CHAR、VARCHAR 和 TEXT 等字段。</p>
<p>MySQL 5.7 及以上版本内置了 ngram 解析器，可处理中文、日文和韩文等分词。</p>
<p>建表时通过 FULLTEXT (title, body) 来定义。通过 MATCH(col1, col2) AGAINST(&#x27;keyword&#x27;) 进行检索，默认按照降序返回结果，支持布尔模式查询。</p>
<ul>
<li>表示必须包含；</li>
</ul>
<ul>
<li>表示排除；</li>
</ul>
<ul>
<li>表示通配符；
底层使用倒排索引将字段中的文本内容进行分词，然后建立一个倒排表。性能比 LIKE &#x27;%keyword%&#x27; 高很多。</li>
</ul>
<p>---- 这部分是帮助大家理解 start，面试中可不背 ----</p>
<p>倒排索引通过一个辅助表存储单词与单词自身在一个或多个文档中所在位置之间的映射，通常采用关联数组实现。</p>
<p>有两种表现形式：<code>inverted file index（{单词，单词所在文档的ID}）和full inverted index（{单词，(单词所在文档的ID，在具体文档中的位置)}）</code>
比如有这样一个文档：</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> DocumentId  Text  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1          Pease porridge hot, pease porridge cold  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2          Pease porridge in the pot  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3          Nine days old  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4          Some like it hot, some like it cold  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5          Some like it in the pot  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6          Nine days old</span><br></span></code></pre></div></div>
<p>inverted file index 的关联数组存储形式为：</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">days → 3,6  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">old → 3,6  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pease → 1,2  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">porridge → 1,2  </span><br></span></code></pre></div></div>
<p>full inverted index 更加详细：</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">days → (3:5),(6:5)  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">old → (3:11),(6:11)  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pease → (1:1),(1:7),(2:1)  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">porridge → (1:7),(2:7)  </span><br></span></code></pre></div></div>
<p>full inverted index 不仅存储了文档 ID，还存储了单词在文档中的具体位置。</p>
<p>InnoDB 采用的是 full inverted index 的方式实现全文索引。</p>
<p>如果需要处理中文分词的话，一定要记得加上 WITH PARSER ngram，否则可能查不出来数据。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="创建索引有哪些注意点">🌟创建索引有哪些注意点？<a href="#创建索引有哪些注意点" class="hash-link" aria-label="Direct link to 🌟创建索引有哪些注意点？" title="Direct link to 🌟创建索引有哪些注意点？">​</a></h3>
<p>第一，选择合适的字段</p>
<p>比如说频繁出现在 WHERE、JOIN、ORDER BY、GROUP BY 中的字段。
优先选择区分度高的字段，比如用户 ID、手机号等唯一值多的，而不是性别、状态等区分度极低的字段，如果真的需要，可以考虑联合索引。
第二，要控制索引的数量，避免过度索引，每个索引都要占用存储空间，单表的索引数量不建议超过 5 个。</p>
<p>要定期通过 SHOW INDEX FROM table_name 查看索引的使用情况，删除不必要的索引。比如说已经有联合索引 (a, b)，单索引（a）就是冗余的。</p>
<p>第三，联合索引的时候要遵循最左前缀原则，即在查询条件中使用联合索引的第一个字段，才能充分利用索引。</p>
<p>比如说联合索引 (A, B, C) 可支持 A、A+B、A+B+C 的查询，但无法支持 B 或 C 的单独查询。</p>
<p>区分度高的字段放在左侧，等值查询的字段优先于范围查询的字段。例如 WHERE A=1 AND B&gt;10 AND C=2，优先 (A, C, B)。</p>
<p>如果联合索引包含查询的所需字段，还可以避免回表，提高查询效率。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="索引哪些情况下会失效呢">🌟索引哪些情况下会失效呢？<a href="#索引哪些情况下会失效呢" class="hash-link" aria-label="Direct link to 🌟索引哪些情况下会失效呢？" title="Direct link to 🌟索引哪些情况下会失效呢？">​</a></h3>
<p>简版：比如索引列使用了函数、使用了通配符开头的模糊查询、联合索引不满足最左前缀原则，或者使用 or 的时候部分字段无索引等。</p>
<p>第一，对索引列使用函数或表达式会导致索引失效。
第二，LIKE 模糊查询以通配符开头会导致索引失效。
第三，联合索引违反了最左前缀原则，索引会失效。
联合索引，但 WHERE 不满足最左前缀原则，索引无法起效。例如：SELECT * FROM table WHERE column2 = 2，联合索引为 (column1, column2)。
第四，使用 OR 连接非索引列条件，会导致索引失效
第五，使用 != 或 <code>&lt;&gt;</code> 不等值查询会导致索引失效。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="什么情况下模糊查询不走索引">什么情况下模糊查询不走索引？<a href="#什么情况下模糊查询不走索引" class="hash-link" aria-label="Direct link to 什么情况下模糊查询不走索引？" title="Direct link to 什么情况下模糊查询不走索引？">​</a></h4>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="索引不适合哪些场景呢">索引不适合哪些场景呢？<a href="#索引不适合哪些场景呢" class="hash-link" aria-label="Direct link to 索引不适合哪些场景呢？" title="Direct link to 索引不适合哪些场景呢？">​</a></h3>
<p>第一，区分度低的列，可以和其他高区分度的列组成联合索引。</p>
<p>第二，频繁更新的列，索引会增加更新的成本。</p>
<p>第三，TEXT、BLOB 等大对象类型的字段，可以使用前缀索引、全文索引替代。</p>
<p>第四，当表的数据量很小的时候，不超过 1000 行，全表扫描可能比使用索引更快。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="性别字段要建立索引吗">性别字段要建立索引吗？<a href="#性别字段要建立索引吗" class="hash-link" aria-label="Direct link to 性别字段要建立索引吗？" title="Direct link to 性别字段要建立索引吗？">​</a></h3>
<p>性别字段不适合建立单独索引。因为性别字段的区分度很低。<br>
<!-- -->如果性别字段确实经常用于查询条件，数据规模也比较大，可以将性别字段作为联合索引的一部分，与区分度高的字段一起，效果会好很多。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="什么是区分度">什么是区分度？<a href="#什么是区分度" class="hash-link" aria-label="Direct link to 什么是区分度？" title="Direct link to 什么是区分度？">​</a></h4>
<p>区分度是衡量一个字段在 MySQL 表中唯一值的比例。<br>
<!-- -->区分度 = 字段的唯一值数量 / 字段的总记录数；越接近 1，就越适合作为索引。因为索引可以更有效地缩小查询范围。
例如，一个表中有 1000 条记录，其中性别字段只有两个值（男、女），那么性别字段的区分度只有 0.002，就不适合建立索引。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么样的字段适合加索引">什么样的字段适合加索引？<a href="#什么样的字段适合加索引" class="hash-link" aria-label="Direct link to 什么样的字段适合加索引？" title="Direct link to 什么样的字段适合加索引？">​</a></h3>
<p>一般来说，主键、唯一键、以及经常作为查询条件的字段最适合加索引。除此之外，字段的区分度要高，这样索引才能起到过滤作用；如果字段经常用于表连接、排序或分组，也建议加索引。同时如果多个字段经常一起出现在查询条件中，也可以建立联合索引来提升性能。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="索引是不是建的越多越好">索引是不是建的越多越好？<a href="#索引是不是建的越多越好" class="hash-link" aria-label="Direct link to 索引是不是建的越多越好？" title="Direct link to 索引是不是建的越多越好？">​</a></h3>
<p>索引不是越多越好。虽然索引可以加快查询，但也会带来写入变慢、占用更多存储空间、甚至让优化器选错索引的风险。<br>
<!-- -->单表索引数量建议不超过 5 个，MySQL 官方建议单表索引总字段数 ≤ 表字段数的 30%。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说索引优化的思路">说说索引优化的思路？<a href="#说说索引优化的思路" class="hash-link" aria-label="Direct link to 说说索引优化的思路？" title="Direct link to 说说索引优化的思路？">​</a></h3>
<p>先通过慢查询日志找出性能瓶颈，然后用 EXPLAIN 分析执行计划，判断是否走了索引、是否回表、是否排序。接着根据字段特性设计合适的索引，如选择区分度高的字段，使用联合索引和覆盖索引，避免索引失效的写法，最后通过实测来验证优化效果。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么-innodb-要使用-b树作为索引">🌟为什么 InnoDB 要使用 B+树作为索引？<a href="#为什么-innodb-要使用-b树作为索引" class="hash-link" aria-label="Direct link to 🌟为什么 InnoDB 要使用 B+树作为索引？" title="Direct link to 🌟为什么 InnoDB 要使用 B+树作为索引？">​</a></h3>
<p>因为 B+ 树是一种高度平衡的多路查找树，能有效降低磁盘的 IO 次数，并且支持有序遍历和范围查询。<br>
<img decoding="async" loading="lazy" alt="B+Tree" src="/doc/assets/images/B+Tree-380ec8e66106f759079206ebd30bfe0b.png" width="1080" height="737" class="img_ev3q">
查询性能非常高，其结构也适合 MySQL 按照页为单位在磁盘上存储。<br>
<!-- -->像其他选项，比如说哈希表不支持范围查询，二叉树层级太深，B 树又不方便范围扫描，所以最终选择了 B+ 树。<br>
<!-- -->再换一种回答：
相比哈希表：B+ 树支持范围查询和排序<br>
<!-- -->相比二叉树和红黑树：B+ 树更“矮胖”，层级更少，磁盘 IO 次数更少<br>
<!-- -->相比 B 树：B+ 树的非叶子节点只存储键值，叶子节点存储数据并通过链表连接，支持范围查询</p>
<p>另外一种回答版本：
B+树是一种自平衡的多路查找树，和红黑树、二叉平衡树不同，B+树的每个节点可以有 m 个子节点，而红黑树和二叉平衡树都只有 2 个。
另外，和 B 树不同，B+树的非叶子节点只存储键值，不存储数据，而叶子节点存储了所有的数据，并且构成了一个有序链表。<br>
<img decoding="async" loading="lazy" alt="B+Tree1" src="/doc/assets/images/B+Tree1-ec65c55d6396919a3d4aca11a754bd19.png" width="1200" height="530" class="img_ev3q">
这样做的好处是，非叶子节点上由于没有存储数据，就可以存储更多的键值对，再加上叶子节点构成了一个有序链表，范围查询时就可以直接通过叶子节点间的指针顺序访问整个查询范围内的所有记录，而无需对树进行多次遍历。查询的效率比 B 树更高。
---- 这部分是帮助大家理解 start，面试中可不背 ----
先说说 B 树。</p>
<p>B 树是一种自平衡的多路查找树，和红黑树、二叉平衡树不同，B 树的每个节点可以有 m 个子节点，而红黑树和二叉平衡树都只有 2 个。<br>
<!-- -->换句话说，红黑树、二叉平衡树是细高个，而 B 树是矮胖子。<br>
<img decoding="async" loading="lazy" alt="B+Tree2" src="/doc/assets/images/B+Tree2-c16077beddc0aba39e433e633f0bb9f1.png" width="782" height="314" class="img_ev3q">
再来说说内存和磁盘的 IO 读写。<br>
<img decoding="async" loading="lazy" alt="cpu-内存-磁盘" src="/doc/assets/images/cpu-内存-磁盘-97f8ea8f5c2d77fae1a041de5c3a6a5a.png" width="778" height="256" class="img_ev3q">
为了提高读写效率，从磁盘往内存中读数据的时候，一次会读取至少一页的数据，如果不满一页，会再多读点。
比如说查询只需要读取 2KB 的数据，但 MySQL 实际上会读取 4KB 的数据，以装满整页。页是 MySQL 进行内存和磁盘交互的最小逻辑单元。
再比如说需要读取 5KB 的数据，实际上 MySQL 会读取 8KB 的数据，刚好两页。
因为读的次数越多，效率就越低。就好比我们在工地上搬砖，一次搬 10 块砖肯定比一次搬 1 块砖的效率要高，反正我每次都搬 10 块（😁）。
对于红黑树、二叉平衡树这种细高个来说，每次搬的砖少，因为力气不够嘛，那来回跑的次数就越多。<br>
<!-- -->树越高，意味着查找数据时就需要更多的磁盘 IO，因为每一层都可能需要从磁盘加载新的节点。<br>
<img decoding="async" loading="lazy" alt="img_8.png" src="/doc/assets/images/img_8-0023c15c77418d944c285f4608deb3be.png" width="1019" height="558" class="img_ev3q">
B 树的节点通常与页的大小对齐，这样每次从磁盘加载一个节点时，正好就是一页的大小。<br>
<img decoding="async" loading="lazy" alt="img_9.png" src="/doc/assets/images/img_9-141ece20b45d713b32e3a8d6f4187c5d.png" width="1080" height="480" class="img_ev3q">
B 树的一个节点通常包括三个部分：
键值：即表中的主键<br>
<!-- -->指针：存储子节点的信息<br>
<!-- -->数据：除主键外的行数据<br>
<!-- -->正所谓“祸兮福所倚，福兮祸所伏”，因为 B 树的每个节点上都存储了数据，就导致每个节点能存储的键值和指针变少了，因为每一个节点的大小是固定的，对吧？
于是 B+树就来了，B+树的非叶子节点只存储键值，不存储数据，而叶子节点会存储所有的行数据，并且构成一个有序链表。<br>
<img decoding="async" loading="lazy" alt="img_10.png" src="/doc/assets/images/img_10-ac577a45d044b3b5527fe3b0ab4d45c7.png" width="1366" height="598" class="img_ev3q">
这样做的好处是，非叶子节点由于没有存储数据，就可以存储更多的键值对，树就变得更加矮胖了，于是就更有劲了，每次搬的砖也就更多了（😂）。
由此一来，查找数据进行的磁盘 IO 就更少了，查询的效率也就更高了。
再加上叶子节点构成了一个有序链表，范围查询时就可以直接通过叶子节点间的指针顺序访问整个查询范围内的所有记录，而无需对树进行多次遍历。B 树就做不到这一点。<br>
<!-- -->ps: 相比 B 树，B+ 的非叶子节点可容纳的键值更多，一个 16KB 的节点可存储约 1200 个键值，大幅降低树的高度。<br>
<!-- -->---- 这部分是帮助大家理解 end，面试中可不背 ----</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="b树的叶子节点是单向链表还是双向链表如果从大值向小值检索如何操作">B+树的叶子节点是单向链表还是双向链表？如果从大值向小值检索，如何操作？<a href="#b树的叶子节点是单向链表还是双向链表如果从大值向小值检索如何操作" class="hash-link" aria-label="Direct link to B+树的叶子节点是单向链表还是双向链表？如果从大值向小值检索，如何操作？" title="Direct link to B+树的叶子节点是单向链表还是双向链表？如果从大值向小值检索，如何操作？">​</a></h3>
<p>B+树的叶子节点是通过双向链表连接的，这样可以方便范围查询和反向遍历。</p>
<p>当执行范围查询时，可以从范围的开始点或结束点开始，向前或向后遍历。
在需要对数据进行逆序处理时，双向链表非常有用。
如果需要在 B+树中从大值向小值进行检索，可以先定位到最右侧节点，找到包含最大值的叶子节点。从根节点开始向右遍历树的方式实现。
<img decoding="async" loading="lazy" alt="img_11.png" src="/doc/assets/images/img_11-92a16116e4f0277f575b5638c22e1eeb.png" width="1623" height="652" class="img_ev3q">
定位到最右侧的叶子节点后，再利用叶节点间的双向链表向左遍历就好了。</p>
<p>为什么 MongoDB 的索引用 B树，而 MySQL 用 B+ 树？
MongoDB 通常以 JSON 格式存储文档，查询以单键查询<code>（如 find({_id: 123})）</code>为主。B 树的“节点既存键又存数据”的特性允许查询在非叶子节点提前终止，从而减少 I/O 次数。
<img decoding="async" loading="lazy" alt="img_12.png" src="/doc/assets/images/img_12-e712df55bffa32d46c27569995ad272b.png" width="1600" height="550" class="img_ev3q">
MySQL 的查询通常涉及范围（WHERE id &gt; 100）、排序（ORDER BY）、连接（JOIN）等操作。B+ 树的叶子节点是链表结构，天然支持顺序遍历，无需回溯至根节点或中序遍历，效率远高于 B 树。
<img decoding="async" loading="lazy" alt="img_13.png" src="/doc/assets/images/img_13-ba7290d9fd02fa172d288702907e53ca.png" width="1586" height="648" class="img_ev3q"></p>
<p>推荐阅读：为什么 MongoDB 索引用 B树，而 MySQL 用 B+ 树？
<a href="https://www.cnblogs.com/rjzheng/p/12316685.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/rjzheng/p/12316685.html</a></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="一棵b树能存储多少条数据呢">🌟一棵B+树能存储多少条数据呢？<a href="#一棵b树能存储多少条数据呢" class="hash-link" aria-label="Direct link to 🌟一棵B+树能存储多少条数据呢？" title="Direct link to 🌟一棵B+树能存储多少条数据呢？">​</a></h3>
<p>一棵 B+ 树能存多少数据，取决于它的分支因子和高度。在 InnoDB 中，页的默认大小为 16KB，当主键为 bigint 时，3 层 B+ 树通常可以存储约 2000 万条数据。
<img decoding="async" loading="lazy" alt="1756473130992" src="/doc/assets/images/1756473130992-a94b1318ff6ac16e19cb7fbae8e6488a.png" width="1080" height="451" class="img_ev3q"></p>
<p><a href="https://juejin.cn/post/6904293886626103309" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6904293886626103309</a></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="现在有一张表-2kw-数据我这个-b树的高度有几层">现在有一张表 2kw 数据，我这个 b+树的高度有几层？<a href="#现在有一张表-2kw-数据我这个-b树的高度有几层" class="hash-link" aria-label="Direct link to 现在有一张表 2kw 数据，我这个 b+树的高度有几层？" title="Direct link to 现在有一张表 2kw 数据，我这个 b+树的高度有几层？">​</a></h3>
<p>对于 2KW 条数据来说，B+树的高度为 3 层就够了。
<img decoding="async" loading="lazy" alt="1756473246248" src="/doc/assets/images/1756473246248-2a8e26cfc8cf9673334c89eee2405cd1.png" width="1622" height="562" class="img_ev3q">
<a href="https://www.cnblogs.com/yifanSJ/p/17662132.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/yifanSJ/p/17662132.html</a></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="每个叶子节点能存放多少条数据">每个叶子节点能存放多少条数据？<a href="#每个叶子节点能存放多少条数据" class="hash-link" aria-label="Direct link to 每个叶子节点能存放多少条数据？" title="Direct link to 每个叶子节点能存放多少条数据？">​</a></h3>
<p>如果单行数据大小为 1KB，那么每页可存储约 16 行（16KB/1KB）数据。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="索引为什么用-b树不用普通二叉树">索引为什么用 B+树不用普通二叉树？<a href="#索引为什么用-b树不用普通二叉树" class="hash-link" aria-label="Direct link to 索引为什么用 B+树不用普通二叉树？" title="Direct link to 索引为什么用 B+树不用普通二叉树？">​</a></h3>
<p>普通二叉树的每个节点最多有两个子节点。当数据按顺序递增插入时，二叉树会退化成链表，导致树的高度等于数据量。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么不用平衡二叉树呢">为什么不用平衡二叉树呢？<a href="#为什么不用平衡二叉树呢" class="hash-link" aria-label="Direct link to 为什么不用平衡二叉树呢？" title="Direct link to 为什么不用平衡二叉树呢？">​</a></h3>
<p>平衡二叉树虽然解决了普通二叉树的退化问题，但每个节点最多只有两个子节点的问题依然存在。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么用-b-树而不用-b-树呢">🌟为什么用 B+ 树而不用 B 树呢？<a href="#为什么用-b-树而不用-b-树呢" class="hash-link" aria-label="Direct link to 🌟为什么用 B+ 树而不用 B 树呢？" title="Direct link to 🌟为什么用 B+ 树而不用 B 树呢？">​</a></h3>
<p>B+ 树相比 B 树有 3 个显著优势：</p>
<p>第一，B 树的每个节点既存储键值，又存储数据和指针，导致单节点存储的键值数量较少。
<img decoding="async" loading="lazy" alt="1756473488143" src="/doc/assets/images/1756473488143-57bd2bba40a4db19268de88b17cc93da.png" width="1176" height="518" class="img_ev3q">
一个 16KB 的 InnoDB 页，如果数据较大，B 树的非叶子节点只能容纳几十个键值，而 B+ 树的非叶子节点可以容纳上千个键值。</p>
<p>第二，B 树的范围查询需要通过中序遍历逐层回溯；而 B+ 树的叶子节点通过双向链表顺序连接，范围查询只需定位起始点后顺序遍历链表即可，没有回溯开销。
<img decoding="async" loading="lazy" alt="1756473511330" src="/doc/assets/images/1756473511330-74f41f4e77412c385bd8d0002b0e3eb2.png" width="1002" height="674" class="img_ev3q">
第三，B 树的数据可能存储在任意节点，假如目标数据恰好位于根节点或上层节点，查询仅需 1-2 次 I/O；但如果数据位于底层节点，则需多次 I/O，导致查询时间波动较大。</p>
<p>而 B+ 树的所有数据都存储在叶子节点，查询路径的长度是固定的，时间稳定为 O(logN)，对 MySQL 在高并发场景下的稳定性至关重要。
有链接详解 waitx</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="b树的时间复杂度是多少">B+树的时间复杂度是多少？<a href="#b树的时间复杂度是多少" class="hash-link" aria-label="Direct link to B+树的时间复杂度是多少？" title="Direct link to B+树的时间复杂度是多少？">​</a></h3>
<p>O(logN)。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么用-b树不用跳表呢">为什么用 B+树不用跳表呢？<a href="#为什么用-b树不用跳表呢" class="hash-link" aria-label="Direct link to 为什么用 B+树不用跳表呢？" title="Direct link to 为什么用 B+树不用跳表呢？">​</a></h3>
<p>跳表本质上还是链表结构，只不过把某些节点抽到上层做了索引。
<img decoding="async" loading="lazy" alt="1756473582311" src="data:image/png;base64,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" width="1031" height="287" class="img_ev3q">
一条数据一个节点，如果需要存放 2000 万条数据，且每次查询都要能达到二分查找的效果，那么跳表的高度大约为 24 层（2 的 24 次方）。</p>
<p>在最坏的情况下，这 24 层数据分散在不同的数据页，查找一次数据就需要 24 次磁盘 I/O。</p>
<p>而 2000 万条数据在 B+树中只需要 3 层就可以了。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="b树的范围查找怎么做的">B+树的范围查找怎么做的？<a href="#b树的范围查找怎么做的" class="hash-link" aria-label="Direct link to B+树的范围查找怎么做的？" title="Direct link to B+树的范围查找怎么做的？">​</a></h3>
<p>一句话回答：</p>
<p>先通过索引路径定位到第一个满足条件的叶子节点，然后顺着叶子节点之间的链表向右/向左扫描，直到超过范围。</p>
<p>详细版：</p>
<p>B+ 树索引的范围查找主要依赖叶子节点之间的双向链表来完成。</p>
<p>第一步，从 B+ 树的根节点开始，通过索引键值逐层向下，找到第一个满足条件的叶子节点。</p>
<p>第二步，利用叶子节点之间的双向链表，从起始节点开始，依次向后遍历每个节点。当索引值超过查询范围，或者遍历到链表末尾时，终止查询。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="了解快排吗">了解快排吗？<a href="#了解快排吗" class="hash-link" aria-label="Direct link to 了解快排吗？" title="Direct link to 了解快排吗？">​</a></h3>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="b树索引和-hash-索引有什么区别">B+树索引和 Hash 索引有什么区别？<a href="#b树索引和-hash-索引有什么区别" class="hash-link" aria-label="Direct link to B+树索引和 Hash 索引有什么区别？" title="Direct link to B+树索引和 Hash 索引有什么区别？">​</a></h3>
<p>B+ 树索引支持范围查询、有序扫描，是 InnoDB 的默认索引结构。
Hash 索引只支持等值查找，速度快但功能弱，常见于 Memory 引擎。</p>
<p>稍微详细一点的回答：</p>
<p>B+ 树索引是一种平衡多路搜索树，所有数据存储在叶子节点上，非叶子节点仅存储索引键。叶子节点通过指针连接形成有序链表，天然支持排序。</p>
<p>并且支持范围查询、模糊查询，是 InnoDB 默认的索引结构。</p>
<p>Hash 索引基于哈希函数将键值映射到固定长度的哈希值，通过哈希值定位数据存储的位置。</p>
<p>完全无序，只支持等值查询，常见于 Memory 引擎。</p>
<p>---- 这部分是帮助大家理解 start，面试中可不背 ----
InnoDB 并不提供直接创建哈希索引的选项，因为 B+ 树索引能够很好地支持范围查询和等值查询，满足了大多数数据库操作的需要。</p>
<p>不过，InnoDB 内部使用了一种名为“自适应哈希索引”（Adaptive Hash Index, AHI）的技术，当某些索引值频繁访问时，InnoDB 会在 B+ 树基础上自动创建哈希索引，兼具两者的优点。
---- 这部分是帮助大家理解 end，面试中可不背 ----</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="聚族索引和非聚族索引有什么区别">🌟聚族索引和非聚族索引有什么区别？<a href="#聚族索引和非聚族索引有什么区别" class="hash-link" aria-label="Direct link to 🌟聚族索引和非聚族索引有什么区别？" title="Direct link to 🌟聚族索引和非聚族索引有什么区别？">​</a></h3>
<p>聚簇索引的叶子节点存储了完整的数据行，数据和索引是在一起的。InnoDB 的主键索引就是聚簇索引，叶子节点不仅存储了主键值，还存储了其他列的值，因此按照主键进行查询的速度会非常快。</p>
<p>每个表只能有一个聚簇索引，通常由主键定义。如果没有显式指定主键，InnoDB 会隐式创建一个隐藏的主键索引 row_id。</p>
<p>非聚簇索引的叶子节点只包含了主键值，需要通过回表按照主键去聚簇索引查找其他列的值，唯一索引、普通索引等非主键索引都是非聚簇索引。
每个表都可以创建多个非聚簇索引，如果不想回表的话，可以通过覆盖索引把要查询的字段也放到索引中。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="回表了解吗">🌟回表了解吗？<a href="#回表了解吗" class="hash-link" aria-label="Direct link to 🌟回表了解吗？" title="Direct link to 🌟回表了解吗？">​</a></h3>
<p>当使用非聚簇索引进行查询时，MySQL 需要先通过非聚簇索引找到主键值，然后再根据主键值回到聚簇索引中查找完整数据行，这个过程称为回表。
<img decoding="async" loading="lazy" alt="1756474103915" src="/doc/assets/images/1756474103915-2e95b030cc36340a3947b535b7ef6ce9.png" width="1789" height="654" class="img_ev3q">
可通过覆盖索引或者联合索引来避免回表。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么情况下会触发回表">什么情况下会触发回表？<a href="#什么情况下会触发回表" class="hash-link" aria-label="Direct link to 什么情况下会触发回表？" title="Direct link to 什么情况下会触发回表？">​</a></h3>
<p>第一，当查询字段不在非聚簇索引中时，必须回表到主键索引获取数据。</p>
<p>第二，查询字段包含非索引列（如 SELECT *），必然触发回表。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="回表记录越多好吗">回表记录越多好吗？<a href="#回表记录越多好吗" class="hash-link" aria-label="Direct link to 回表记录越多好吗？" title="Direct link to 回表记录越多好吗？">​</a></h3>
<p>回表记录越多，通常代表性能越差，因为每条记录都需要通过主键再查询一次完整数据。这个过程涉及内存访问或磁盘 IO，尤其当缓存命中率不高时，回表会严重影响查询效率。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="了解-mrr-吗">了解 MRR 吗？<a href="#了解-mrr-吗" class="hash-link" aria-label="Direct link to 了解 MRR 吗？" title="Direct link to 了解 MRR 吗？">​</a></h3>
<p>MRR 是 InnoDB 为了解决回表带来的大量随机 IO 问题而引入的一种优化策略。
<img decoding="async" loading="lazy" alt="1756475621841" src="/doc/assets/images/1756475621841-04a4cbfe0498857554a15d2389aed3af.png" width="1080" height="722" class="img_ev3q">
它会先把非聚簇索引查到的主键值列表进行排序，再按顺序去主键索引中批量回表，将随机 I/O 转换为顺序 I/O，以减少磁盘寻道时间。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="联合索引了解吗补充">🌟联合索引了解吗？（补充）<a href="#联合索引了解吗补充" class="hash-link" aria-label="Direct link to 🌟联合索引了解吗？（补充）" title="Direct link to 🌟联合索引了解吗？（补充）">​</a></h3>
<p>联合索引就是把多个字段放在一个索引里，但必须遵守“最左前缀”原则，只有从第一个字段开始连续使用，索引才会生效。
联合索引会按字段顺序构建B+树。例如（age, name）索引会先按照 age 排序，age 相同则按照 name 排序，若两者都相同则按主键排序，确保叶子节点无重复索引项。</p>
<p>创建(A,B,C)联合索引相当于同时创建了(A)、(A,B)和(A,B,C)三个索引。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="联合索引底层的存储结构是怎样的">联合索引底层的存储结构是怎样的？<a href="#联合索引底层的存储结构是怎样的" class="hash-link" aria-label="Direct link to 联合索引底层的存储结构是怎样的？" title="Direct link to 联合索引底层的存储结构是怎样的？">​</a></h3>
<p>联合索引在底层采用 B+ 树结构进行存储，这一点与单列索引相同。</p>
<p><img decoding="async" loading="lazy" alt="1756475710183" src="/doc/assets/images/1756475710183-a9b25dd56ae1d9d81b427f42945e9ada.png" width="1774" height="1108" class="img_ev3q">
与单列索引不同的是，联合索引的每个节点会存储所有索引列的值，而不仅仅是第一列的值。例如，对于联合索引(a,b,c)，每个节点都包含 a、b、c 三列的值。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="联合索引的叶子节点存的什么内容">联合索引的叶子节点存的什么内容?<a href="#联合索引的叶子节点存的什么内容" class="hash-link" aria-label="Direct link to 联合索引的叶子节点存的什么内容?" title="Direct link to 联合索引的叶子节点存的什么内容?">​</a></h3>
<p>联合索引属于非聚簇索引，叶子节点存储的是联合索引各列的值和对应行的主键值，而不是完整的数据行。查询非索引字段时，需要通过主键值回表到聚簇索引获取完整数据。
<img decoding="async" loading="lazy" alt="1756475738987" src="/doc/assets/images/1756475738987-e7f2c48a1427def56ca83ad6899e9e19.png" width="1188" height="762" class="img_ev3q">
例如索引(a, b)的叶子节点会完整存储(a, b)的值，并按字段顺序排序（如 a 优先，a 相同则按 b 排序）。如果主键是 id，叶子节点会存储 (a, b, id) 的组合。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="覆盖索引了解吗">🌟覆盖索引了解吗？<a href="#覆盖索引了解吗" class="hash-link" aria-label="Direct link to 🌟覆盖索引了解吗？" title="Direct link to 🌟覆盖索引了解吗？">​</a></h3>
<p>覆盖索引指的是：查询所需的字段全部都在索引中，不需要回表，从索引页就能直接返回结果。</p>
<p>可以将高频查询的字段（如 WHERE 条件和 SELECT 列）组合为联合索引，实现覆盖索引。
普通索引只用于加速查询条件的匹配，而覆盖索引还能直接提供查询结果。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是最左前缀原则">🌟什么是最左前缀原则？<a href="#什么是最左前缀原则" class="hash-link" aria-label="Direct link to 🌟什么是最左前缀原则？" title="Direct link to 🌟什么是最左前缀原则？">​</a></h3>
<p>最左前缀原则指的是：MySQL 使用联合索引时，必须从最左边的字段开始匹配，才能命中索引。</p>
<p>如果排序或分组的列是最左前缀的一部分，索引还可以加速操作。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="范围查询后的列还能用索引吗">范围查询后的列还能用索引吗？<a href="#范围查询后的列还能用索引吗" class="hash-link" aria-label="Direct link to 范围查询后的列还能用索引吗？" title="Direct link to 范围查询后的列还能用索引吗？">​</a></h3>
<p>范围查询只能应用于最左前缀的最后一列。范围查询之后的列无法使用索引。
ps: 如果是指定的in也算精确匹配的</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么不从最左开始查就无法匹配呢">为什么不从最左开始查，就无法匹配呢？<a href="#为什么不从最左开始查就无法匹配呢" class="hash-link" aria-label="Direct link to 为什么不从最左开始查，就无法匹配呢？" title="Direct link to 为什么不从最左开始查，就无法匹配呢？">​</a></h3>
<p>一句话回答：</p>
<p>因为联合索引在 B+ 树中是按照最左字段优先排序构建的，如果跳过最左字段，MySQL 无法判断查找范围从哪里开始，自然也就无法使用索引。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是索引下推">🌟什么是索引下推？<a href="#什么是索引下推" class="hash-link" aria-label="Direct link to 🌟什么是索引下推？" title="Direct link to 🌟什么是索引下推？">​</a></h3>
<p>索引下推是指：MySQL 把 WHERE 条件尽可能“下推”到索引扫描阶段，在存储引擎层提前过滤掉不符合条件的记录。
<img decoding="async" loading="lazy" alt="1756475943770" src="/doc/assets/images/1756475943770-d94aa4ae17b00a67c1a848d125ea41e6.png" width="751" height="763" class="img_ev3q">
当查询条件包含索引列但未完全匹配时，ICP 会在存储引擎层过滤非索引列条件，以减少回表次数。</p>
<p>传统的查询流程是，储引擎通过联合索引定位到符合最左前缀条件的主键 ID；回表读取完整数据行并返回给 Server 层；Server 层对所有返回的行进行 WHERE 条件过滤。</p>
<p>有了 ICP 后，存储引擎在索引层直接过滤可下推的条件，仅对符合索引条件的记录回表读取数据，再返回给 Server 层进行剩余条件过滤。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何查看是否用到了索引补充">如何查看是否用到了索引？（补充）<a href="#如何查看是否用到了索引补充" class="hash-link" aria-label="Direct link to 如何查看是否用到了索引？（补充）" title="Direct link to 如何查看是否用到了索引？（补充）">​</a></h3>
<p>可以通过 EXPLAIN 关键字来查看是否使用了索引。
如果使用了索引，结果中的 key 值会显示索引的名称。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="mysql-中有哪几种锁">🌟MySQL 中有哪几种锁？<a href="#mysql-中有哪几种锁" class="hash-link" aria-label="Direct link to 🌟MySQL 中有哪几种锁？" title="Direct link to 🌟MySQL 中有哪几种锁？">​</a></h3>
<p>MySQL 中有多种类型的锁，可以从不同维度来分类，按锁粒度划分的话，有表锁、行锁。
按照加锁机制划分的话，有乐观锁和悲观锁。按照兼容性划分的话，有共享锁和排他锁。
<img decoding="async" loading="lazy" alt="1756477634309" src="/doc/assets/images/1756477634309-85e4d6c04c4b67ace49fe1591db69ffc.png" width="1080" height="450" class="img_ev3q">
表锁：锁定整个表，资源开销小，加锁快，但并发度低，不会出现死锁；适合查询为主、少量更新的场景（如 MyISAM 引擎）。</p>
<p>IServise：表级锁
IServise：表级锁
再细分的话，有表共享读锁（S锁）：允许多个事务同时读，但阻塞写操作；表独占写锁（X锁）：独占表，阻塞其他事务的读写。</p>
<p>Draven：共享锁和独占锁
Draven：共享锁和独占锁
行锁：锁定单行或多行，开销大、加锁慢，可能出现死锁，但并发度高（InnoDB 默认支持）。</p>
<p>再细分的话，有记录锁（Record Lock）：锁定索引中的具体记录；间隙锁（Gap Lock）：锁定索引记录之间的间隙，防止幻读；临键锁（Next-Key Lock）：结合记录锁和间隙锁，锁定一个左开右闭的区间（如 (5, 10]）。</p>
<p>共享锁（S锁/读锁），允许多个事务同时读取数据，但阻塞写操作。语法：SELECT ... LOCK IN SHARE MODE</p>
<p>排他锁（X锁/写锁），独占数据，阻塞其他事务的读写。语法：SELECT ... FOR UPDATE。</p>
<p>乐观锁假设冲突少，通过版本号或 CAS 机制检测冲突（如 UPDATE SET version=version+1 WHERE version=old_version）。</p>
<p>悲观锁假设并发冲突频繁，先加锁再操作SELECT FOR UPDATE。</p>
<p>---- 这部分是帮助大家理解 end，面试中可不背</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="全局锁了解吗补充">全局锁了解吗？（补充）<a href="#全局锁了解吗补充" class="hash-link" aria-label="Direct link to 全局锁了解吗？（补充）" title="Direct link to 全局锁了解吗？（补充）">​</a></h3>
<p>全局锁就是对整个数据库实例进行加锁，当执行全局锁定操作时，整个数据库将会处于只读状态，所有写操作都会被阻塞，直到全局锁被释放。</p>
<p>在进行全库备份，或者数据迁移时，可以使用全局锁来保证数据的一致性。</p>
<p>在 MySQL 中，可以使用 FLUSH TABLES WITH READ LOCK 命令来获取全局锁。</p>
<p>执行该命令后，所有表将被锁定为只读状态。记得在完成备份或迁移后，使用 UNLOCK TABLES 命令释放全局锁。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="表锁了解吗">表锁了解吗？<a href="#表锁了解吗" class="hash-link" aria-label="Direct link to 表锁了解吗？" title="Direct link to 表锁了解吗？">​</a></h3>
<p>表锁常见于 MyISAM 引擎，InnoDB 也可以手动通过 LOCK TABLES 加锁。
适合读多写少、全表扫描或者表结构变更的场景用。</p>
<p>表锁又可以细分为共享锁和排他锁。共享锁允许多个事务同时读表，但不允许写操作。</p>
<p>MyISAM 在执行 SELECT 时会自动加读锁，执行 INSERT/UPDATE/DELETE 时会加写锁。</p>
<p>对于 InnoDB 引擎，无索引的 UPDATE/DELETE 可能会导致锁升级为表锁。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说-mysql-的行锁">🌟说说 MySQL 的行锁？<a href="#说说-mysql-的行锁" class="hash-link" aria-label="Direct link to 🌟说说 MySQL 的行锁？" title="Direct link to 🌟说说 MySQL 的行锁？">​</a></h3>
<p>行锁是 InnoDB 存储引擎中最细粒度的锁，它锁定表中的一行记录，允许其他事务访问表中的其他行。</p>
<p>底层是通过给索引加锁实现的，这就意味着只有通过索引条件检索数据时，InnoDB 才能使用行级锁，否则会退化为表锁。
<img decoding="async" loading="lazy" alt="1756477796316" src="/doc/assets/images/1756477796316-5aaa3f2c920f80932d3b2b8aaaa9eb8e.png" width="799" height="655" class="img_ev3q"></p>
<p>行锁又可以细分为记录锁、间隙锁和临键锁三种形式。通过 SELECT ... FOR UPDATE 可以加排他锁。</p>
<p>通过 SELECT ...LOCK IN SHARE MODE 可以加共享锁。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="select-for-update-有什么需要注意的">select for update 有什么需要注意的？<a href="#select-for-update-有什么需要注意的" class="hash-link" aria-label="Direct link to select for update 有什么需要注意的？" title="Direct link to select for update 有什么需要注意的？">​</a></h3>
<p>第一，必须在事务中使用，否则锁会立即释放。</p>
<p>第二，使用时必须注意是否命中索引，否则可能锁全表。 ？？？</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说记录锁吧">说说记录锁吧？<a href="#说说记录锁吧" class="hash-link" aria-label="Direct link to 说说记录锁吧？" title="Direct link to 说说记录锁吧？">​</a></h3>
<p>记录锁是行锁最基本的表现形式，当我们使用唯一索引或者主键索引进行等值查询时，MySQL 会为该记录自动添加排他锁，禁止其他事务读取或者修改锁定记录。
<img decoding="async" loading="lazy" alt="1756478162741" src="/doc/assets/images/1756478162741-bb7652e8cca0225d8b9db6c6c91365c1.png" width="1316" height="1138" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="间隙锁了解吗补充">间隙锁了解吗？（补充）<a href="#间隙锁了解吗补充" class="hash-link" aria-label="Direct link to 间隙锁了解吗？（补充）" title="Direct link to 间隙锁了解吗？（补充）">​</a></h3>
<p>间隙锁用于在范围查询时锁定记录之间的“间隙”，防止其他事务在该范围内插入新记录。仅在可重复读及以上的隔离级别下生效，主要用于防止幻读。
<img decoding="async" loading="lazy" alt="1756481552423" src="/doc/assets/images/1756481552423-6ae87f5f659528e501efac0ae383be31.png" width="1658" height="1174" class="img_ev3q"></p>
<p><a href="https://www.51cto.com/article/779551.html" target="_blank" rel="noopener noreferrer">六个案例搞懂间隙锁</a>
<a href="https://blog.csdn.net/javaanddonet/article/details/111187345" target="_blank" rel="noopener noreferrer">MySQL中间隙锁的加锁机制</a></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="执行什么命令会加上间隙锁">执行什么命令会加上间隙锁？<a href="#执行什么命令会加上间隙锁" class="hash-link" aria-label="Direct link to 执行什么命令会加上间隙锁？" title="Direct link to 执行什么命令会加上间隙锁？">​</a></h3>
<p>在可重复读隔离级别下，执行 FOR UPDATE / LOCK IN SHARE MODE 等加锁语句，且查询条件是范围查询时，就会自动加上间隙锁。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="临键锁了解吗">临键锁了解吗？<a href="#临键锁了解吗" class="hash-link" aria-label="Direct link to 临键锁了解吗？" title="Direct link to 临键锁了解吗？">​</a></h3>
<p>临键锁是记录锁和间隙锁的结合体，锁住的是索引记录和索引记录之间的间隙。</p>
<p><img decoding="async" loading="lazy" alt="1756481676105" src="/doc/assets/images/1756481676105-a03cbce161464ad7854eb1197821f932.png" width="1392" height="734" class="img_ev3q">
和间隙锁不同，临键锁的间隙是一个左开右闭区间。例如 (1,3] 表示锁定大于 1 且小于等于 3 的所有记录。</p>
<p>当 InnoDB 执行一个范围查询时，会使用临键锁来锁定满足条件的行数据以及该范围内的间隙。
<img decoding="async" loading="lazy" alt="1756481688211" src="/doc/assets/images/1756481688211-21fee6d46dcbbebff57f71043c34cb97.png" width="1318" height="786" class="img_ev3q">
比如说下面这条语句会锁定 id 在 5 到 10 之间的所有记录，以及这些记录之间的间隙。</p>
<div class="language-mysql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-mysql codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">SELECT * FROM table WHERE id BETWEEN 5 AND 10 FOR UPDATE;</span><br></span></code></pre></div></div>
<p>MySQL 默认的行锁类型就是临键锁。当使用唯一索引的等值查询匹配到一条记录时，临键锁会退化成记录锁；如果没有匹配到任何记录，会退化成间隙锁。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="意向锁是什么知道吗">意向锁是什么知道吗？<a href="#意向锁是什么知道吗" class="hash-link" aria-label="Direct link to 意向锁是什么知道吗？" title="Direct link to 意向锁是什么知道吗？">​</a></h3>
<p>意向锁是一种表级锁，表示事务打算对表中的某些行数据加锁，但不会直接锁定数据行本身。</p>
<p>由 InnoDB 自动管理，当事务需要添加行锁时，会先在表上添加意向锁。这样当要添加表锁的时候，可以通过查看表上的意向锁，快速判断是否有冲突，而无需逐行检查，从而提高加锁效率。
<img decoding="async" loading="lazy" alt="1756481738422" src="/doc/assets/images/1756481738422-4645e198a05081c96b625472d1f65476.png" width="1080" height="737" class="img_ev3q">
当执行 SELECT ... LOCK IN SHARE MODE 时，会自动加意向共享锁；当执行 SELECT ... FOR UPDATE 时，会自动加意向排他锁。</p>
<p>意向锁之间互相兼容，也不会与行锁冲突。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="意向锁的意义是什么">意向锁的意义是什么？<a href="#意向锁的意义是什么" class="hash-link" aria-label="Direct link to 意向锁的意义是什么？" title="Direct link to 意向锁的意义是什么？">​</a></h3>
<p>在没有意向锁的情况下，当事务 A 持有某表的行锁时，如果事务 B 想添加表锁，InnoDB 必须检查表中每一行数据是否被加锁，这种全表扫描的方式效率极低。
<img decoding="async" loading="lazy" alt="1756481785071" src="/doc/assets/images/1756481785071-577429d2e5b914f244af1acb36ce9d5a.png" width="1196" height="868" class="img_ev3q">
有了意向锁之后，事务在加行锁前，先在表上加对应的意向锁；其他事务加表锁时，只需检查表上的意向锁，无需逐行检查。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="mysql的乐观锁和悲观锁了解吗">🌟MySQL的乐观锁和悲观锁了解吗？<a href="#mysql的乐观锁和悲观锁了解吗" class="hash-link" aria-label="Direct link to 🌟MySQL的乐观锁和悲观锁了解吗？" title="Direct link to 🌟MySQL的乐观锁和悲观锁了解吗？">​</a></h3>
<p>悲观锁是一种&quot;先上锁再操作&quot;的保守策略，它假设数据被外界访问时必然会产生冲突，因此在数据处理过程中全程加锁，保证同一时间只有一个线程可以访问数据。
MySQL 中的行锁和表锁都是悲观锁。
<img decoding="async" loading="lazy" alt="1756481831954" src="/doc/assets/images/1756481831954-3d38cbfd554ee6d18e4d7f4fdad6e634.png" width="853" height="373" class="img_ev3q">
乐观锁会假设并发操作不会总发生冲突，属于小概率事件，因此不会在读取数据时加锁，而是在提交更新时才检查数据是否被其他事务修改过。
<img decoding="async" loading="lazy" alt="1756481836013" src="/doc/assets/images/1756481836013-3d38cbfd554ee6d18e4d7f4fdad6e634.png" width="853" height="373" class="img_ev3q">
乐观锁并不是 MySQL 内置的锁机制，而是通过程序逻辑实现的，常见的实现方式有版本号机制和时间戳机制。通过在表中增加 version 字段或者 timestamp 字段来实现。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何通过悲观锁和乐观锁解决库存超卖问题">如何通过悲观锁和乐观锁解决库存超卖问题？<a href="#如何通过悲观锁和乐观锁解决库存超卖问题" class="hash-link" aria-label="Direct link to 如何通过悲观锁和乐观锁解决库存超卖问题？" title="Direct link to 如何通过悲观锁和乐观锁解决库存超卖问题？">​</a></h3>
<p>悲观锁通过 SELECT ... FOR UPDATE 在查询时直接锁定记录，确保其他事务必须等待当前事务完成才能操作该行数据。</p>
<div class="language-mysql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-mysql codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">BEGIN;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-- 对id=1的商品记录加排他锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SELECT stock FROM products WHERE id=1 FOR UPDATE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-- 生成订单</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">INSERT INTO orders (user_id, product_id) VALUES (123, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-- 扣减库存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">UPDATE products SET stock=stock-1 WHERE id=1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">COMMIT;</span><br></span></code></pre></div></div>
<p>乐观锁通过在表中增加 version 字段作为判断条件。</p>
<div class="language-mysql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-mysql codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">-- 查询商品信息，获取版本号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SELECT stock, version FROM products WHERE id=1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-- 更新库存时检查版本号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">UPDATE products </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SET stock=stock-1, version=version+1 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WHERE id=1 AND version=旧版本号;</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="遇到过mysql死锁问题吗你是如何解决的">遇到过MySQL死锁问题吗，你是如何解决的？<a href="#遇到过mysql死锁问题吗你是如何解决的" class="hash-link" aria-label="Direct link to 遇到过MySQL死锁问题吗，你是如何解决的？" title="Direct link to 遇到过MySQL死锁问题吗，你是如何解决的？">​</a></h3>
<p>遇到过。MySQL 的死锁是由于多个事务持有资源并相互等待引起的。我通过 SHOW ENGINE INNODB STATUS 查看死锁信息，定位到是加锁顺序不一致导致的，最后通过调整加锁顺序解决了这个问题。
<img decoding="async" loading="lazy" alt="1756481996611" src="/doc/assets/images/1756481996611-72a7b945c541c14081d9d557443f1798.png" width="2400" height="1116" class="img_ev3q"></p>
<div class="language-mysql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-mysql codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">-- 创建表/插入数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CREATE TABLE account (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    id INT AUTO_INCREMENT PRIMARY KEY,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    balance INT NOT NULL</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">INSERT INTO account (balance) VALUES (100), (200);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-- 事务 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">START TRANSACTION;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-- 锁住 id=1 的行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">UPDATE account SET balance = balance - 10 WHERE id = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-- 等待锁住 id=2 的行（事务 2 已锁住）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">UPDATE account SET balance = balance + 10 WHERE id = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-- 事务 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">START TRANSACTION;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-- 锁住 id=2 的行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">UPDATE account SET balance = balance - 10 WHERE id = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-- 等待锁住 id=1 的行（事务 1 已锁住）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">UPDATE account SET balance = balance + 10 WHERE id = 1;</span><br></span></code></pre></div></div>
<p>访问相同的资源，但顺序不同，就会导致死锁。</p>
<p>解决办法也很简单，先使用 SHOW ENGINE INNODB STATUS\G; 确认死锁的具体信息，然后调整资源的访问顺序。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="事务">事务<a href="#事务" class="hash-link" aria-label="Direct link to 事务" title="Direct link to 事务">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="mysql事务的四大特性说一下">🌟MySQL事务的四大特性说一下？<a href="#mysql事务的四大特性说一下" class="hash-link" aria-label="Direct link to 🌟MySQL事务的四大特性说一下？" title="Direct link to 🌟MySQL事务的四大特性说一下？">​</a></h3>
<p>事务是一条或多条 SQL 语句组成的执行单元。四个特性分别是原子性、一致性、隔离性和持久性。
原子性保证事务中的操作要么全部执行、要么全部失败；
一致性保证数据从事务开始前的一个一致状态转移到结束后的另外一个一致状态；
隔离性保证并发事务之间互不干扰；
持久性保证事务提交后数据不会丢失。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="详细说一下原子性">详细说一下原子性？<a href="#详细说一下原子性" class="hash-link" aria-label="Direct link to 详细说一下原子性？" title="Direct link to 详细说一下原子性？">​</a></h4>
<p>简短回答：原子性要求事务的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务中的操作不能只执行其中一部分。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="详细说一下一致性">详细说一下一致性？<a href="#详细说一下一致性" class="hash-link" aria-label="Direct link to 详细说一下一致性？" title="Direct link to 详细说一下一致性？">​</a></h4>
<p>一致性确保数据的状态从一个一致状态转变为另一个一致状态。一致性与业务规则有关，比如银行转账，不论事务成功还是失败，转账双方的总金额应该是不变的。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="详细说一下隔离性">详细说一下隔离性？<a href="#详细说一下隔离性" class="hash-link" aria-label="Direct link to 详细说一下隔离性？" title="Direct link to 详细说一下隔离性？">​</a></h3>
<p>隔离性意味着并发执行的事务是彼此隔离的，一个事务的执行不会被其他事务干扰。事务之间是井水不犯河水的。</p>
<p>隔离性主要是为了解决事务并发执行时可能出现的脏读、不可重复读、幻读等问题。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="详细说一下持久性">详细说一下持久性？<a href="#详细说一下持久性" class="hash-link" aria-label="Direct link to 详细说一下持久性？" title="Direct link to 详细说一下持久性？">​</a></h3>
<p>一旦事务提交，则其所做的修改将永久保存到 MySQL 中。即使发生系统崩溃，修改的数据也不会丢失。</p>
<p>MySQL 的持久性是通过 InnoDB 引擎的 redo log 实现的。在事务提交时，InnoDB 会先将修改操作写入 redo log，并刷盘持久化。崩溃后，InnoDB 会通过 redo log 恢复数据，从而保证事务提交成功的数据不会丢失。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="acid-靠什么保证的呢">ACID 靠什么保证的呢？<a href="#acid-靠什么保证的呢" class="hash-link" aria-label="Direct link to ACID 靠什么保证的呢？" title="Direct link to ACID 靠什么保证的呢？">​</a></h3>
<p>ACID 中的原子性主要通过 Undo Log 来实现，持久性通过 Redo Log 来实现，隔离性由 MVCC 和锁机制来实现，一致性则由其他三大特性共同保证。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="详细说说如何保证原子性">详细说说如何保证原子性？<a href="#详细说说如何保证原子性" class="hash-link" aria-label="Direct link to 详细说说如何保证原子性？" title="Direct link to 详细说说如何保证原子性？">​</a></h4>
<p>事务对数据进行修改前，会记录一份快照到 Undo Log，如果事务中有任何一步执行失败，系统会读取 Undo Log 将所有操作回滚，恢复到事务开始前的状态，从而保证事务要么全部成功，要么全部失败。
<img decoding="async" loading="lazy" alt="1756482280050" src="/doc/assets/images/1756482280050-719cbfde206caf98506199b6f23a2715.png" width="418" height="461" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="详细说说如何保证持久性">详细说说如何保证持久性？<a href="#详细说说如何保证持久性" class="hash-link" aria-label="Direct link to 详细说说如何保证持久性？" title="Direct link to 详细说说如何保证持久性？">​</a></h4>
<p>MySQL 的持久性主要由预写 Redo Log、双写机制、两阶段提交以及 Checkpoint 刷盘机制共同保证。</p>
<p>当事务提交时，MySQL 会先将事务的修改操作写入 Redo Log，并强制刷盘，然后再将内存中的数据页刷入磁盘。这样即使系统崩溃，重启后也能通过 Redo Log 重放恢复数据。
<img decoding="async" loading="lazy" alt="1756482323188" src="/doc/assets/images/1756482323188-43fc021571f265d7fe7400484fd3b1ce.png" width="720" height="614" class="img_ev3q">
在将数据页写入到磁盘时，如果发生崩溃，可能会导致数据页不完整。InnoDB 的数据页大小为16KB，通常大于操作系统的 4KB页大小。</p>
<p>为了解决只写入部分的问题，MySQL 采用了双写机制，脏盘刷页时，先将数据页写入到一个双写缓冲区中，2M 的连续空间，然后再将其写入到磁盘的实际位置。
<img decoding="async" loading="lazy" alt="1756482367604" src="/doc/assets/images/1756482367604-8cd0869908a4e612b0d2722671a5e680.png" width="1080" height="551" class="img_ev3q">
崩溃恢复时，如果发现数据页不完整，会从双写缓冲区中恢复副本，确保数据页的完整性。</p>
<p>在涉及主从复制时，MySQL 通过两阶段提交保证 Redo Log 和 Binlog 的一致性：第一阶段，写入 Redo Log 并标记为 prepare 状态；第二阶段，写入 Binlog 再提交 Redo Log 为 commit 状态。
<img decoding="async" loading="lazy" alt="1756482384018" src="/doc/assets/images/1756482384018-9f57cff3c3fc660b4bddfb38fcc74da0.png" width="757" height="1492" class="img_ev3q">
崩溃恢复时，如果发现 Redo Log 是 prepare 但 Binlog 完整，则会提交事务；反之会回滚，避免主从不一致。</p>
<p>另外，由于 Redo Log 的容量有限，Checkpoint 机制会定期将内存中的脏页刷到磁盘，这样能减少崩溃恢复时需要处理的 Redo Log 数量。
<img decoding="async" loading="lazy" alt="1756482393496" src="/doc/assets/images/1756482393496-401ab092c8c5efe5c7b5fb9e3330f937.png" width="720" height="276" class="img_ev3q"></p>
<p>深入解析MySQL双写缓冲区   ？
MySQL 事务二阶段提交  ？</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="详细说说如何保证隔离性">详细说说如何保证隔离性？<a href="#详细说说如何保证隔离性" class="hash-link" aria-label="Direct link to 详细说说如何保证隔离性？" title="Direct link to 详细说说如何保证隔离性？">​</a></h3>
<p>隔离性主要通过锁机制和 MVCC 来实现。</p>
<p>比如说一个事务正在修改某条数据时，MySQL 会通过临键锁来防止其他事务同时进行修改，避免数据冲突。
<img decoding="async" loading="lazy" alt="1756482430078" src="/doc/assets/images/1756482430078-37f1eb9e6a452e159080bdf85935c0e7.png" width="1203" height="672" class="img_ev3q">
同时，临键锁可以防止幻读现象的发生。比如事务 A 查询 id &gt; 10 的记录，那么临键锁不仅会锁住 id=10 的行，还会锁住 10 后面的“间隙”，防止其他事务插入 id=15 的数据。</p>
<p>假如表中的主键有 id: 5, 10, 15, 20, 25，那么 InnoDB 会对以下区间和记录加锁：</p>
<p>加锁对象	类型	锁定含义
(10, 15]	临键锁	锁住 id=15 和前间隙，防止插入11~14
(15, 20]	临键锁	锁住了 id=20 和前间隙
(20, 25]	临键锁	锁住了 id=25 和前间隙
(25, +∞)	间隙锁	锁住尾部防止插入30等</p>
<p>MVCC 主要用来优化读操作，通过保存数据的历史版本，让读操作不需要加锁就能直接读取快照，提高读的并发性能。</p>
<p><img decoding="async" loading="lazy" alt="1756509832699" src="/doc/assets/images/1756509832699-7f70c24b3f25d37f24d0a5e8ae20265a.png" width="750" height="284" class="img_ev3q"></p>
<p>不同的隔离级别对应不同的实现策略，比如说在可重复读隔离级别下，事务第一次查询时会生成一个 Read View，之后所有读操作都复用这个视图，保证多次读取的结果一致</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何保证一致性呢">如何保证一致性呢？<a href="#如何保证一致性呢" class="hash-link" aria-label="Direct link to 如何保证一致性呢？" title="Direct link to 如何保证一致性呢？">​</a></h3>
<p>MySQL 的一致性并不是靠某一个机制单独保证的，而是原子性、隔离性和持久性协同作用的结果。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="事务会不会自动提交">事务会不会自动提交？<a href="#事务会不会自动提交" class="hash-link" aria-label="Direct link to 事务会不会自动提交？" title="Direct link to 事务会不会自动提交？">​</a></h3>
<p>是的，MySQL 默认开启了事务自动提交模式。</p>
<p>每条单独的 SQL 语句都会被视为一个独立的事务处理单元；SQL 语句执行成功后会自动执行 COMMIT；执行失败时会自动 ROLLBACK。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="事务的隔离级别有哪些">🌟事务的隔离级别有哪些？<a href="#事务的隔离级别有哪些" class="hash-link" aria-label="Direct link to 🌟事务的隔离级别有哪些？" title="Direct link to 🌟事务的隔离级别有哪些？">​</a></h3>
<p>隔离级别定义了一个事务可能受其他事务影响的程度，MySQL 支持四种隔离级别，分别是：读未提交、读已提交、可重复读和串行化
读未提交会出现脏读，读已提交会出现不可重复读，可重复读是 InnoDB 默认的隔离级别，可以避免脏读和不可重复读，但会出现幻读。不过通过 MVCC 和临键锁，能够防止大多数并发问题。</p>
<p>串行化最安全，但性能较差，通常不推荐使用</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="详细说说读未提交">详细说说读未提交？<a href="#详细说说读未提交" class="hash-link" aria-label="Direct link to 详细说说读未提交？" title="Direct link to 详细说说读未提交？">​</a></h4>
<p>事务可以读取其他未提交事务修改的数据。也就是说，如果未提交的事务一旦回滚，读取到的数据就会变成了“脏数据”，通常不会使用。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="什么是读已提交">什么是读已提交？<a href="#什么是读已提交" class="hash-link" aria-label="Direct link to 什么是读已提交？" title="Direct link to 什么是读已提交？">​</a></h4>
<p>读已提交避免了脏读，但可能会出现不可重复读，即同一事务内多次读取同一数据结果会不同，因为其他事务提交的修改，对当前事务是可见的。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="什么是可重复读">什么是可重复读？<a href="#什么是可重复读" class="hash-link" aria-label="Direct link to 什么是可重复读？" title="Direct link to 什么是可重复读？">​</a></h4>
<p>可重复读能确保同一事务内多次读取相同数据的结果一致，即使其他事务已提交修改。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="什么是可重复读-1">什么是可重复读？<a href="#什么是可重复读-1" class="hash-link" aria-label="Direct link to 什么是可重复读？" title="Direct link to 什么是可重复读？">​</a></h4>
<p>是 MySQL 默认的隔离级别，避免了“脏读”和“不可重复读”，通过 MVCC 和临键锁也能在一定程度上避免幻读。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是串行化">什么是串行化？<a href="#什么是串行化" class="hash-link" aria-label="Direct link to 什么是串行化？" title="Direct link to 什么是串行化？">​</a></h3>
<p>串行化是最高的隔离级别，通过强制事务串行执行来解决“幻读”问题。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="a-事务未提交b-事务上查询到的是旧值还是新值">A 事务未提交，B 事务上查询到的是旧值还是新值？<a href="#a-事务未提交b-事务上查询到的是旧值还是新值" class="hash-link" aria-label="Direct link to A 事务未提交，B 事务上查询到的是旧值还是新值？" title="Direct link to A 事务未提交，B 事务上查询到的是旧值还是新值？">​</a></h3>
<p>如果 B 是普通的 SELECT，也就是快照读，它读的是旧值，即事务 A 修改前的快照，并且不会阻塞；如果 B 是当前读，比如 SELECT … FOR UPDATE，它会被阻塞直到事务 A 提交或回滚。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="怎么更改事务的隔离级别">怎么更改事务的隔离级别？<a href="#怎么更改事务的隔离级别" class="hash-link" aria-label="Direct link to 怎么更改事务的隔离级别？" title="Direct link to 怎么更改事务的隔离级别？">​</a></h3>
<p>MySQL 支持通过 SET 语句修改事务隔离级别，包括全局级别、当前会话，但一般不建议在生产环境中随意修改隔离级别。</p>
<p>测试环境下可以使用 SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ; 可以修改当前会话的隔离级别。</p>
<p>使用 SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED; 可以修改全局隔离级别，影响新的连接，但不会改变现有会话。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="事务的隔离级别是如何实现的">事务的隔离级别是如何实现的？<a href="#事务的隔离级别是如何实现的" class="hash-link" aria-label="Direct link to 事务的隔离级别是如何实现的？" title="Direct link to 事务的隔离级别是如何实现的？">​</a></h3>
<p>读未提交通过行锁共享锁确保一个事务在更新行数据但没有提交的情况下，其他事务不能更新该行数据，但不会阻止脏读，意味着事务2 可以在事务1 提交之前读取到事务1 修改的数据。</p>
<p>读已提交会在更新数据前加行级排他锁，不允许其他事务写入或者读取未提交的数据，也就意味着事务2 不能在事务 1 提交之前读取到事务1 修改的数据，从而解决脏读的问题。
另外，读已提交会在每次读取数据前都生成一个新的 ReadView，所以会出现不可重复读的问题。</p>
<p>可重复读只在第一次读操作时生成 ReadView，后续读操作都会使用这个 ReadView，从而避免不可重复读的问题。
另外，对于当前读操作，可重复读会通过临键锁来锁住当前行和前间隙，防止其他事务在这个范围内插入数据，从而避免幻读的问题。</p>
<p>串行化级别下，事务在读操作时，会先加表级共享锁；在写操作时，会先加表级排他锁。
直到事务结束后才释放锁，这样就能确保事务之间不会相互干扰。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="请详细说说幻读呢">🌟请详细说说幻读呢？<a href="#请详细说说幻读呢" class="hash-link" aria-label="Direct link to 🌟请详细说说幻读呢？" title="Direct link to 🌟请详细说说幻读呢？">​</a></h3>
<p>幻读是指在同一个事务中，多次执行相同的范围查询，结果却不同。这种现象通常发生在其他事务在两次查询之间插入或删除了符合当前查询条件的数据。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何避免幻读">如何避免幻读？<a href="#如何避免幻读" class="hash-link" aria-label="Direct link to 如何避免幻读？" title="Direct link to 如何避免幻读？">​</a></h3>
<p>MySQL 在可重复读隔离级别下，通过 MVCC 和临键锁可以在一定程度上避免幻读。</p>
<p>比如说在查询时显示加锁，利用临键锁锁定查询范围，防止其他事务插入新的数据。
其他事务在插入数据时，会被阻塞，直到当前事务提交或回滚。</p>
<p>---- 这部分是帮助大家理解 start，面试中可以不背 ----</p>
<p>解释一下。</p>
<p>如果查询语句中包含显式加锁（如 FOR UPDATE），InnoDB 会使用当前读，直接读取最新的数据，并加锁。</p>
<p>在范围查询时，InnoDB 不仅会对符合条件的记录加行锁，还会对相邻的索引间隙加间隙锁，从而形成临键锁。
<img decoding="async" loading="lazy" alt="alt text" src="/doc/assets/images/image-de70ae3068b8f7c781839e67b8d744a7.png" width="1080" height="400" class="img_ev3q">
临键锁可以防止其他事务在间隙中插入新数据，从而避免幻读。</p>
<p>---- 这部分是帮助大家理解 end，面试中可以不背 ----</p>
<p>---- 这部分是帮助大家理解 start，面试中可以不背 ----</p>
<p>使用 SELECT 查询时，如果没有显式加锁，InnoDB 会使用 MVCC 提供一致性视图。</p>
<p>每个事务在启动时都会生成一个 Read View，用来确定哪些数据对当前事务可见。
<img decoding="async" loading="lazy" alt="1756510394720" src="/doc/assets/images/1756510394720-eb9ab1f00973658cd05cd329a0d1186b.png" width="1155" height="728" class="img_ev3q">
其他事务在当前事务启动后插入的新数据不会被当前事务看到，因此不会出现幻读。</p>
<p>---- 这部分是帮助大家理解 end，面试中可以不背 ----</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是当前读呢">什么是当前读呢？<a href="#什么是当前读呢" class="hash-link" aria-label="Direct link to 什么是当前读呢？" title="Direct link to 什么是当前读呢？">​</a></h3>
<p>当前读是指读取记录的最新已提交版本，并且在读取时对记录加锁，确保其他并发事务不能修改当前记录。</p>
<p>比如 SELECT ... LOCK IN SHARE MODE、SELECT ... FOR UPDATE，以及 UPDATE、DELETE，都属于当前读</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么-update-和-delete-也属于当前读">为什么 UPDATE 和 DELETE 也属于当前读？<a href="#为什么-update-和-delete-也属于当前读" class="hash-link" aria-label="Direct link to 为什么 UPDATE 和 DELETE 也属于当前读？" title="Direct link to 为什么 UPDATE 和 DELETE 也属于当前读？">​</a></h3>
<p>因为更新、删除这些操作，本质上不仅是写操作，还需要在写之前读取数据，然后才能修改或删除。为了保证修改的是最新的数据，并防止并发冲突，InnoDB 必须读取最新版本的数据并加锁，因此 UPDATE 和 DELETE 也属于当前读。
<img decoding="async" loading="lazy" alt="1756510432320" src="/doc/assets/images/1756510432320-4cf1e9233a0cbd23f6882e9009a65d27.png" width="640" height="524" class="img_ev3q"></p>
<p>SQL语句	是否当前读	是否加锁
SELECT * FROM user WHERE id=1	❌ 否	❌ 否
SELECT * FROM user WHERE id=1 FOR UPDATE	✅ 是	✅ 加排他锁
SELECT * FROM user WHERE id=1 LOCK IN SHARE MODE	✅ 是	✅ 加共享锁
UPDATE user SET ... WHERE id=1	✅ 是	✅ 加排他锁
DELETE FROM user WHERE id=1	✅ 是	✅ 加排他锁</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是快照读呢">什么是快照读呢？<a href="#什么是快照读呢" class="hash-link" aria-label="Direct link to 什么是快照读呢？" title="Direct link to 什么是快照读呢？">​</a></h3>
<p>快照读是 InnoDB 通过 MVCC 实现的一种非阻塞读方式。当事务执行 SELECT 查询时，InnoDB 并不会直接读当前最新的数据，而是根据事务开始时生成的 Read View 去判断每条记录的可见性，从而读取符合条件的历史版本。
<img decoding="async" loading="lazy" alt="1756510460387" src="/doc/assets/images/1756510460387-fc19ccc870d941e6a80a40823204d245.png" width="1330" height="749" class="img_ev3q">
SQL	是否快照读？	说明
SELECT * FROM t WHERE id=1	✅ 是	快照读
SELECT * FROM t WHERE id=1 FOR UPDATE	❌ 否	当前读，读取最新版本并加锁
UPDATE / DELETE	❌ 否	当前读，必须读取当前版本并加锁
INSERT	❌ 否	写操作，不存在历史版本</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="mvcc-了解吗">🌟MVCC 了解吗？<a href="#mvcc-了解吗" class="hash-link" aria-label="Direct link to 🌟MVCC 了解吗？" title="Direct link to 🌟MVCC 了解吗？">​</a></h3>
<p>MVCC 指的是多版本并发控制，每次修改数据时，都会生成一个新的版本，而不是直接在原有数据上进行修改。并且每个事务只能看到在它开始之前已经提交的数据版本。
<img decoding="async" loading="lazy" alt="1756510486253" src="/doc/assets/images/1756510486253-c343aadb3ad56469b7e81b51b5c35ead.png" width="1752" height="723" class="img_ev3q"></p>
<p>这样的话，读操作就不会阻塞写操作，写操作也不会阻塞读操作，从而避免加锁带来的性能损耗。</p>
<p>其底层实现主要依赖于 Undo Log 和 Read View。</p>
<p>每次修改数据前，先将记录拷贝到Undo Log，并且每条记录会包含三个隐藏列，DB_TRX_ID 用来记录修改该行的事务 ID，DB_ROLL_PTR 用来指向 Undo Log 中的前一个版本，DB_ROW_ID 用来唯一标识该行数据（仅无主键时生成）。
<img decoding="async" loading="lazy" alt="img_14.png" src="/doc/assets/images/img_14-3b976eb9d420357db404502e8a77aa4c.png" width="743" height="800" class="img_ev3q">
每次读取数据时，都会生成一个 ReadView，其中记录了当前活跃事务的 ID 集合、最小事务 ID、最大事务 ID 等信息，通过与 DB_TRX_ID 进行对比，判断当前事务是否可以看到该数据版本。
<img decoding="async" loading="lazy" alt="img_15.png" src="/doc/assets/images/img_15-a6d8b82710748fcca4f380413450f6ce.png" width="1268" height="978" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="请详细说说什么是版本链">请详细说说什么是版本链？<a href="#请详细说说什么是版本链" class="hash-link" aria-label="Direct link to 请详细说说什么是版本链？" title="Direct link to 请详细说说什么是版本链？">​</a></h3>
<p>版本链是指 InnoDB 中同一条记录的多个历史版本，通过 DB_ROLL_PTR 字段将它们像链表一样串起来，用来支持 MVCC 的快照读。</p>
<p><img decoding="async" loading="lazy" alt="img_16.png" src="/doc/assets/images/img_16-d0e8f9394834f073c5ea0f163c9ce275.png" width="1256" height="664" class="img_ev3q">
假设有一张hero表，表中有这样一行记录，name 为张三，city 为帝都，插入这行记录的事务 id 是 80。</p>
<p>此时，DB_TRX_ID的值就是 80，DB_ROLL_PTR的值就是指向这条 insert undo 日志的指针
<img decoding="async" loading="lazy" alt="img_17.png" src="/doc/assets/images/img_17-66be82fd2edf5e0fca4c58b9dfb91985.png" width="1080" height="268" class="img_ev3q"></p>
<p>接下来，如果有两个DB_TRX_ID分别为100、200的事务对这条记录进行了update操作，那么这条记录的版本链就会变成下面这样：
<img decoding="async" loading="lazy" alt="img_18.png" src="/doc/assets/images/img_18-57debfd395002d9c9e6cc486eba0c405.png" width="1080" height="459" class="img_ev3q">
也就是说，当更新一行数据时，InnoDB 不会直接覆盖原有数据，而是创建一个新的数据版本，并更新 DB_TRX_ID 和 DB_ROLL_PTR，使它们指向前一个版本和相关的 undo 日志。</p>
<p>这样，老版本的数据就不会丢失，可以通过版本链找到。</p>
<p>由于 undo 日志会记录每一次的 update，并且新插入的行数据会记录上一条 undo 日志的指针，所以可以通过 DB_ROLL_PTR 这个指针找到上一条记录，这样就形成了一个版本链。
<img decoding="async" loading="lazy" alt="img_19.png" src="/doc/assets/images/img_19-8d3e60ea60252352dae304ecb52da2a0.png" width="787" height="555" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="请详细说说什么是readview">请详细说说什么是ReadView？<a href="#请详细说说什么是readview" class="hash-link" aria-label="Direct link to 请详细说说什么是ReadView？" title="Direct link to 请详细说说什么是ReadView？">​</a></h3>
<p>ReadView 是 InnoDB 为每个事务创建的一份“可见性视图”，用于判断在执行快照读时，哪些数据版本是当前这个事务可以看到的，哪些不能看到。</p>
<p><img decoding="async" loading="lazy" alt="img_20.png" src="/doc/assets/images/img_20-4c9b0f4656fbab8a7beff7b7377a91dc.png" width="1094" height="594" class="img_ev3q">
当事务开始执行时，InnoDB 会为该事务创建一个 ReadView，这个 ReadView 会记录 4 个重要的信息：</p>
<p>creator_trx_id：创建该 ReadView 的事务 ID。
m_ids：所有活跃事务的 ID 列表，活跃事务是指那些已经开始但尚未提交的事务。
min_trx_id：所有活跃事务中最小的事务 ID。它是 m_ids 数组中最小的事务 ID。
max_trx_id ：事务 ID 的最大值加一。换句话说，它是下一个将要生成的事务 ID。
ReadView 是如何判断记录的某个版本是否可见的？
会通过三个步骤来判断：
<img decoding="async" loading="lazy" alt="img_21.png" src="/doc/assets/images/img_21-52bf05c471572514bb93a4763624e090.png" width="1696" height="994" class="img_ev3q">
①、如果某个数据版本的 DB_TRX_ID 小于 min_trx_id，则该数据版本在生成 ReadView 之前就已经提交，因此对当前事务是可见的。</p>
<p>②、如果 DB_TRX_ID 大于 max_trx_id，则表示创建该数据版本的事务在生成 ReadView 之后开始，因此对当前事务不可见。</p>
<p>③、如果 DB_TRX_ID 在 min_trx_id 和 max_trx_id 之间，需要判断 DB_TRX_ID 是否在 m_ids 列表中：</p>
<p>不在，表示创建该数据版本的事务在生成 ReadView 之后已经提交，因此对当前事务也是可见的。
在，表示事务仍然活跃，或者在当前事务生成 ReadView 之后才开始，因此是不可见的。
<img decoding="async" loading="lazy" alt="img_22.png" src="/doc/assets/images/img_22-f417a3c1f1083a867755b92b5dec304d.png" width="718" height="225" class="img_ev3q"></p>
<p>举个实际的例子。</p>
<p>读事务开启了一个 ReadView，这个 ReadView 里面记录了当前活跃事务的 ID 列表（444、555、665），以及最小事务 ID（444）和最大事务 ID（666）。当然还有自己的事务 ID 520，也就是 creator_trx_id。</p>
<p>它要读的这行数据的写事务 ID 是 x，也就是 DB_TRX_ID。</p>
<p>如果 x = 110，显然在 ReadView 生成之前就提交了，所以这行数据是可见的。
如果 x = 667，显然是未知世界，所以这行数据对读操作是不可见的。
如果 x = 519，虽然 519 大于 444 小于 666，但是 519 不在活跃事务列表里，所以这行数据是可见的。因为 519 是在 520 生成 ReadView 之前就提交了。
如果 x = 555，虽然 555 大于 444 小于 666，但是 555 在活跃事务列表里，所以这行数据是不可见的。因为 555 不确定有没有提交。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="可重复读和读已提交在-readview-上的区别是什么">可重复读和读已提交在 ReadView 上的区别是什么？<a href="#可重复读和读已提交在-readview-上的区别是什么" class="hash-link" aria-label="Direct link to 可重复读和读已提交在 ReadView 上的区别是什么？" title="Direct link to 可重复读和读已提交在 ReadView 上的区别是什么？">​</a></h3>
<p>可重复读：在第一次读取数据时生成一个 ReadView，这个 ReadView 会一直保持到事务结束，这样可以保证在事务中多次读取同一行数据时，读取到的数据是一致的。
<img decoding="async" loading="lazy" alt="img_23.png" src="/doc/assets/images/img_23-3ece4e3b78718590f6472dfad25bd728.png" width="1222" height="1246" class="img_ev3q">
读已提交：每次读取数据前都生成一个 ReadView，这样就能保证每次读取的数据都是最新的。</p>
<p>如果两个 AB 事务并发修改一个变量，那么 A 读到的值是什么，怎么分析。
事务 A 在读取时是否能读到事务 B 的修改，取决于 A 是快照读还是当前读。如果是快照读，InnoDB 会使用 MVCC 的 ReadView 判断记录版本是否可见，若事务 B 尚未提交或在 A 的视图不可见，则 A 会读到旧值；如果是当前读，则需要加锁，若 B 已提交可直接读取，否则 A 会阻塞直到 B 结束。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="高可用">高可用<a href="#高可用" class="hash-link" aria-label="Direct link to 高可用" title="Direct link to 高可用">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="mysql数据库读写分离了解吗">MySQL数据库读写分离了解吗？<a href="#mysql数据库读写分离了解吗" class="hash-link" aria-label="Direct link to MySQL数据库读写分离了解吗？" title="Direct link to MySQL数据库读写分离了解吗？">​</a></h3>
<p>读写分离就是把“写操作”交给主库处理，“读操作”分给多个从库处理，从而提升系统并发性能。
<img decoding="async" loading="lazy" alt="img_24.png" src="/doc/assets/images/img_24-b2ea6f3ed44216571bb8fef6395a43c9.png" width="892" height="942" class="img_ev3q"></p>
<p>应用层通过中间件（如 MyCat、ShardingSphere）自动路由请求，将 INSERT / UPDATE / DELETE 等写操作发送给主库，将 SELECT 查询操作发送给从库。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 示例：Java中通过不同数据源切换</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Transactional</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void updateOrder(Order order) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    masterDataSource.update(order); // 写操作走主库</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public Order getOrderById(Long id) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return slaveDataSource.query(id); // 读操作走从库</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>主库将数据变更通过 binlog 同步到从库，从而保持数据一致性。</p>
<p><img decoding="async" loading="lazy" alt="img_25.png" src="/doc/assets/images/img_25-73c17ecd2ccd3c6ec92eb47a71879bdb.png" width="921" height="691" class="img_ev3q">
主库 dump_thread 线程通过 TCP 将 binlog 推送给从库，从库 io_thread 线程，接收主库 binlog，写入 relay log，从库 sql_thread 线程读取 relay log，并顺序执行 SQL 语句，更新从库数据。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="读写分离的实现方式有哪些">读写分离的实现方式有哪些？<a href="#读写分离的实现方式有哪些" class="hash-link" aria-label="Direct link to 读写分离的实现方式有哪些？" title="Direct link to 读写分离的实现方式有哪些？">​</a></h3>
<p>实现读写分离有三种方式：最简单的是在应用层手动控制主从数据源，适用于小型项目；</p>
<p><img decoding="async" loading="lazy" alt="img_26.png" src="/doc/assets/images/img_26-a06a7fa36a967a4453df0b5f7ddd0905.png" width="892" height="880" class="img_ev3q">
中等项目是通过 Spring + 多数据源插件、AOP 注解自动路由；</p>
<p>大型系统通常使用中间件，如 ShardingSphere、MyCat，支持自动路由、负载均衡、故障转移等功能。
<img decoding="async" loading="lazy" alt="img_27.png" src="/doc/assets/images/img_27-1ddd1e266634adebbf9e57244af4893e.png" width="890" height="920" class="img_ev3q"></p>
<p>Mycat 的读写分离功能依赖于 MySQL 的主从复制架构：</p>
<p>writeHost: 表示主节点，负责处理所有的 DML SQL 语句，如 INSERT、UPDATE 和 DELETE。
readHost: 表示从节点，负责处理查询 SQL 语句（如 SELECT），以实现读写分离。
正常情况下，Mycat 会将第一个配置的 writeHost 作为默认的写节点。所有的 DML SQL 语句会被发送到此默认写节点执行。</p>
<p>写节点完成数据写入后，通过 MySQL 的主从复制机制，将数据同步到所有从节点，确保主从数据一致性</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="主从复制原理了解吗">主从复制原理了解吗？<a href="#主从复制原理了解吗" class="hash-link" aria-label="Direct link to 主从复制原理了解吗？" title="Direct link to 主从复制原理了解吗？">​</a></h3>
<p>MySQL 的主从复制是一种数据同步机制，用于将数据从主数据库复制到一个或多个从数据库。
<img decoding="async" loading="lazy" alt="img_28.png" src="/doc/assets/images/img_28-f628f1e13c9f4e915e7f8adfb03c7e04.png" width="1080" height="420" class="img_ev3q">
主库执行事务提交时，将数据变更以事件形式记录到 Binlog。从库通过 I/O 线程从主库的 Binlog 中读取变更事件，并将这些事件写入到本地的中继日志文件中，SQL 线程会实时监控中继日志的内容，按顺序读取并执行这些事件，从而保证从库与主库数据一致。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="主从同步延迟怎么处理">主从同步延迟怎么处理？<a href="#主从同步延迟怎么处理" class="hash-link" aria-label="Direct link to 主从同步延迟怎么处理？" title="Direct link to 主从同步延迟怎么处理？">​</a></h3>
<p>主从同步延迟是因为从库需要先接收 binlog，再执行 SQL 才能同步主库数据，在高并发写或网络抖动时容易出现延迟，导致读写不一致。</p>
<p>第一种解决方案：对一致性要求高的查询（如支付结果查询）可以直接走主库。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 伪代码示例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public Object query(String sql) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(isWriteQuery(sql) || needStrongConsistency(sql)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return masterDataSource.query(sql);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return slaveDataSource.query(sql);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>第二种解决方案：对于非关键业务允许短暂数据不一致，可以提示用户“数据同步中，请稍后刷新”，然后借助异步通知机制替代实时查询。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 伪代码示例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public Object query(String sql) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(isWriteQuery(sql)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return masterDataSource.query(sql);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 异步通知用户数据已更新</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        notifyUser(&quot;数据同步中，请稍后刷新&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return slaveDataSource.query(sql);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>第三种解决方案：采用半同步复制，主库在事务提交时，要等至少一个从库确认收到 binlog（但不要求执行完成），才算提交成功。
<img decoding="async" loading="lazy" alt="img_29.png" src="/doc/assets/images/img_29-b8cc425e4eb1b73678ecf00c9f8669c0.png" width="523" height="369" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="请说说半同步复制的流程">请说说半同步复制的流程？<a href="#请说说半同步复制的流程" class="hash-link" aria-label="Direct link to 请说说半同步复制的流程？" title="Direct link to 请说说半同步复制的流程？">​</a></h3>
<p>第一步，主库安装半同步插件：
INSTALL PLUGIN rpl_semi_sync_master SONAME &#x27;semisync_master.so&#x27;;
第二步，主库启用半同步复制并设置超时时间：
SET GLOBAL rpl_semi_sync_master_enabled = 1;
SET GLOBAL rpl_semi_sync_master_timeout = 10000;
主库 my.cnf 配置示例：</p>
<div class="language-ini codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-ini codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[mysqld]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plugin-load = &quot;rpl_semi_sync_master=semisync_master.so&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rpl_semi_sync_master_enabled = 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rpl_semi_sync_master_timeout = 10000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># MySQL 5.7+建议使用无损模式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rpl_semi_sync_master_wait_point = AFTER_SYNC</span><br></span></code></pre></div></div>
<p>第三步，从库安装半同步插件：
INSTALL PLUGIN rpl_semi_sync_slave SONAME &#x27;semisync_slave.so&#x27;;
第四步，从库启用半同步复制：
SET GLOBAL rpl_semi_sync_slave_enabled = 1;
从库 my.cnf 配置示例：</p>
<div class="language-ini codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-ini codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[mysqld]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plugin-load = &quot;rpl_semi_sync_slave=semisync_slave.so&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rpl_semi_sync_slave_enabled = 1</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="你们一般是怎么分库的呢">🌟你们一般是怎么分库的呢？<a href="#你们一般是怎么分库的呢" class="hash-link" aria-label="Direct link to 🌟你们一般是怎么分库的呢？" title="Direct link to 🌟你们一般是怎么分库的呢？">​</a></h3>
<p>分库的策略有两种，第一种是垂直分库：按照业务模块将不同的表拆分到不同的库中，比如说用户、登录、权限等表放在用户库中，商品、分类、库存放在商品库中，优惠券、满减、秒杀放在活动库中。
<img decoding="async" loading="lazy" alt="img_30.png" src="/doc/assets/images/img_30-b2edf72e270f7f8696d4042f264c7a6f.png" width="1080" height="781" class="img_ev3q">
第二种是水平分库：按照一定的策略将一个表中的数据拆分到多个库中，比如哈希分片和范围分片，对用户 id 进行取模运算或者范围划分，将数据分散到不同的库中。
<img decoding="async" loading="lazy" alt="img_31.png" src="/doc/assets/images/img_31-5a47d6e8adc1565aacf0ccc5fecb51ce.png" width="1080" height="680" class="img_ev3q">
贴一段使用 ShardingSphere 的 inline 算法定义分片规则：</p>
<div class="language-yaml codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-yaml codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token key atrule" style="color:#00a4db">rules</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token tag" style="color:#00009f">!SHARDING</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">tables</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">order</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">actualDataNodes</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> db_$</span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain">0..3</span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain">.order_$</span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain">0..15</span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">databaseStrategy</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token key atrule" style="color:#00a4db">standard</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          </span><span class="token key atrule" style="color:#00a4db">shardingColumn</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> user_id</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          </span><span class="token key atrule" style="color:#00a4db">shardingAlgorithmName</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> db_hash_mod</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">tableStrategy</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token key atrule" style="color:#00a4db">standard</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          </span><span class="token key atrule" style="color:#00a4db">shardingColumn</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> order_time</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          </span><span class="token key atrule" style="color:#00a4db">shardingAlgorithmName</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> table_interval_yearly</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">shardingAlgorithms</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">db_hash_mod</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">type</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> HASH_MOD</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">props</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token key atrule" style="color:#00a4db">sharding-count</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">4</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">table_interval_yearly</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">type</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> INTERVAL</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">props</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token key atrule" style="color:#00a4db">datetime-pattern</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;yyyy-MM-dd HH:mm:ss&#x27;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token key atrule" style="color:#00a4db">datetime-lower</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;2024-01-01 00:00:00&#x27;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token key atrule" style="color:#00a4db">datetime-upper</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;2025-01-01 00:00:00&#x27;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token key atrule" style="color:#00a4db">sharding-suffix-pattern</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;yyyy&#x27;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token key atrule" style="color:#00a4db">datetime-interval-amount</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token key atrule" style="color:#00a4db">datetime-interval-unit</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;Years&#x27;</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="那你们是怎么分表的">🌟那你们是怎么分表的？<a href="#那你们是怎么分表的" class="hash-link" aria-label="Direct link to 🌟那你们是怎么分表的？" title="Direct link to 🌟那你们是怎么分表的？">​</a></h3>
<p>当单表超过 500 万条数据，就可以考虑水平分表了。比如说我们可以将文章表拆分成多个表，如 article_0、article_9999、article_19999 等。
<img decoding="async" loading="lazy" alt="img_32.png" src="/doc/assets/images/img_32-693ae5671965e64a50bea0c2be7f1552.png" width="1080" height="850" class="img_ev3q">
在技术派实战项目中，我们将文章的基本信息和内容详情做了垂直分表处理，因为文章的内容会占用比较大的空间，在只需要查看文章基本信息时把文章详情也带出来的话，就会占用更多的网络 IO 和内存导致查询变慢；而文章的基本信息，如标题、作者、状态等信息占用的空间较小，很适合不需要查询文章详情的场景。
<img decoding="async" loading="lazy" alt="img_33.png" src="/doc/assets/images/img_33-3ac5b01f19a2997901281ed0616c9470.png" width="2084" height="1804" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="水平分库分表的分片策略有哪几种">水平分库分表的分片策略有哪几种？<a href="#水平分库分表的分片策略有哪几种" class="hash-link" aria-label="Direct link to 水平分库分表的分片策略有哪几种？" title="Direct link to 水平分库分表的分片策略有哪几种？">​</a></h3>
<p>常见的分片策略有三种，范围分片、Hash 分片和路由分片。</p>
<p>范围分片是根据某个字段的值范围进行水平拆分。适用于分片键具有连续性的场景。
<img decoding="async" loading="lazy" alt="img_34.png" src="/doc/assets/images/img_34-8c72bc3889a72632dfed864ed65470e0.png" width="801" height="433" class="img_ev3q">
比如说将 user_id 作为分片键：</p>
<p>1 ~ 10000 → db1.user_1
10001 ~ 20000 → db2.user_2
Hash 分片是指通过对分片键的值进行哈希取模，将数据均匀分布到多个库表中，适用于分片键具有离散性的场景。
<img decoding="async" loading="lazy" alt="img_35.png" src="/doc/assets/images/img_35-1f29355577875a01ed4001c8db06f272.png" width="664" height="411" class="img_ev3q">
比如说我们一开始规划好了 4 个表，那么就可以简单地通过取模来实现分表：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public String getTableNameByHash(long userId) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int tableIndex = (int) (userId % 4);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return &quot;user_&quot; + tableIndex;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>路由分片是通过路由配置来确定数据应该存储在哪个库表，适用于分片键不规律的场景。</p>
<p><img decoding="async" loading="lazy" alt="img_36.png" src="/doc/assets/images/img_36-2e7f49518414a86d569db4871ed85b40.png" width="953" height="555" class="img_ev3q">
比如说我们可以通过 order_router 表来确定订单数据存储在哪个表中：</p>
<p>order_id	table_id
xxxx	table_1
yyyy	table_2
zzzz	table_3</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="不停机扩容怎么实现">不停机扩容怎么实现？<a href="#不停机扩容怎么实现" class="hash-link" aria-label="Direct link to 不停机扩容怎么实现？" title="Direct link to 不停机扩容怎么实现？">​</a></h3>
<p>第一个阶段：新旧库同时写入，确保数据实时同步；可以借助消息队列实现异步补偿，幂等避免重复写入。读操作仍然走旧库。
<img decoding="async" loading="lazy" alt="img_37.png" src="/doc/assets/images/img_37-89cdd23f80c42510cb377b868f66cb35.png" width="1074" height="710" class="img_ev3q"></p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Transactional</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void createOrder(Order order) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    oldDB.insert(order);  // 写入旧库</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    newDB.insert(order);  // 写入新扩容节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    kafka.send(&quot;data_sync&quot;, order);  // 异步补偿通道</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>第二个阶段，通过 Canal 或者自研脚本将旧库的历史数据同步到新库。关键业务在查询时同时查询新旧库，进行数据校验，确保一致性。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public List&lt;Order&gt; getOrders(Long userId) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    List&lt;Order&gt; orders = newDB.getOrders(userId);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    List&lt;Order&gt; oldOrders = oldDB.getOrders(userId);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!orders.equals(oldOrders)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 数据不一致，进行补偿</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        kafka.send(&quot;data_sync&quot;, oldOrders);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>第三个阶段，在确认新库数据一致性后，逐步将读请求切换到新库，然后下线旧库。
<img decoding="async" loading="lazy" alt="img_38.png" src="/doc/assets/images/img_38-0d24139ae8b805a115f733caa92ddcfa.png" width="1076" height="564" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="常用的分库分表中间件有哪些">常用的分库分表中间件有哪些？<a href="#常用的分库分表中间件有哪些" class="hash-link" aria-label="Direct link to 常用的分库分表中间件有哪些？" title="Direct link to 常用的分库分表中间件有哪些？">​</a></h3>
<p>常用的分库分表中间件有 ShardingSphere 和 Mycat。
①、ShardingSphere 最初由当当开源，后来贡献给了 Apache，其子项目 Sharding-JDBC 主要在 Java 的 JDBC 层提供额外的服务。无需额外部署和依赖，可理解为增强版的 JDBC 驱动，完全兼容 JDBC 和各种 ORM 框架。
<img decoding="async" loading="lazy" alt="img_39.png" src="/doc/assets/images/img_39-4805878e86f96b42da6375cdff40a2b7.png" width="1462" height="740" class="img_ev3q">
②、Mycat 是由阿里巴巴的一款产品 Cobar 衍生而来，可以把它看作一个数据库代理。
<img decoding="async" loading="lazy" alt="img_40.png" src="/doc/assets/images/img_40-a551c4da4586b50e84d81ee745bd25b6.png" width="881" height="751" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="你觉得分库分表会带来什么问题呢">你觉得分库分表会带来什么问题呢？<a href="#你觉得分库分表会带来什么问题呢" class="hash-link" aria-label="Direct link to 你觉得分库分表会带来什么问题呢？" title="Direct link to 你觉得分库分表会带来什么问题呢？">​</a></h3>
<p>第一，跨库事务无法依赖单机 MySQL 的 ACID 特性，需要使用分布式事务解决方案，如 Seata 的 AT 模式、TCC 模式等。
<img decoding="async" loading="lazy" alt="img_41.png" src="/doc/assets/images/img_41-ea28f71913891a4746dc75356732ed35.png" width="2786" height="1596" class="img_ev3q"></p>
<p>第二，跨库后无法使用 JOIN 联表查询。可以在业务层进行拼接，或者把需要联表查询的数据放到 ES 中。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Java 代码示例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">User user = userService.getUserById(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;Order&gt; orders = orderService.getOrdersByUserId(1);</span><br></span></code></pre></div></div>
<p>第三，自增 ID 在分片场景下容易冲突，需要使用全局唯一方案。
数据库表被切分后，不能再依赖数据库自身的主键生成机制，所以需要一些手段来保证全局主键唯一。比如说雪花算法、京东的 JD-hotkey。
<img decoding="async" loading="lazy" alt="img_42.png" src="/doc/assets/images/img_42-05ea80825050cd94695ef220a53ed258.png" width="1718" height="1432" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="你们项目中的分布式主键-id-是怎么生成的">你们项目中的分布式主键 id 是怎么生成的？<a href="#你们项目中的分布式主键-id-是怎么生成的" class="hash-link" aria-label="Direct link to 你们项目中的分布式主键 id 是怎么生成的？" title="Direct link to 你们项目中的分布式主键 id 是怎么生成的？">​</a></h3>
<p>在技术派项目中，我们在雪花算法的基础上实现了一套自定义的 ID 生成方案，通过更改时间戳单位、ID 长度、workId 与 dataCenterId 的分配比例，ID 生成的延迟降低了 20%；满足了分布式环境下 ID 的唯一性。
<img decoding="async" loading="lazy" alt="img_43.png" src="/doc/assets/images/img_43-52f6779460a1beadeea9b2b7ba682914.png" width="2598" height="1818" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="雪花算法具体是怎么实现的">雪花算法具体是怎么实现的？<a href="#雪花算法具体是怎么实现的" class="hash-link" aria-label="Direct link to 雪花算法具体是怎么实现的？" title="Direct link to 雪花算法具体是怎么实现的？">​</a></h3>
<p>雪花算法是 Twitter 开源的分布式 ID 生成算法，其核心思想是：使用一个 64 位的数字来作为全局唯一 ID。</p>
<p>第 1 位是符号位，永远是 0，表示正数。
接下来的 41 位是时间戳，记录的是当前时间戳减去一个固定的开始时间戳，可以使用 69 年。
然后是 10 位的工作机器 ID。
最后是 12 位的序列号，每毫秒最多可生成 4096 个 ID。
<img decoding="async" loading="lazy" alt="img_44.png" src="/doc/assets/images/img_44-40a9c853089aae1f2fda122332694295.png" width="2104" height="1602" class="img_ev3q">
大致的实现代码如下所示：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class SnowflakeIdGenerator {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private long datacenterId = 1L; // 数据中心ID</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private long machineId = 1L; // 机器ID</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private long sequence = 0L; // 序列号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private long lastTimestamp = -1L;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized long nextId() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long timestamp = System.currentTimeMillis();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (timestamp == lastTimestamp) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sequence = (sequence + 1) &amp; 4095;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (sequence == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                while (timestamp == lastTimestamp) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    timestamp = System.currentTimeMillis();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sequence = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lastTimestamp = timestamp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ((timestamp - 1609459200000L) &lt;&lt; 22) | (datacenterId &lt;&lt; 17) | (machineId &lt;&lt; 12) | sequence;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="运维">运维<a href="#运维" class="hash-link" aria-label="Direct link to 运维" title="Direct link to 运维">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="百万级别以上的数据如何删除">百万级别以上的数据如何删除？<a href="#百万级别以上的数据如何删除" class="hash-link" aria-label="Direct link to 百万级别以上的数据如何删除？" title="Direct link to 百万级别以上的数据如何删除？">​</a></h3>
<p>在处理百万级别的数据删除时，大范围的 DELETE 语句往往会造成锁表时间长、事务日志膨胀等问题。</p>
<p>可以采用批量删除的方案，将删除操作分成多个小批次进行处理。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public void batchDelete(String tableName, String condition, int batchSize) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 1. 创建线程池</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int threadCount = Runtime.getRuntime().availableProcessors();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ExecutorService executor = Executors.newFixedThreadPool(threadCount);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    CountDownLatch latch = new CountDownLatch(threadCount);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 2. 获取总记录数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long totalCount = getTotalCount(tableName, condition);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 3. 计算每个线程处理的数据量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long perThreadCount = totalCount / threadCount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 4. 分配任务给线程池</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; threadCount; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long startId = i * perThreadCount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long endId = (i == threadCount - 1) ? totalCount : (startId + perThreadCount);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        executor.execute(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 分批次删除数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (long j = startId; j &lt; endId; j += batchSize) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    String deleteSql = String.format(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        &quot;DELETE FROM %s WHERE %s LIMIT %d&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        tableName, condition, batchSize</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 执行删除</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    jdbcTemplate.update(deleteSql);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                latch.countDown();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 5. 等待所有线程完成</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    latch.await();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    executor.shutdown();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>也可以采用创建新表替换原表的方式，把需要保留的数据迁移到新表中，然后删除旧表。</p>
<p>简单的方案：</p>
<div class="language-sql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-sql codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">-- 1. 创建新表结构(包含索引)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">CREATE</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">TABLE</span><span class="token plain"> new_table </span><span class="token operator" style="color:#393A34">LIKE</span><span class="token plain"> large_table</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">-- 2. 插入需要保留的数据</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">INSERT</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">INTO</span><span class="token plain"> new_table </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">SELECT</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">FROM</span><span class="token plain"> large_table </span><span class="token keyword" style="color:#00009f">WHERE</span><span class="token plain"> condition</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">-- 3. 重命名表</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">RENAME</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">TABLE</span><span class="token plain"> large_table </span><span class="token keyword" style="color:#00009f">TO</span><span class="token plain"> old_table</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> new_table </span><span class="token keyword" style="color:#00009f">TO</span><span class="token plain"> large_table</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">-- 4. 删除旧表</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">DROP</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">TABLE</span><span class="token plain"> old_table</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre></div></div>
<p>加入检查表空间、分批导入数据、验证数据一致性等步骤：</p>
<div class="language-sql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-sql codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">-- 1. 在执行之前先检查空间是否足够</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">SELECT</span><span class="token plain"> table_schema</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       table_name</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       </span><span class="token function" style="color:#d73a49">round</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">data_length </span><span class="token operator" style="color:#393A34">+</span><span class="token plain"> index_length</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">/</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1024</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">/</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1024</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">2</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;Size in MB&quot;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">FROM</span><span class="token plain"> information_schema</span><span class="token punctuation" style="color:#393A34">.</span><span class="token keyword" style="color:#00009f">TABLES</span><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">WHERE</span><span class="token plain"> table_schema </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">DATABASE</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">AND</span><span class="token plain"> table_name </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;large_table&#x27;</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">-- 2. 创建新表</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">CREATE</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">TABLE</span><span class="token plain"> new_table </span><span class="token operator" style="color:#393A34">LIKE</span><span class="token plain"> large_table</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">-- 3. 分批导入数据（避免一次性导入过多数据）</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">SET</span><span class="token plain"> </span><span class="token variable" style="color:#36acaa">@batch</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">SET</span><span class="token plain"> </span><span class="token variable" style="color:#36acaa">@batch_size</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">10000</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">SET</span><span class="token plain"> </span><span class="token variable" style="color:#36acaa">@total</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">SELECT</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">COUNT</span><span class="token punctuation" style="color:#393A34">(</span><span class="token operator" style="color:#393A34">*</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">FROM</span><span class="token plain"> large_table </span><span class="token keyword" style="color:#00009f">WHERE</span><span class="token plain"> condition</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">REPEAT</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">INSERT</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">INTO</span><span class="token plain"> new_table </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">SELECT</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">FROM</span><span class="token plain"> large_table </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">WHERE</span><span class="token plain"> condition</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">LIMIT</span><span class="token plain"> </span><span class="token variable" style="color:#36acaa">@batch_size</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">SET</span><span class="token plain"> </span><span class="token variable" style="color:#36acaa">@batch</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token variable" style="color:#36acaa">@batch</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">+</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">UNTIL </span><span class="token variable" style="color:#36acaa">@batch</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> </span><span class="token variable" style="color:#36acaa">@batch_size</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> </span><span class="token variable" style="color:#36acaa">@total</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">END</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">REPEAT</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">-- 4. 验证数据一致性</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">SELECT</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">COUNT</span><span class="token punctuation" style="color:#393A34">(</span><span class="token operator" style="color:#393A34">*</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">FROM</span><span class="token plain"> new_table</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">SELECT</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">COUNT</span><span class="token punctuation" style="color:#393A34">(</span><span class="token operator" style="color:#393A34">*</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">FROM</span><span class="token plain"> large_table </span><span class="token keyword" style="color:#00009f">WHERE</span><span class="token plain"> condition</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">-- 5. 在业务低峰期执行表切换</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">RENAME</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">TABLE</span><span class="token plain"> large_table </span><span class="token keyword" style="color:#00009f">TO</span><span class="token plain"> old_table</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             new_table </span><span class="token keyword" style="color:#00009f">TO</span><span class="token plain"> large_table</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">-- 6. 确认无误后再删除旧表（建议不要立即删除）</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">-- DROP TABLE old_table;</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="千万级大表如何添加字段">千万级大表如何添加字段？<a href="#千万级大表如何添加字段" class="hash-link" aria-label="Direct link to 千万级大表如何添加字段？" title="Direct link to 千万级大表如何添加字段？">​</a></h3>
<p>在低版本的 MySQL 中，千万级数据量的表中添加字段时，直接使用 ALTER TABLE 命令会导致长时间锁表、甚至数据库崩溃等。</p>
<p>可以使用 Percona Toolkit 的 pt-online-schema-change 来完成，它通过创建临时表、逐步同步数据并使用触发器捕获变更来实现。
对于 MySQL 8.0+ 版本，可以直接通过 ALTER TABLE 来完成，因为加入了 INSTAN 算法，添加列并不会长时间锁表。
如果没有指定 ALGORITHM=INSTANT 算法，MySQL 会先尝试 INSTANT 算法；如果无法完成，会切换到 INPLACE 算法；如果仍然无法完成，会尝试 COPY 算法。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="mysql-导致-cpu-飙升的话要怎么处理呢">MySQL 导致 cpu 飙升的话，要怎么处理呢？<a href="#mysql-导致-cpu-飙升的话要怎么处理呢" class="hash-link" aria-label="Direct link to MySQL 导致 cpu 飙升的话，要怎么处理呢？" title="Direct link to MySQL 导致 cpu 飙升的话，要怎么处理呢？">​</a></h3>
<p>我通常先通过 top 命令确认是否是 mysqld 的进程占用。
然后通过 SHOW PROCESSLIST 和慢查询日志定位是否存在耗时 SQL，再配合 explain 和 performance_schema 分析 SQL 是否命中索引，是否存在临时表和排序。</p>
<div class="language-sql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-sql codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">-- 使用 EXPLAIN 分析SQL执行计划</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">EXPLAIN</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">SELECT</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">FROM</span><span class="token plain"> large_table </span><span class="token keyword" style="color:#00009f">WHERE</span><span class="token plain"> condition</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">-- 查看表的索引使用情况</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">SHOW</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">INDEX</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">FROM</span><span class="token plain"> table_name</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">-- 查看InnoDB状态</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">SHOW</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">ENGINE</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">INNODB</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">STATUS</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">-- 查看表的统计信息</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">ANALYZE</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">TABLE</span><span class="token plain"> table_name</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre></div></div>
<p>最终通过 SQL 优化、加索引、分批操作等手段逐步优化。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="sql题">sql题<a href="#sql题" class="hash-link" aria-label="Direct link to sql题" title="Direct link to sql题">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="新建一个表结构创建索引将百万或千万级的数据使用-insert-导入该表新建一个表结构将百万或千万级的数据使用-isnert-导入该表再创建索引这两种效率哪个高呢或者说用时短呢">新建一个表结构，创建索引，将百万或千万级的数据使用 insert 导入该表，新建一个表结构，将百万或千万级的数据使用 isnert 导入该表，再创建索引，这两种效率哪个高呢？或者说用时短呢？<a href="#新建一个表结构创建索引将百万或千万级的数据使用-insert-导入该表新建一个表结构将百万或千万级的数据使用-isnert-导入该表再创建索引这两种效率哪个高呢或者说用时短呢" class="hash-link" aria-label="Direct link to 新建一个表结构，创建索引，将百万或千万级的数据使用 insert 导入该表，新建一个表结构，将百万或千万级的数据使用 isnert 导入该表，再创建索引，这两种效率哪个高呢？或者说用时短呢？" title="Direct link to 新建一个表结构，创建索引，将百万或千万级的数据使用 insert 导入该表，新建一个表结构，将百万或千万级的数据使用 isnert 导入该表，再创建索引，这两种效率哪个高呢？或者说用时短呢？">​</a></h3>
<p>在大数据量导入场景下，先导入数据，后建索引的效率显著高于先建索引，后导入数据的效率。</p>
<p>先插入数据再创建索引：在没有索引的情况下插入数据，数据库不需要在每次插入时更新索引。
先创建索引再插入数据：数据库需要在每次插入新记录时维护索引结构，随着数据量的增加，索引的维护会导致额外的性能开销。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="mysql是先建立索引好还是先插入数据好">MySQL是先建立索引好还是先插入数据好？<a href="#mysql是先建立索引好还是先插入数据好" class="hash-link" aria-label="Direct link to MySQL是先建立索引好还是先插入数据好？" title="Direct link to MySQL是先建立索引好还是先插入数据好？">​</a></h3>
<p>如果是小批量插入，可以先建索引；但在大数据量数据导入场景下，推荐先插入数据再建索引。</p>
<p>因为索引是基于 B+ 树的，大量插入时如果提前建索引，会频繁触发页分裂和索引结构调整，影响性能。</p>
<p>插入完成后统一构建索引，MySQL 会按顺序批量生成索引结构，速度更快、资源消耗更低。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是深分页select--from-tbn-limit-1000000000-这个有什么问题如果表大或者表小分别什么问题">什么是深分页，select * from tbn limit 1000000000 这个有什么问题，如果表大或者表小分别什么问题<a href="#什么是深分页select--from-tbn-limit-1000000000-这个有什么问题如果表大或者表小分别什么问题" class="hash-link" aria-label="Direct link to 什么是深分页，select * from tbn limit 1000000000 这个有什么问题，如果表大或者表小分别什么问题" title="Direct link to 什么是深分页，select * from tbn limit 1000000000 这个有什么问题，如果表大或者表小分别什么问题">​</a></h3>
<p>深分页是指在 MySQL 中获取比较靠后的数据页，比如第 1000 页、第 10000 页等。特别是使用 LIMIT offset,count 这种方式，当 offset 特别大，就会带来严重的性能问题。</p>
<p>对于 SELECT * FROM tbn LIMIT 1000000,10，这样的查询语句来说，MySQL 会：</p>
<p>从表中读取第一条记录，判断是否满足 where 条件；如果满足，计数器+1；否则直到 计数器累计到 1000000 时才开始真正取数据
再继续获取 10 条数据，返回
性能会非常差，因为需要从头扫描，无法利用索引优化，并且需要抛弃大量不需要的数据，占用大量的内存和 CPU 资源。</p>
<p>可以借助主键索引分页进行优化：</p>
<div class="language-sql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-sql codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">SELECT</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">FROM</span><span class="token plain"> tbn</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">WHERE</span><span class="token plain"> id </span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">SELECT</span><span class="token plain"> id </span><span class="token keyword" style="color:#00009f">FROM</span><span class="token plain"> tbn </span><span class="token keyword" style="color:#00009f">ORDER</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">BY</span><span class="token plain"> id </span><span class="token keyword" style="color:#00009f">LIMIT</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1000000</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">LIMIT</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">10</span><br></span></code></pre></div></div>
<p>或者记住上次分页的最大 ID，然后再查询：</p>
<div class="language-sql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-sql codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">SELECT</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">FROM</span><span class="token plain"> tbn</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">WHERE</span><span class="token plain"> id </span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> last_page_max_id</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">LIMIT</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">10</span><br></span></code></pre></div></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-tags-row"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a rel="tag" class="tag_zVej tagRegular_sFm0" href="/doc/docs/tags/interview">INTERVIEW</a></li><li class="tag_QGVx"><a rel="tag" class="tag_zVej tagRegular_sFm0" href="/doc/docs/tags/mysql">MYSQL</a></li></ul></div></div><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/MYSQL/mysql-review.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/doc/docs/INTERVIEW/MQ"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">ROCKETMQ_REVIEW</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/doc/docs/MYSQL/mysql-tmp"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">mysql-tmp</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#mysql-基础" class="table-of-contents__link toc-highlight">mysql 基础</a><ul><li><a href="#mysql的date和timestamp的区别" class="table-of-contents__link toc-highlight">mysql的date和timestamp的区别？</a></li><li><a href="#sql-查询语句的执行顺序了解吗" class="table-of-contents__link toc-highlight">SQL 查询语句的执行顺序了解吗？</a></li><li><a href="#in-和-exists的差别" class="table-of-contents__link toc-highlight">IN 和 EXISTS的差别</a></li><li><a href="#记录货币用什么类型比较好" class="table-of-contents__link toc-highlight">记录货币用什么类型比较好？</a></li><li><a href="#dropdelete-与-truncate-的区别" class="table-of-contents__link toc-highlight">drop、delete 与 truncate 的区别？</a></li><li><a href="#用过哪些-mysql-函数补充" class="table-of-contents__link toc-highlight">用过哪些 MySQL 函数？（补充）</a></li><li><a href="#说说-mysql-的基础架构" class="table-of-contents__link toc-highlight">说说 MySQL 的基础架构？</a></li></ul></li><li><a href="#数据库架构" class="table-of-contents__link toc-highlight">数据库架构</a><ul><li><a href="#一条查询语句是如何执行的" class="table-of-contents__link toc-highlight">🌟一条查询语句是如何执行的？</a></li><li><a href="#一条更新语句是如何执行的" class="table-of-contents__link toc-highlight">一条更新语句是如何执行的？</a></li><li><a href="#说说-mysql-的段区页行补充" class="table-of-contents__link toc-highlight">说说 MySQL 的段区页行（补充）</a></li></ul></li><li><a href="#存储引擎" class="table-of-contents__link toc-highlight">存储引擎</a><ul><li><a href="#mysql-有哪些常见存储引擎" class="table-of-contents__link toc-highlight">🌟MySQL 有哪些常见存储引擎？</a></li><li><a href="#innodb-和-myisam-主要有什么区别" class="table-of-contents__link toc-highlight">InnoDB 和 MyISAM 主要有什么区别？</a></li><li><a href="#innodb的内存结构了解吗" class="table-of-contents__link toc-highlight">InnoDB的内存结构了解吗？</a></li><li><a href="#数据页的结构了解吗-ps自己暂时不看" class="table-of-contents__link toc-highlight">数据页的结构了解吗？ (ps:自己暂时不看)</a></li><li><a href="#innodb-的-buffer-pool了解吗补充" class="table-of-contents__link toc-highlight">InnoDB 的 Buffer Pool了解吗？（补充）</a></li></ul></li><li><a href="#日志" class="table-of-contents__link toc-highlight">日志</a><ul><li><a href="#mysql-日志文件有哪些" class="table-of-contents__link toc-highlight">🌟MySQL 日志文件有哪些？</a></li><li><a href="#请重点说说-binlog" class="table-of-contents__link toc-highlight">请重点说说 binlog？</a></li><li><a href="#有了binlog为什么还要undolog-redolog" class="table-of-contents__link toc-highlight">有了binlog为什么还要undolog redolog？</a></li><li><a href="#说说-redo-log-的工作机制" class="table-of-contents__link toc-highlight">说说 redo log 的工作机制？</a></li><li><a href="#binlog-和-redo-log-有什么区别" class="table-of-contents__link toc-highlight">binlog 和 redo log 有什么区别？</a></li><li><a href="#为什么要两阶段提交呢" class="table-of-contents__link toc-highlight">🌟为什么要两阶段提交呢？</a></li><li><a href="#redo-log-的写入过程了解吗" class="table-of-contents__link toc-highlight">🌟redo log 的写入过程了解吗？</a></li><li><a href="#什么是慢-sql" class="table-of-contents__link toc-highlight">🌟什么是慢 SQL？</a></li><li><a href="#sql-的执行过程了解吗" class="table-of-contents__link toc-highlight">SQL 的执行过程了解吗？</a></li><li><a href="#如何优化慢-sql-呢" class="table-of-contents__link toc-highlight">如何优化慢 SQL 呢？</a></li><li><a href="#你知道哪些方法来优化-sql" class="table-of-contents__link toc-highlight">🌟你知道哪些方法来优化 SQL？</a></li><li><a href="#如何利用覆盖索引" class="table-of-contents__link toc-highlight">如何利用覆盖索引？</a></li><li><a href="#如何正确使用联合索引" class="table-of-contents__link toc-highlight">如何正确使用联合索引？</a></li><li><a href="#如何进行分页优化" class="table-of-contents__link toc-highlight">如何进行分页优化？</a></li><li><a href="#为什么分页会变慢" class="table-of-contents__link toc-highlight">为什么分页会变慢？</a></li><li><a href="#join-代替子查询有什么好处" class="table-of-contents__link toc-highlight">JOIN 代替子查询有什么好处？</a></li><li><a href="#join操作为什么要小表驱动大表" class="table-of-contents__link toc-highlight">JOIN操作为什么要小表驱动大表？</a></li><li><a href="#为什么要避免使用-join-关联太多的表" class="table-of-contents__link toc-highlight">为什么要避免使用 JOIN 关联太多的表？</a></li><li><a href="#如何进行排序优化" class="table-of-contents__link toc-highlight">如何进行排序优化？</a></li><li><a href="#什么是-filesort" class="table-of-contents__link toc-highlight">什么是 filesort？</a></li><li><a href="#全字段排序和-rowid-排序了解多少" class="table-of-contents__link toc-highlight">全字段排序和 rowid 排序了解多少？</a></li><li><a href="#你对-sort_merge_passes-参数了解吗" class="table-of-contents__link toc-highlight">你对 Sort_merge_passes 参数了解吗？</a></li><li><a href="#条件下推你了解多少" class="table-of-contents__link toc-highlight">条件下推你了解多少？</a></li><li><a href="#为什么要尽量避免使用-select-" class="table-of-contents__link toc-highlight">为什么要尽量避免使用 select *？</a></li><li><a href="#你还知道哪些-sql-优化方法" class="table-of-contents__link toc-highlight">你还知道哪些 SQL 优化方法？</a></li><li><a href="#explain平常有用过吗" class="table-of-contents__link toc-highlight">🌟explain平常有用过吗？</a></li><li><a href="#type的执行效率等级达到什么级别比较合适" class="table-of-contents__link toc-highlight">type的执行效率等级，达到什么级别比较合适？</a></li></ul></li><li><a href="#索引" class="table-of-contents__link toc-highlight">索引</a><ul><li><a href="#索引为什么能提高mysql查询效率" class="table-of-contents__link toc-highlight">🌟索引为什么能提高MySQL查询效率？</a></li><li><a href="#能简单说一下索引的分类吗" class="table-of-contents__link toc-highlight">🌟能简单说一下索引的分类吗？</a></li><li><a href="#你对主键索引了解多少" class="table-of-contents__link toc-highlight">你对主键索引了解多少？</a></li><li><a href="#唯一索引和主键索引有什么区别" class="table-of-contents__link toc-highlight">唯一索引和主键索引有什么区别？</a></li><li><a href="#unique-key-和-unique-index-有什么区别" class="table-of-contents__link toc-highlight">unique key 和 unique index 有什么区别？</a></li><li><a href="#普通索引和唯一索引有什么区别" class="table-of-contents__link toc-highlight">普通索引和唯一索引有什么区别？</a></li><li><a href="#你对全文索引了解多少" class="table-of-contents__link toc-highlight">你对全文索引了解多少？</a></li><li><a href="#创建索引有哪些注意点" class="table-of-contents__link toc-highlight">🌟创建索引有哪些注意点？</a></li><li><a href="#索引哪些情况下会失效呢" class="table-of-contents__link toc-highlight">🌟索引哪些情况下会失效呢？</a></li><li><a href="#索引不适合哪些场景呢" class="table-of-contents__link toc-highlight">索引不适合哪些场景呢？</a></li><li><a href="#性别字段要建立索引吗" class="table-of-contents__link toc-highlight">性别字段要建立索引吗？</a></li><li><a href="#什么样的字段适合加索引" class="table-of-contents__link toc-highlight">什么样的字段适合加索引？</a></li><li><a href="#索引是不是建的越多越好" class="table-of-contents__link toc-highlight">索引是不是建的越多越好？</a></li><li><a href="#说说索引优化的思路" class="table-of-contents__link toc-highlight">说说索引优化的思路？</a></li><li><a href="#为什么-innodb-要使用-b树作为索引" class="table-of-contents__link toc-highlight">🌟为什么 InnoDB 要使用 B+树作为索引？</a></li><li><a href="#b树的叶子节点是单向链表还是双向链表如果从大值向小值检索如何操作" class="table-of-contents__link toc-highlight">B+树的叶子节点是单向链表还是双向链表？如果从大值向小值检索，如何操作？</a></li><li><a href="#一棵b树能存储多少条数据呢" class="table-of-contents__link toc-highlight">🌟一棵B+树能存储多少条数据呢？</a></li><li><a href="#现在有一张表-2kw-数据我这个-b树的高度有几层" class="table-of-contents__link toc-highlight">现在有一张表 2kw 数据，我这个 b+树的高度有几层？</a></li><li><a href="#每个叶子节点能存放多少条数据" class="table-of-contents__link toc-highlight">每个叶子节点能存放多少条数据？</a></li><li><a href="#索引为什么用-b树不用普通二叉树" class="table-of-contents__link toc-highlight">索引为什么用 B+树不用普通二叉树？</a></li><li><a href="#为什么不用平衡二叉树呢" class="table-of-contents__link toc-highlight">为什么不用平衡二叉树呢？</a></li><li><a href="#为什么用-b-树而不用-b-树呢" class="table-of-contents__link toc-highlight">🌟为什么用 B+ 树而不用 B 树呢？</a></li><li><a href="#b树的时间复杂度是多少" class="table-of-contents__link toc-highlight">B+树的时间复杂度是多少？</a></li><li><a href="#为什么用-b树不用跳表呢" class="table-of-contents__link toc-highlight">为什么用 B+树不用跳表呢？</a></li><li><a href="#b树的范围查找怎么做的" class="table-of-contents__link toc-highlight">B+树的范围查找怎么做的？</a></li><li><a href="#了解快排吗" class="table-of-contents__link toc-highlight">了解快排吗？</a></li><li><a href="#b树索引和-hash-索引有什么区别" class="table-of-contents__link toc-highlight">B+树索引和 Hash 索引有什么区别？</a></li><li><a href="#聚族索引和非聚族索引有什么区别" class="table-of-contents__link toc-highlight">🌟聚族索引和非聚族索引有什么区别？</a></li><li><a href="#回表了解吗" class="table-of-contents__link toc-highlight">🌟回表了解吗？</a></li><li><a href="#什么情况下会触发回表" class="table-of-contents__link toc-highlight">什么情况下会触发回表？</a></li><li><a href="#回表记录越多好吗" class="table-of-contents__link toc-highlight">回表记录越多好吗？</a></li><li><a href="#了解-mrr-吗" class="table-of-contents__link toc-highlight">了解 MRR 吗？</a></li><li><a href="#联合索引了解吗补充" class="table-of-contents__link toc-highlight">🌟联合索引了解吗？（补充）</a></li><li><a href="#联合索引底层的存储结构是怎样的" class="table-of-contents__link toc-highlight">联合索引底层的存储结构是怎样的？</a></li><li><a href="#联合索引的叶子节点存的什么内容" class="table-of-contents__link toc-highlight">联合索引的叶子节点存的什么内容?</a></li><li><a href="#覆盖索引了解吗" class="table-of-contents__link toc-highlight">🌟覆盖索引了解吗？</a></li><li><a href="#什么是最左前缀原则" class="table-of-contents__link toc-highlight">🌟什么是最左前缀原则？</a></li><li><a href="#范围查询后的列还能用索引吗" class="table-of-contents__link toc-highlight">范围查询后的列还能用索引吗？</a></li><li><a href="#为什么不从最左开始查就无法匹配呢" class="table-of-contents__link toc-highlight">为什么不从最左开始查，就无法匹配呢？</a></li><li><a href="#什么是索引下推" class="table-of-contents__link toc-highlight">🌟什么是索引下推？</a></li><li><a href="#如何查看是否用到了索引补充" class="table-of-contents__link toc-highlight">如何查看是否用到了索引？（补充）</a></li><li><a href="#mysql-中有哪几种锁" class="table-of-contents__link toc-highlight">🌟MySQL 中有哪几种锁？</a></li><li><a href="#全局锁了解吗补充" class="table-of-contents__link toc-highlight">全局锁了解吗？（补充）</a></li><li><a href="#表锁了解吗" class="table-of-contents__link toc-highlight">表锁了解吗？</a></li><li><a href="#说说-mysql-的行锁" class="table-of-contents__link toc-highlight">🌟说说 MySQL 的行锁？</a></li><li><a href="#select-for-update-有什么需要注意的" class="table-of-contents__link toc-highlight">select for update 有什么需要注意的？</a></li><li><a href="#说说记录锁吧" class="table-of-contents__link toc-highlight">说说记录锁吧？</a></li><li><a href="#间隙锁了解吗补充" class="table-of-contents__link toc-highlight">间隙锁了解吗？（补充）</a></li><li><a href="#执行什么命令会加上间隙锁" class="table-of-contents__link toc-highlight">执行什么命令会加上间隙锁？</a></li><li><a href="#临键锁了解吗" class="table-of-contents__link toc-highlight">临键锁了解吗？</a></li><li><a href="#意向锁是什么知道吗" class="table-of-contents__link toc-highlight">意向锁是什么知道吗？</a></li><li><a href="#意向锁的意义是什么" class="table-of-contents__link toc-highlight">意向锁的意义是什么？</a></li><li><a href="#mysql的乐观锁和悲观锁了解吗" class="table-of-contents__link toc-highlight">🌟MySQL的乐观锁和悲观锁了解吗？</a></li><li><a href="#如何通过悲观锁和乐观锁解决库存超卖问题" class="table-of-contents__link toc-highlight">如何通过悲观锁和乐观锁解决库存超卖问题？</a></li><li><a href="#遇到过mysql死锁问题吗你是如何解决的" class="table-of-contents__link toc-highlight">遇到过MySQL死锁问题吗，你是如何解决的？</a></li></ul></li><li><a href="#事务" class="table-of-contents__link toc-highlight">事务</a><ul><li><a href="#mysql事务的四大特性说一下" class="table-of-contents__link toc-highlight">🌟MySQL事务的四大特性说一下？</a></li><li><a href="#详细说一下隔离性" class="table-of-contents__link toc-highlight">详细说一下隔离性？</a></li><li><a href="#详细说一下持久性" class="table-of-contents__link toc-highlight">详细说一下持久性？</a></li><li><a href="#acid-靠什么保证的呢" class="table-of-contents__link toc-highlight">ACID 靠什么保证的呢？</a></li><li><a href="#详细说说如何保证隔离性" class="table-of-contents__link toc-highlight">详细说说如何保证隔离性？</a></li><li><a href="#如何保证一致性呢" class="table-of-contents__link toc-highlight">如何保证一致性呢？</a></li><li><a href="#事务会不会自动提交" class="table-of-contents__link toc-highlight">事务会不会自动提交？</a></li><li><a href="#事务的隔离级别有哪些" class="table-of-contents__link toc-highlight">🌟事务的隔离级别有哪些？</a></li><li><a href="#什么是串行化" class="table-of-contents__link toc-highlight">什么是串行化？</a></li><li><a href="#a-事务未提交b-事务上查询到的是旧值还是新值" class="table-of-contents__link toc-highlight">A 事务未提交，B 事务上查询到的是旧值还是新值？</a></li><li><a href="#怎么更改事务的隔离级别" class="table-of-contents__link toc-highlight">怎么更改事务的隔离级别？</a></li><li><a href="#事务的隔离级别是如何实现的" class="table-of-contents__link toc-highlight">事务的隔离级别是如何实现的？</a></li><li><a href="#请详细说说幻读呢" class="table-of-contents__link toc-highlight">🌟请详细说说幻读呢？</a></li><li><a href="#如何避免幻读" class="table-of-contents__link toc-highlight">如何避免幻读？</a></li><li><a href="#什么是当前读呢" class="table-of-contents__link toc-highlight">什么是当前读呢？</a></li><li><a href="#为什么-update-和-delete-也属于当前读" class="table-of-contents__link toc-highlight">为什么 UPDATE 和 DELETE 也属于当前读？</a></li><li><a href="#什么是快照读呢" class="table-of-contents__link toc-highlight">什么是快照读呢？</a></li><li><a href="#mvcc-了解吗" class="table-of-contents__link toc-highlight">🌟MVCC 了解吗？</a></li><li><a href="#请详细说说什么是版本链" class="table-of-contents__link toc-highlight">请详细说说什么是版本链？</a></li><li><a href="#请详细说说什么是readview" class="table-of-contents__link toc-highlight">请详细说说什么是ReadView？</a></li><li><a href="#可重复读和读已提交在-readview-上的区别是什么" class="table-of-contents__link toc-highlight">可重复读和读已提交在 ReadView 上的区别是什么？</a></li></ul></li><li><a href="#高可用" class="table-of-contents__link toc-highlight">高可用</a><ul><li><a href="#mysql数据库读写分离了解吗" class="table-of-contents__link toc-highlight">MySQL数据库读写分离了解吗？</a></li><li><a href="#读写分离的实现方式有哪些" class="table-of-contents__link toc-highlight">读写分离的实现方式有哪些？</a></li><li><a href="#主从复制原理了解吗" class="table-of-contents__link toc-highlight">主从复制原理了解吗？</a></li><li><a href="#主从同步延迟怎么处理" class="table-of-contents__link toc-highlight">主从同步延迟怎么处理？</a></li><li><a href="#请说说半同步复制的流程" class="table-of-contents__link toc-highlight">请说说半同步复制的流程？</a></li><li><a href="#你们一般是怎么分库的呢" class="table-of-contents__link toc-highlight">🌟你们一般是怎么分库的呢？</a></li><li><a href="#那你们是怎么分表的" class="table-of-contents__link toc-highlight">🌟那你们是怎么分表的？</a></li><li><a href="#水平分库分表的分片策略有哪几种" class="table-of-contents__link toc-highlight">水平分库分表的分片策略有哪几种？</a></li><li><a href="#不停机扩容怎么实现" class="table-of-contents__link toc-highlight">不停机扩容怎么实现？</a></li><li><a href="#常用的分库分表中间件有哪些" class="table-of-contents__link toc-highlight">常用的分库分表中间件有哪些？</a></li><li><a href="#你觉得分库分表会带来什么问题呢" class="table-of-contents__link toc-highlight">你觉得分库分表会带来什么问题呢？</a></li><li><a href="#你们项目中的分布式主键-id-是怎么生成的" class="table-of-contents__link toc-highlight">你们项目中的分布式主键 id 是怎么生成的？</a></li><li><a href="#雪花算法具体是怎么实现的" class="table-of-contents__link toc-highlight">雪花算法具体是怎么实现的？</a></li></ul></li><li><a href="#运维" class="table-of-contents__link toc-highlight">运维</a><ul><li><a href="#百万级别以上的数据如何删除" class="table-of-contents__link toc-highlight">百万级别以上的数据如何删除？</a></li><li><a href="#千万级大表如何添加字段" class="table-of-contents__link toc-highlight">千万级大表如何添加字段？</a></li><li><a href="#mysql-导致-cpu-飙升的话要怎么处理呢" class="table-of-contents__link toc-highlight">MySQL 导致 cpu 飙升的话，要怎么处理呢？</a></li></ul></li><li><a href="#sql题" class="table-of-contents__link toc-highlight">sql题</a><ul><li><a href="#新建一个表结构创建索引将百万或千万级的数据使用-insert-导入该表新建一个表结构将百万或千万级的数据使用-isnert-导入该表再创建索引这两种效率哪个高呢或者说用时短呢" class="table-of-contents__link toc-highlight">新建一个表结构，创建索引，将百万或千万级的数据使用 insert 导入该表，新建一个表结构，将百万或千万级的数据使用 isnert 导入该表，再创建索引，这两种效率哪个高呢？或者说用时短呢？</a></li><li><a href="#mysql是先建立索引好还是先插入数据好" class="table-of-contents__link toc-highlight">MySQL是先建立索引好还是先插入数据好？</a></li><li><a href="#什么是深分页select--from-tbn-limit-1000000000-这个有什么问题如果表大或者表小分别什么问题" class="table-of-contents__link toc-highlight">什么是深分页，select * from tbn limit 1000000000 这个有什么问题，如果表大或者表小分别什么问题</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/doc/docs/intro">Tutorial</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://x.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">X<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/doc/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>