<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-MQ/ROCKETMQ_REVIEW" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.8.1">
<title data-rh="true">ROCKETMQ_REVIEW | My Site</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://your-docusaurus-site.example.com/doc/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://your-docusaurus-site.example.com/doc/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://your-docusaurus-site.example.com/doc/docs/INTERVIEW/MQ"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="ROCKETMQ_REVIEW | My Site"><meta data-rh="true" name="description" content="ROCKETMQ_REVIEW"><meta data-rh="true" property="og:description" content="ROCKETMQ_REVIEW"><link data-rh="true" rel="icon" href="/doc/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://your-docusaurus-site.example.com/doc/docs/INTERVIEW/MQ"><link data-rh="true" rel="alternate" href="https://your-docusaurus-site.example.com/doc/docs/INTERVIEW/MQ" hreflang="en"><link data-rh="true" rel="alternate" href="https://your-docusaurus-site.example.com/doc/docs/INTERVIEW/MQ" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"ROCKETMQ_REVIEW","item":"https://your-docusaurus-site.example.com/doc/docs/INTERVIEW/MQ"}]}</script><link rel="alternate" type="application/rss+xml" href="/doc/blog/rss.xml" title="My Site RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/doc/blog/atom.xml" title="My Site Atom Feed"><link rel="stylesheet" href="/doc/assets/css/styles.8d5b4fe0.css">
<script src="/doc/assets/js/runtime~main.7888916f.js" defer="defer"></script>
<script src="/doc/assets/js/main.2ba6fd96.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t="light";var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",e||t),document.documentElement.setAttribute("data-theme-choice",e||t)}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/doc/img/logo.svg"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/doc/"><div class="navbar__logo"><img src="/doc/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/doc/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">My Site</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/doc/docs/intro">Tutorial</a><a class="navbar__item navbar__link" href="/doc/blog">Blog</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="Switch between dark and light mode (currently system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/doc/docs/intro">Tutorial Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/doc/docs/category/tutorial---basics">Tutorial - Basics</a><button aria-label="Expand sidebar category &#x27;Tutorial - Basics&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/doc/docs/category/tutorial---extras">Tutorial - Extras</a><button aria-label="Expand sidebar category &#x27;Tutorial - Extras&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/doc/docs/JAVA/">java</a><button aria-label="Expand sidebar category &#x27;java&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" href="/doc/docs/INTERVIEW/MQ">MQ</a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/doc/docs/INTERVIEW/MQ">ROCKETMQ_REVIEW</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/MYSQL/MYSQL-REVIEW">MYSQL</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/NGINX/NGINX-REVIEW">NGINX</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/intereview/redis">REDIS</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/SPRING/SPRING-REVIEW">SPRING</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/doc/docs/tmp">tmp</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/分布式/分布式-REVIEW">分布式</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/微服务/微服务-REVIEW">微服务</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/doc/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">MQ</span></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">ROCKETMQ_REVIEW</span></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>ROCKETMQ_REVIEW</h1></header><h2 class="anchor anchorWithStickyNavbar_LWe7" id="基础">基础<a href="#基础" class="hash-link" aria-label="Direct link to 基础" title="Direct link to 基础">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么要使用消息队列呢">为什么要使用消息队列呢？<a href="#为什么要使用消息队列呢" class="hash-link" aria-label="Direct link to 为什么要使用消息队列呢？" title="Direct link to 为什么要使用消息队列呢？">​</a></h3>
<p>消息队列（Message Queue, MQ）是一种非常重要的中间件技术，广泛应用于分布式系统中，以提高系统的可用性、解耦能力和异步通信效率。
①、解耦</p>
<p>生产者将消息放入队列，消费者从队列中取出消息，这样一来，生产者和消费者之间就不需要直接通信，生产者只管生产消息，消费者只管消费消息，这样就实现了解耦。
<img decoding="async" loading="lazy" alt="1756999602002" src="/doc/assets/images/1756999602002-a957ce75823270501009ec0df8370ad3.png" width="1080" height="427" class="img_ev3q">
像 PmHub 中的任务审批，就用了 RocketMQ 来做解耦。</p>
<p>②、异步：
系统可以将那些耗时的任务放在消息队列中异步处理，从而快速响应用户的请求。比如说，用户下单后，系统可以先返回一个下单成功的消息，然后将订单信息放入消息队列中，后台系统再去处理订单信息。
<img decoding="async" loading="lazy" alt="1756999642386" src="/doc/assets/images/1756999642386-a2a918fe5f370105a78bc18dd40a119e.png" width="1080" height="807" class="img_ev3q"></p>
<p>③、削峰：</p>
<p>削峰填谷是一种常见的技术手段，用于应对系统高并发请求的瞬时流量高峰，通过消息队列，可以将瞬时的高峰流量转化为持续的低流量，从而保护系统不会因为瞬时的高流量而崩溃。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何用rocketmq做削峰填谷的">如何用RocketMQ做削峰填谷的？<a href="#如何用rocketmq做削峰填谷的" class="hash-link" aria-label="Direct link to 如何用RocketMQ做削峰填谷的？" title="Direct link to 如何用RocketMQ做削峰填谷的？">​</a></h3>
<p>用户请求到达系统后，由生产者接收请求并将其转化为消息，发送到 RocketMQ 队列中。队列用来充当缓冲区，将大量请求按照顺序排队，这样就可以削减请求高峰时对后端服务的直接压力。</p>
<p>不仅如此，生产者通过异步方式发送消息，还可以快速响应用户请求。</p>
<p>消费者从 RocketMQ 队列中按照一定速率读取消息并进行处理。可以根据后端处理能力和当前负载情况动态调整消费者的消费速率，达到填谷的效果。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么要选择-rocketmq">为什么要选择 RocketMQ?<a href="#为什么要选择-rocketmq" class="hash-link" aria-label="Direct link to 为什么要选择 RocketMQ?" title="Direct link to 为什么要选择 RocketMQ?">​</a></h3>
<p><img decoding="async" loading="lazy" alt="1756999775920" src="/doc/assets/images/1756999775920-6f186a00513c30bf18afc446f4b23964.png" width="1080" height="2178" class="img_ev3q">
我们系统主要面向 C 端用户，有一定的并发量，对性能也有比较高的要求，所以选择了低延迟、吞吐量比较高，可用性比较好的 RocketMQ</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="rocketmq-有什么优缺点">RocketMQ 有什么优缺点？<a href="#rocketmq-有什么优缺点" class="hash-link" aria-label="Direct link to RocketMQ 有什么优缺点？" title="Direct link to RocketMQ 有什么优缺点？">​</a></h3>
<p>RocketMQ 优点：
单机吞吐量：十万级
可用性：非常高，分布式架构
消息可靠性：经过参数优化配置，消息可以做到 0 丢失
功能支持：MQ 功能较为完善，还是分布式的，扩展性好
支持 10 亿级别的消息堆积，不会因为堆积导致性能下降
源码是 Java，方便结合公司自己的业务二次开发
天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况
RoketMQ在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择RocketMQ</p>
<p>RocketMQ 缺点
支持的客户端语言不多，目前是 Java 及 c++，其中 c++不成熟
没有在 MQ 核心中去实现JMS等接口，有些系统要迁移需要修改大量代码</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说你对-rocketmq-的理解">说说你对 RocketMQ 的理解？<a href="#说说你对-rocketmq-的理解" class="hash-link" aria-label="Direct link to 说说你对 RocketMQ 的理解？" title="Direct link to 说说你对 RocketMQ 的理解？">​</a></h3>
<p><img decoding="async" loading="lazy" alt="1756999863317" src="/doc/assets/images/1756999863317-fa298d12e3a7b1e009a3d29758856632.png" width="958" height="601" class="img_ev3q">
RocketMQ 是阿里巴巴开源的一款分布式消息中间件，具有高吞吐量、低延迟和高可用性。其主要组件包括生产者、消费者、Broker、Topic 和队列。消息由生产者发送到 Broker，再根据路由规则存储到队列中，消费者从队列中拉取消息进行处理。适用于异步解耦和流量削峰等场景。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="消息队列有哪些消息模型">消息队列有哪些消息模型？<a href="#消息队列有哪些消息模型" class="hash-link" aria-label="Direct link to 消息队列有哪些消息模型？" title="Direct link to 消息队列有哪些消息模型？">​</a></h3>
<p>消息队列有两种模型：队列模型和发布/订阅模型。</p>
<p>队列模型
这是最初的一种消息队列模型，对应着消息队列“发-存-收”的模型。生产者往某个队列里面发送消息，一个队列可以存储多个生产者的消息，一个队列也可以有多个消费者，但是消费者之间是竞争关系，也就是说每条消息只能被一个消费者消费。
<img decoding="async" loading="lazy" alt="1756999896773" src="/doc/assets/images/1756999896773-20232619c2e5ca5e9eb095ee4e9a9be6.png" width="1080" height="312" class="img_ev3q"></p>
<p>发布/订阅模型
如果需要将一份消息数据分发给多个消费者，并且每个消费者都要求收到全量的消息。很显然，队列模型无法满足这个需求。解决的方式就是发布/订阅模型。</p>
<p>在发布 - 订阅模型中，消息的发送方称为发布者（Publisher），消息的接收方称为订阅者（Subscriber），服务端存放消息的容器称为主题（Topic）。发布者将消息发送到主题中，订阅者在接收消息之前需要先“订阅主题”。“订阅”在这里既是一个动作，同时还可以认为是主题在消费时的一个逻辑副本，每份订阅中，订阅者都可以接收到主题的所有消息。
<img decoding="async" loading="lazy" alt="1757338678086" src="/doc/assets/images/1757338678086-4792cc4af948350f50b206d2bf239755.png" width="1080" height="405" class="img_ev3q"></p>
<p>它和 “队列模式” 的异同：生产者就是发布者，队列就是主题，消费者就是订阅者，无本质区别。唯一的不同点在于：一份消息数据是否可以被多次消费。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="那-rocketmq-的消息模型呢">那 RocketMQ 的消息模型呢？<a href="#那-rocketmq-的消息模型呢" class="hash-link" aria-label="Direct link to 那 RocketMQ 的消息模型呢？" title="Direct link to 那 RocketMQ 的消息模型呢？">​</a></h3>
<p>RocketMQ 使用的消息模型是标准的发布-订阅模型，在 RocketMQ 的术语表中，生产者、消费者和主题，与发布-订阅模型中的概念是完全一样的。</p>
<p>RocketMQ 本身的消息是由下面几部分组成：
<img decoding="async" loading="lazy" alt="1757338748817" src="/doc/assets/images/1757338748817-3e8b700380d88377aecd538ae1e71e13.png" width="1080" height="426" class="img_ev3q"></p>
<ul>
<li>
<p>Message
Message（消息）就是要传输的信息。
一条消息必须有一个主题（Topic），主题可以看做是你的信件要邮寄的地址。
一条消息也可以拥有一个可选的标签（Tag）和额处的键值对，它们可以用于设置一个业务 Key 并在 Broker 上查找此消息以便在开发期间查找问题。</p>
</li>
<li>
<p>Topic
Topic（主题）可以看做消息的归类，它是消息的第一级类型。比如一个电商系统可以分为：交易消息、物流消息等，一条消息必须有一个 Topic 。
Topic 与生产者和消费者的关系非常松散，一个 Topic 可以有 0 个、1 个、多个生产者向其发送消息，一个生产者也可以同时向不同的 Topic 发送消息。
一个 Topic 也可以被 0 个、1 个、多个消费者订阅。</p>
</li>
<li>
<p>Tag
Tag（标签）可以看作子主题，它是消息的第二级类型，用于为用户提供额外的灵活性。使用标签，同一业务模块不同目的的消息就可以用相同 Topic 而不同的 Tag 来标识。比如交易消息又可以分为：交易创建消息、交易完成消息等，一条消息可以没有 Tag 。</p>
</li>
</ul>
<p>标签有助于保持你的代码干净和连贯，并且还可以为 RocketMQ 提供的查询系统提供帮助。</p>
<ul>
<li>Group
RocketMQ 中，订阅者的概念是通过消费组（Consumer Group）来体现的。每个消费组都消费主题中一份完整的消息，不同消费组之间消费进度彼此不受影响，也就是说，一条消息被 Consumer Group1 消费过，也会再给 Consumer Group2 消费。</li>
</ul>
<p>消费组中包含多个消费者，同一个组内的消费者是竞争消费的关系，每个消费者负责消费组内的一部分消息。默认情况，如果一条消息被消费者 Consumer1 消费了，那同组的其他消费者就不会再收到这条消息。</p>
<ul>
<li>Message Queue
Message Queue（消息队列），一个 Topic 下可以设置多个消息队列，Topic 包括多个 Message Queue ，如果一个 Consumer 需要获取 Topic 下所有的消息，就要遍历所有的 Message Queue。</li>
</ul>
<p>RocketMQ 还有一些其它的 Queue——例如 ConsumerQueue。</p>
<ul>
<li>Offset
在 Topic 的消费过程中，由于消息需要被不同的组进行多次消费，所以消费完的消息并不会立即被删除，这就需要 RocketMQ 为每个消费组在每个队列上维护一个消费位置（Consumer Offset），这个位置之前的消息都被消费过，之后的消息都没有被消费过，每成功消费一条消息，消费位置就加一。</li>
</ul>
<p>也可以这么说，Queue 是一个长度无限的数组，Offset 就是下标。</p>
<p>RocketMQ 的消息模型中，这些就是比较关键的概念了。画张图总结一下：
<img decoding="async" loading="lazy" alt="1757339102124" src="/doc/assets/images/1757339102124-7d3e022bec83fd419006cecd3aa6910a.png" width="1080" height="623" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="消息的消费模式了解吗">消息的消费模式了解吗？<a href="#消息的消费模式了解吗" class="hash-link" aria-label="Direct link to 消息的消费模式了解吗？" title="Direct link to 消息的消费模式了解吗？">​</a></h3>
<p>消息消费模式有两种：Clustering（集群消费）和Broadcasting（广播消费）。
<img decoding="async" loading="lazy" alt="1757339153566" src="/doc/assets/images/1757339153566-7db681d585cff18a2605872cd09d343c.png" width="616" height="427" class="img_ev3q">
默认情况下就是集群消费，这种模式下一个消费者组共同消费一个主题的多个队列，一个队列只会被一个消费者消费，如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。</p>
<p>而广播消费消息会发给消费者组中的每一个消费者进行消费。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="roctetmq-基本架构了解吗">RoctetMQ 基本架构了解吗？<a href="#roctetmq-基本架构了解吗" class="hash-link" aria-label="Direct link to RoctetMQ 基本架构了解吗？" title="Direct link to RoctetMQ 基本架构了解吗？">​</a></h3>
<p>先看图，RocketMQ 的基本架构：
<img decoding="async" loading="lazy" alt="1757339185478" src="/doc/assets/images/1757339185478-a067e0697255ada74ba9459ba0861109.png" width="1080" height="766" class="img_ev3q">
RocketMQ 一共有四个部分组成：NameServer，Broker，Producer 生产者，Consumer 消费者，它们对应了：发现、发、存、收，为了保证高可用，一般每一部分都是集群部署的。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="那能介绍一下这四部分吗">那能介绍一下这四部分吗？<a href="#那能介绍一下这四部分吗" class="hash-link" aria-label="Direct link to 那能介绍一下这四部分吗？" title="Direct link to 那能介绍一下这四部分吗？">​</a></h3>
<p>类比一下我们生活的邮政系统——</p>
<p>邮政系统要正常运行，离不开下面这四个角色， 一是发信者，二 是收信者， 三是负责暂存传输的邮局， 四是负责协调各个地方邮局的管理机构。对应到 RocketMQ 中，这四个角色就是 Producer、 Consumer、 Broker 、NameServer。
<img decoding="async" loading="lazy" alt="1757339248389" src="/doc/assets/images/1757339248389-845c8a95c8a38f2c4e2e662bfd6bc45a.png" width="641" height="326" class="img_ev3q"></p>
<p>NameServer
NameServer 是一个无状态的服务器，角色类似于 Kafka 使用的 Zookeeper，但比 Zookeeper 更轻量。</p>
<p>特点：</p>
<p>每个 NameServer 结点之间是相互独立，彼此没有任何信息交互。
Nameserver 被设计成几乎是无状态的，通过部署多个结点来标识自己是一个伪集群，Producer 在发送消息前从 NameServer 中获取 Topic 的路由信息也就是发往哪个 Broker，Consumer 也会定时从 NameServer 获取 Topic 的路由信息，Broker 在启动时会向 NameServer 注册，并定时进行心跳连接，且定时同步维护的 Topic 到 NameServer。
功能主要有两个：</p>
<p>1、和 Broker 结点保持长连接。
2、维护 Topic 的路由信息。
Broker
消息存储和中转角色，负责存储和转发消息。</p>
<p>Broker 内部维护着一个个 Consumer Queue，用来存储消息的索引，真正存储消息的地方是 CommitLog（日志文件）。
<img decoding="async" loading="lazy" alt="1757339327331" src="/doc/assets/images/1757339327331-ed866597fd58ffae16ec597a6a3dd77d.png" width="1080" height="847" class="img_ev3q"></p>
<p>单个 Broker 与所有的 Nameserver 保持着长连接和心跳，并会定时将 Topic 信息同步到 NameServer，和 NameServer 的通信底层是通过 Netty 实现的。
Producer</p>
<p>消息生产者，业务端负责发送消息，由用户自行实现和分布式部署。</p>
<p>Producer由用户进行分布式部署，消息由Producer通过多种负载均衡模式发送到Broker集群，发送低延时，支持快速失败。</p>
<p>RocketMQ 提供了三种方式发送消息：同步、异步和单向</p>
<p>同步发送：同步发送指消息发送方发出数据后会在收到接收方发回响应之后才发下一个数据包。一般用于重要通知消息，例如重要通知邮件、营销短信。</p>
<p>异步发送：异步发送指发送方发出数据后，不等接收方发回响应，接着发送下个数据包，一般用于可能链路耗时较长而对响应时间敏感的业务场景，例如用户视频上传后通知启动转码服务。</p>
<p>单向发送：单向发送是指只负责发送消息而不等待服务器回应且没有回调函数触发，适用于某些耗时非常短但对可靠性要求并不高的场景，例如日志收集。</p>
<p>Consumer
消息消费者，负责消费消息，一般是后台系统负责异步消费。</p>
<p>Consumer也由用户部署，支持 PUSH 和 PULL 两种消费模式，支持集群消费和广播消费，提供实时的消息订阅机制。
Pull：拉取型消费者（Pull Consumer）主动从消息服务器拉取信息，只要批量拉取到消息，用户应用就会启动消费过程，所以 Pull 称为主动消费型。
Push：推送型消费者（Push Consumer）封装了消息的拉取、消费进度和其他的内部维护工作，将消息到达时执行的回调接口留给用户应用程序来实现。所以 Push 称为被动消费类型，但其实从实现上看还是从消息服务器中拉取消息，不同于 Pull 的是 Push 首先要注册消费监听器，当监听器处触发后才开始消费消息。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="进阶">进阶<a href="#进阶" class="hash-link" aria-label="Direct link to 进阶" title="Direct link to 进阶">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何保证消息的可用性可靠性不丢失呢">如何保证消息的可用性/可靠性/不丢失呢？<a href="#如何保证消息的可用性可靠性不丢失呢" class="hash-link" aria-label="Direct link to 如何保证消息的可用性/可靠性/不丢失呢？" title="Direct link to 如何保证消息的可用性/可靠性/不丢失呢？">​</a></h3>
<p>消息可能在哪些阶段丢失呢？可能会在这三个阶段发生丢失：生产阶段、存储阶段、消费阶段。</p>
<p>所以要从这三个阶段考虑：
<img decoding="async" loading="lazy" alt="1757339373869" src="/doc/assets/images/1757339373869-1726e02fd7e07e716c1b1f390d867914.png" width="785" height="276" class="img_ev3q">
生产
在生产阶段，主要通过请求确认机制，来保证消息的可靠传递。</p>
<p>1、同步发送的时候，要注意处理响应结果和异常。如果返回响应 OK，表示消息成功发送到了 Broker，如果响应失败，或者发生其它异常，都应该重试。
2、异步发送的时候，应该在回调方法里检查，如果发送失败或者异常，都应该进行重试。
3、如果发生超时的情况，也可以通过查询日志的 API，来检查是否在 Broker 存储成功。
存储
存储阶段，可以通过配置可靠性优先的 Broker 参数来避免因为宕机丢消息，简单说就是可靠性优先的场景都应该使用同步。</p>
<p>1、消息只要持久化到 CommitLog（日志文件）中，即使 Broker 宕机，未消费的消息也能重新恢复再消费。
2、Broker 的刷盘机制：同步刷盘和异步刷盘，不管哪种刷盘都可以保证消息一定存储在 pagecache 中（内存中），但是同步刷盘更可靠，它是 Producer 发送消息后等数据持久化到磁盘之后再返回响应给 Producer。
<img decoding="async" loading="lazy" alt="1757340350484" src="/doc/assets/images/1757340350484-198f30a34341f89f4978586ac347d58a.png" width="1080" height="981" class="img_ev3q">
3、Broker 通过主从模式来保证高可用，Broker 支持 Master 和 Slave 同步复制、Master 和 Slave 异步复制模式，生产者的消息都是发送给 Master，但是消费既可以从 Master 消费，也可以从 Slave 消费。同步复制模式可以保证即使 Master 宕机，消息肯定在 Slave 中有备份，保证了消息不会丢失。
消费</p>
<p>从 Consumer 角度分析，如何保证消息被成功消费？</p>
<p>Consumer 保证消息成功消费的关键在于确认的时机，不要在收到消息后就立即发送消费确认，而是应该在执行完所有消费业务逻辑之后，再发送消费确认。因为消息队列维护了消费的位置，逻辑执行失败了，没有确认，再去队列拉取消息，就还是之前的一条。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何处理消息重复的问题呢">如何处理消息重复的问题呢？<a href="#如何处理消息重复的问题呢" class="hash-link" aria-label="Direct link to 如何处理消息重复的问题呢？" title="Direct link to 如何处理消息重复的问题呢？">​</a></h3>
<p>RocketMQ 可以保证消息一定投递，且不丢失，但无法保证消息不重复消费。</p>
<p>因此，需要在业务端做好消息的幂等性处理，或者做消息去重。
<img decoding="async" loading="lazy" alt="1757340391962" src="/doc/assets/images/1757340391962-a778ac6362bb424c655d58846d4a1681.png" width="502" height="232" class="img_ev3q">
幂等性是指一个操作可以执行多次而不会产生副作用，即无论执行多少次，结果都是相同的。可以在业务逻辑中加入检查逻辑，确保同一消息多次消费不会产生副作用。</p>
<p>例如，在支付场景下，消费者消费扣款的消息，对一笔订单执行扣款操作，金额为100元。</p>
<p>如果因网络不稳定等原因导致扣款消息重复投递，消费者重复消费了该扣款消息，但最终的业务结果要保证只扣款一次，金额为100元。如果扣款操作是符合要求的，那么就可以认为整个消费过程实现了消息幂等。</p>
<p>消息去重，是指在消费者消费消息之前，先检查一下是否已经消费过这条消息，如果消费过了，就不再消费。</p>
<p>业务端可以通过一个专门的表来记录已经消费过的消息 ID，每次消费消息之前，先查询一下这个表，如果已经存在，就不再消费。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public void processMessage(String messageId, String message) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!isMessageProcessed(messageId)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 处理消息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        markMessageAsProcessed(messageId);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private boolean isMessageProcessed(String messageId) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 查询去重表，检查消息ID是否存在</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private void markMessageAsProcessed(String messageId) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 将消息ID插入去重表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何保证消息的幂等性">如何保证消息的幂等性？<a href="#如何保证消息的幂等性" class="hash-link" aria-label="Direct link to 如何保证消息的幂等性？" title="Direct link to 如何保证消息的幂等性？">​</a></h3>
<p><img decoding="async" loading="lazy" alt="1757340423906" src="/doc/assets/images/1757340423906-31ec18decd5e80b06d256f7dfcbe18da.png" width="738" height="466" class="img_ev3q"></p>
<p>首先，消息必须携带业务唯一标识，可以通过雪花算法生成全局唯一 ID。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Message msg = new Message(TOPIC /* Topic */,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             TAG /* Tag */,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               (&quot;Hello RocketMQ &quot; + i).getBytes(RemotingHelper.DEFAULT_CHARSET) /* Message body */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">message.setKey(&quot;ORDERID_100&quot;); // 订单编号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SendResult sendResult = producer.send(message);</span><br></span></code></pre></div></div>
<p>其次，在消费者接收到消息后，判断 Redis 中是否存在该业务主键的标志位，若存在标志位，则认为消费成功，否则执行业务逻辑，执行完成后，在缓存中添加标志位。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (MessageExt messageExt : msgs) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           String bizKey = messageExt.getKeys(); // 唯一业务主键</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           //1. 判断是否存在标志</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           if(redisTemplate.hasKey(RedisKeyConstants.WAITING_SEND_LOCK + bizKey)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         			continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       		 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         	 //2. 执行业务逻辑</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           //TODO do business</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           //3. 设置标志位</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           redisTemplate.opsForValue().set(RedisKeyConstants.WAITING_SEND_LOCK + bizKey, &quot;1&quot;, 72, TimeUnit.HOURS);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        logger.error(&quot;consumeMessage error: &quot;, e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ConsumeConcurrentlyStatus.RECONSUME_LATER;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>然后，利用数据库的唯一索引来防止业务的重复插入。</p>
<div class="language-sql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-sql codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">CREATE</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">TABLE</span><span class="token plain"> </span><span class="token identifier punctuation" style="color:#393A34">`</span><span class="token identifier">t_order</span><span class="token identifier punctuation" style="color:#393A34">`</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token identifier punctuation" style="color:#393A34">`</span><span class="token identifier">id</span><span class="token identifier punctuation" style="color:#393A34">`</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">bigint</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">20</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">NOT</span><span class="token plain"> </span><span class="token boolean" style="color:#36acaa">NULL</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">AUTO_INCREMENT</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token identifier punctuation" style="color:#393A34">`</span><span class="token identifier">order_id</span><span class="token identifier punctuation" style="color:#393A34">`</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">varchar</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">64</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">NOT</span><span class="token plain"> </span><span class="token boolean" style="color:#36acaa">NULL</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">COMMENT</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;订单编号&#x27;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token identifier punctuation" style="color:#393A34">`</span><span class="token identifier">order_name</span><span class="token identifier punctuation" style="color:#393A34">`</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">varchar</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">64</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">NOT</span><span class="token plain"> </span><span class="token boolean" style="color:#36acaa">NULL</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">COMMENT</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;订单名称&#x27;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">PRIMARY</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">KEY</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token identifier punctuation" style="color:#393A34">`</span><span class="token identifier">id</span><span class="token identifier punctuation" style="color:#393A34">`</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">UNIQUE</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">KEY</span><span class="token plain"> </span><span class="token identifier punctuation" style="color:#393A34">`</span><span class="token identifier">order_id</span><span class="token identifier punctuation" style="color:#393A34">`</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token identifier punctuation" style="color:#393A34">`</span><span class="token identifier">order_id</span><span class="token identifier punctuation" style="color:#393A34">`</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">ENGINE</span><span class="token operator" style="color:#393A34">=</span><span class="token keyword" style="color:#00009f">InnoDB</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">DEFAULT</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">CHARSET</span><span class="token operator" style="color:#393A34">=</span><span class="token plain">utf8mb4 </span><span class="token keyword" style="color:#00009f">COMMENT</span><span class="token operator" style="color:#393A34">=</span><span class="token string" style="color:#e3116c">&#x27;订单表&#x27;</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre></div></div>
<p>最后，在数据库表中使用版本号，通过乐观锁机制来保证幂等性。每次更新操作时检查版本号是否一致，只有一致时才执行更新并递增版本号。如果版本号不一致，则说明操作已被执行过，拒绝重复操作。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public void updateRecordWithOptimisticLock(int id, String newValue, int expectedVersion) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int updatedRows = jdbcTemplate.update(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;UPDATE records SET value = ?, version = version + 1 WHERE id = ? AND version = ?&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        newValue, id, expectedVersion</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (updatedRows == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new OptimisticLockingFailureException(&quot;Record has been modified by another transaction&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>或者悲观锁机制，通过数据库的锁机制来保证幂等性。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public void updateRecordWithPessimisticLock(int id) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    jdbcTemplate.queryForObject(&quot;SELECT * FROM records WHERE id = ? FOR UPDATE&quot;, id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    jdbcTemplate.update(&quot;UPDATE records SET value = ? WHERE id = ?&quot;, &quot;newValue&quot;, id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="雪花算法了解吗">雪花算法了解吗？<a href="#雪花算法了解吗" class="hash-link" aria-label="Direct link to 雪花算法了解吗？" title="Direct link to 雪花算法了解吗？">​</a></h3>
<p>雪花算法是由 Twitter 开发的一种分布式唯一 ID 生成算法。</p>
<p>雪花算法以 64 bit 来存储组成 ID 的4 个部分：</p>
<p>最高位占1 bit，始终为 0，表示正数。
中位占 41 bit，值为毫秒级时间戳；
中下位占 10 bit，机器 ID（包括数据中心 ID 和机器 ID），可以支持 1024 个节点。
末位占 12 bit，值为当前毫秒内生成的不同的自增序列，值的上限为 4096；</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="怎么处理消息积压">怎么处理消息积压？<a href="#怎么处理消息积压" class="hash-link" aria-label="Direct link to 怎么处理消息积压？" title="Direct link to 怎么处理消息积压？">​</a></h3>
<p>发生了消息积压，这时候就得想办法赶紧把积压的消息消费完，就得考虑提高消费能力，一般有两种办法：
<img decoding="async" loading="lazy" alt="1757341790928" src="/doc/assets/images/1757341790928-850aecad88a2131647ab565189482eae.png" width="1080" height="419" class="img_ev3q">
消费者扩容：如果当前 Topic 的 Message Queue 的数量大于消费者数量，就可以对消费者进行扩容，增加消费者，来提高消费能力，尽快把积压的消息消费玩。
消息迁移 Queue 扩容：如果当前 Topic 的 Message Queue 的数量小于或者等于消费者数量，这种情况，再扩容消费者就没什么用，就得考虑扩容 Message Queue。可以新建一个临时的 Topic，临时的 Topic 多设置一些 Message Queue，然后先用一些消费者把消费的数据丢到临时的 Topic，因为不用业务处理，只是转发一下消息，还是很快的。接下来用扩容的消费者去消费新的 Topic 里的数据，消费完了之后，恢复原状。
<img decoding="async" loading="lazy" alt="1757341808996" src="/doc/assets/images/1757341808996-627d7f3468c2adcbe9bccd6180397e81.png" width="1080" height="957" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="顺序消息如何实现">顺序消息如何实现？<a href="#顺序消息如何实现" class="hash-link" aria-label="Direct link to 顺序消息如何实现？" title="Direct link to 顺序消息如何实现？">​</a></h3>
<p>RocketMQ 实现顺序消息的关键在于保证消息生产和消费过程中严格的顺序控制，即确保同一业务的消息按顺序发送到同一个队列中，并由同一个消费者线程按顺序消费。
局部顺序消息如何实现？
局部顺序消息保证在某个逻辑分区或业务逻辑下的消息顺序，例如同一个订单或用户的消息按顺序消费，而不同订单或用户之间的顺序不做保证。
<img decoding="async" loading="lazy" alt="1757341849660" src="/doc/assets/images/1757341849660-0a1f4d4f8f89d59c1da8c65f19a5f4f4.png" width="1080" height="829" class="img_ev3q"></p>
<p>全局顺序消息如何实现？
全局顺序消息保证消息在整个系统范围内的严格顺序，即消息按照生产的顺序被消费。</p>
<p>可以将所有消息发送到一个单独的队列中，确保所有消息按生产顺序发送和消费。
<img decoding="async" loading="lazy" alt="1757341865433" src="/doc/assets/images/1757341865433-bc01b0d50e9f45c0dbcab1deef5d59cb.png" width="1080" height="434" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何实现消息过滤">如何实现消息过滤？<a href="#如何实现消息过滤" class="hash-link" aria-label="Direct link to 如何实现消息过滤？" title="Direct link to 如何实现消息过滤？">​</a></h3>
<p>有两种方案：</p>
<p>一种是在 Broker 端按照 Consumer 的去重逻辑进行过滤，这样做的好处是避免了无用的消息传输到 Consumer 端，缺点是加重了 Broker 的负担，实现起来相对复杂。
另一种是在 Consumer 端过滤，比如按照消息设置的 tag 去重，这样的好处是实现起来简单，缺点是有大量无用的消息到达了 Consumer 端只能丢弃不处理。
一般采用 Cosumer 端过滤，如果希望提高吞吐量，可以采用 Broker 过滤。</p>
<p>对消息的过滤有三种方式：
<img decoding="async" loading="lazy" alt="1757341901152" src="/doc/assets/images/1757341901152-90157975a7ec4935be8d4c1484435829.png" width="1064" height="352" class="img_ev3q">
根据 Tag 过滤：这是最常见的一种，用起来高效简单</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">DefaultMQPushConsumerconsumer=newDefaultMQPushConsumer(&quot;CID_EXAMPLE&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">consumer.subscribe(&quot;TOPIC&quot;,&quot;TAGA||TAGB||TAGC&quot;);</span><br></span></code></pre></div></div>
<p>SQL 表达式过滤：SQL 表达式过滤更加灵活</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">DefaultMQPushConsumerconsumer=newDefaultMQPushConsumer(&quot;please_rename_unique_group_name_4&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//只有订阅的消息有这个属性a,a&gt;=0anda&lt;=3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">consumer.subscribe(&quot;TopicTest&quot;,MessageSelector.bySql(&quot;abetween0and3&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">consumer.registerMessageListener(newMessageListenerConcurrently(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">publicConsumeConcurrentlyStatusconsumeMessage(List&lt;MessageExt&gt;msgs,ConsumeConcurrentlyContextcontext){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">returnConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">consumer.start();</span><br></span></code></pre></div></div>
<p>Filter Server 方式：最灵活，也是最复杂的一种方式，允许用户自定义函数进行过滤</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="延时消息了解吗">延时消息了解吗？<a href="#延时消息了解吗" class="hash-link" aria-label="Direct link to 延时消息了解吗？" title="Direct link to 延时消息了解吗？">​</a></h3>
<p>电商的订单超时自动取消，就是一个典型的利用延时消息的例子，用户提交了一个订单，就可以发送一个延时消息，1h 后去检查这个订单的状态，如果还是未付款就取消订单释放库存。</p>
<p>RocketMQ 是支持延时消息的，只需要在生产消息的时候设置消息的延时级别：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//实例化一个生产者来产生延时消息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">DefaultMQProducerproducer=newDefaultMQProducer(&quot;ExampleProducerGroup&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//启动生产者</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">producer.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">inttotalMessagesToSend=100;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for(inti=0;i&lt;totalMessagesToSend;i++){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Messagemessage=newMessage(&quot;TestTopic&quot;,(&quot;Helloscheduledmessage&quot;+i).getBytes());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //设置延时等级3,这个消息将在10s之后发送(现在只支持固定的几个时间,详看delayTimeLevel)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    message.setDelayTimeLevel(3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //发送消息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    producer.send(message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>private String messageDelayLevel = &quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&quot;;</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="rocketmq-怎么实现延时消息的">RocketMQ 怎么实现延时消息的？<a href="#rocketmq-怎么实现延时消息的" class="hash-link" aria-label="Direct link to RocketMQ 怎么实现延时消息的？" title="Direct link to RocketMQ 怎么实现延时消息的？">​</a></h3>
<p>简单，八个字：临时存储+定时任务。
Broker 收到延时消息了，会先发送到主题（SCHEDULE_TOPIC_XXXX）的相应时间段的 Message Queue 中，然后通过一个定时任务轮询这些队列，到期后，把消息投递到目标 Topic 的队列中，然后消费者就可以正常消费这些消息。
<img decoding="async" loading="lazy" alt="1757342008664" src="/doc/assets/images/1757342008664-b760a0cc021fe7db5dc16de0912e44df.png" width="1080" height="740" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="怎么实现分布式消息事务的半消息">怎么实现分布式消息事务的？半消息？<a href="#怎么实现分布式消息事务的半消息" class="hash-link" aria-label="Direct link to 怎么实现分布式消息事务的？半消息？" title="Direct link to 怎么实现分布式消息事务的？半消息？">​</a></h3>
<p>半消息：是指暂时还不能被 Consumer 消费的消息，Producer 成功发送到 Broker 端的消息，但是此消息被标记为 “暂不可投递” 状态，只有等 Producer 端执行完本地事务后经过二次确认了之后，Consumer 才能消费此条消息。</p>
<p>依赖半消息，可以实现分布式消息事务，其中的关键在于二次确认以及消息回查：
<img decoding="async" loading="lazy" alt="1757342026311" src="/doc/assets/images/1757342026311-f9f5e50257a4224b8aa338b7f1251114.png" width="1080" height="402" class="img_ev3q"></p>
<p>1、Producer 向 broker 发送半消息
2、Producer 端收到响应，消息发送成功，此时消息是半消息，标记为 “不可投递” 状态，Consumer 消费不了。
3、Producer 端执行本地事务。
4、正常情况本地事务执行完成，Producer 向 Broker 发送 Commit/Rollback，如果是 Commit，Broker 端将半消息标记为正常消息，Consumer 可以消费，如果是 Rollback，Broker 丢弃此消息。
5、异常情况，Broker 端迟迟等不到二次确认。在一定时间后，会查询所有的半消息，然后到 Producer 端查询半消息的执行情况。
6、Producer 端查询本地事务的状态
7、根据事务的状态提交 commit/rollback 到 broker 端。（5，6，7 是消息回查）
8、消费者段消费到消息之后，执行本地事务。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="死信队列知道吗">死信队列知道吗？<a href="#死信队列知道吗" class="hash-link" aria-label="Direct link to 死信队列知道吗？" title="Direct link to 死信队列知道吗？">​</a></h3>
<p>死信队列用于存储那些无法被正常处理的消息，这些消息被称为死信（Dead Letter）。
<img decoding="async" loading="lazy" alt="1757342057150" src="/doc/assets/images/1757342057150-c827364ba7533c7906a2c46cd8371420.png" width="656" height="790" class="img_ev3q">
产生死信的原因是，消费者在处理消息时发生异常，且达到了最大重试次数。当消费失败的原因排查并解决后，可以重发这些死信消息，让消费者重新消费；如果暂时无法处理，为避免到期后死信消息被删除，可以先将死信消息导出并进行保存。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何保证-rocketmq-的高可用">如何保证 RocketMQ 的高可用？<a href="#如何保证-rocketmq-的高可用" class="hash-link" aria-label="Direct link to 如何保证 RocketMQ 的高可用？" title="Direct link to 如何保证 RocketMQ 的高可用？">​</a></h3>
<p>NameServer 因为是无状态，且不相互通信的，所以只要集群部署就可以保证高可用。
<img decoding="async" loading="lazy" alt="1757342087980" src="/doc/assets/images/1757342087980-2134e95aa3d296f809c80216ba2a821f.png" width="530" height="350" class="img_ev3q">
RocketMQ 的高可用主要是在体现在 Broker 的读和写的高可用，Broker 的高可用是通过集群和主从实现的。
<img decoding="async" loading="lazy" alt="1757342099262" src="/doc/assets/images/1757342099262-402d753a8c8a238472039719d49b1166.png" width="886" height="812" class="img_ev3q">
Broker 可以配置两种角色：Master 和 Slave，Master 角色的 Broker 支持读和写，Slave 角色的 Broker 只支持读，Master 会向 Slave 同步消息。</p>
<p>也就是说 Producer 只能向 Master 角色的 Broker 写入消息，Cosumer 可以从 Master 和 Slave 角色的 Broker 读取消息。</p>
<p>Consumer 的配置文件中，并不需要设置是从 Master 读还是从 Slave 读，当 Master 不可用或者繁忙的时候， Consumer 的读请求会被自动切换到从 Slave。有了自动切换 Consumer 这种机制，当一个 Master 角色的机器出现故障后，Consumer 仍然可以从 Slave 读取消息，不影响 Consumer 读取消息，这就实现了读的高可用。</p>
<p>如何达到发送端写的高可用性呢？在创建 Topic 的时候，把 Topic 的多个 Message Queue 创建在多个 Broker 组上（相同 Broker 名称，不同 brokerId 机器组成 Broker 组），这样当 Broker 组的 Master 不可用后，其他组 Master 仍然可用， Producer 仍然可以发送消息 RocketMQ 目前还不支持把 Slave 自动转成 Master ，如果机器资源不足，需要把 Slave 转成 Master ，则要手动停止 Slave 色的 Broker ，更改配置文件，用新的配置文件启动 Broker。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="原理">原理<a href="#原理" class="hash-link" aria-label="Direct link to 原理" title="Direct link to 原理">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说一下-rocketmq-的整体工作流程">说一下 RocketMQ 的整体工作流程？<a href="#说一下-rocketmq-的整体工作流程" class="hash-link" aria-label="Direct link to 说一下 RocketMQ 的整体工作流程？" title="Direct link to 说一下 RocketMQ 的整体工作流程？">​</a></h3>
<p>简单来说，RocketMQ 是一个分布式消息队列，也就是消息队列+分布式系统。</p>
<p>作为消息队列，它是发-存-收的一个模型，对应的就是 Producer、Broker、Cosumer；作为分布式系统，它要有服务端、客户端、注册中心，对应的就是 Broker、Producer/Consumer、NameServer</p>
<p>所以我们看一下它主要的工作流程：RocketMQ 由 NameServer 注册中心集群、Producer 生产者集群、Consumer 消费者集群和若干 Broker（RocketMQ 进程）组成：</p>
<p>Broker 在启动的时候去向所有的 NameServer 注册，并保持长连接，每 30s 发送一次心跳
Producer 在发送消息的时候从 NameServer 获取 Broker 服务器地址，根据负载均衡算法选择一台服务器来发送消息
Conusmer 消费消息的时候同样从 NameServer 获取 Broker 地址，然后主动拉取消息来消费</p>
<p><img decoding="async" loading="lazy" alt="1757342132427" src="/doc/assets/images/1757342132427-b529b500a7d4c6ed6eae526ac177e766.png" width="1080" height="522" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么-rocketmq-不使用-zookeeper-作为注册中心呢">为什么 RocketMQ 不使用 Zookeeper 作为注册中心呢？<a href="#为什么-rocketmq-不使用-zookeeper-作为注册中心呢" class="hash-link" aria-label="Direct link to 为什么 RocketMQ 不使用 Zookeeper 作为注册中心呢？" title="Direct link to 为什么 RocketMQ 不使用 Zookeeper 作为注册中心呢？">​</a></h3>
<p>Kafka 我们都知道采用 Zookeeper 作为注册中心——当然也开始逐渐去 Zookeeper，RocketMQ 不使用 Zookeeper 其实主要可能从这几方面来考虑：</p>
<p>基于可用性的考虑，根据 CAP 理论，同时最多只能满足两个点，而 Zookeeper 满足的是 CP，也就是说 Zookeeper 并不能保证服务的可用性，Zookeeper 在进行选举的时候，整个选举的时间太长，期间整个集群都处于不可用的状态，而这对于一个注册中心来说肯定是不能接受的，作为服务发现来说就应该是为可用性而设计。
基于性能的考虑，NameServer 本身的实现非常轻量，而且可以通过增加机器的方式水平扩展，增加集群的抗压能力，而 Zookeeper 的写是不可扩展的，Zookeeper 要解决这个问题只能通过划分领域，划分多个 Zookeeper 集群来解决，首先操作起来太复杂，其次这样还是又违反了 CAP 中的 A 的设计，导致服务之间是不连通的。
持久化的机制来带的问题，ZooKeeper 的 ZAB 协议对每一个写请求，会在每个 ZooKeeper 节点上保持写一个事务日志，同时再加上定期的将内存数据镜像（Snapshot）到磁盘来保证数据的一致性和持久性，而对于一个简单的服务发现的场景来说，这其实没有太大的必要，这个实现方案太重了。而且本身存储的数据应该是高度定制化的。
消息发送应该弱依赖注册中心，而 RocketMQ 的设计理念也正是基于此，生产者在第一次发送消息的时候从 NameServer 获取到 Broker 地址后缓存到本地，如果 NameServer 整个集群不可用，短时间内对于生产者和消费者并不会产生太大影响。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="broker-是怎么保存数据的呢">Broker 是怎么保存数据的呢？<a href="#broker-是怎么保存数据的呢" class="hash-link" aria-label="Direct link to Broker 是怎么保存数据的呢？" title="Direct link to Broker 是怎么保存数据的呢？">​</a></h3>
<p>RocketMQ 主要的存储文件包括 CommitLog 文件、ConsumeQueue 文件、Indexfile 文件。</p>
<p><img decoding="async" loading="lazy" alt="1757342306713" src="/doc/assets/images/1757342306713-14e3675cf5622137972d42a7a81f5978.png" width="1060" height="352" class="img_ev3q">
消息存储的整体的设计：
<img decoding="async" loading="lazy" alt="1757342320658" src="/doc/assets/images/1757342320658-7e3f175985ec9430d4776922eae4b4e4.png" width="1080" height="847" class="img_ev3q">
CommitLog：消息主体以及元数据的存储主体，存储 Producer 端写入的消息主体内容,消息内容不是定长的。单个文件大小默认 1G, 文件名长度为 20 位，左边补零，剩余为起始偏移量，比如 00000000000000000000 代表了第一个文件，起始偏移量为 0，文件大小为 1G=1073741824；当第一个文件写满了，第二个文件为 00000000001073741824，起始偏移量为 1073741824，以此类推。消息主要是顺序写入日志文件，当文件满了，写入下一个文件。
CommitLog 文件保存于<code>${Rocket_Home}/store/commitlog</code> 目录中，从图中我们可以明显看出来文件名的偏移量，每个文件默认 1G，写满后自动生成一个新的文件。
<img decoding="async" loading="lazy" alt="1757342338586" src="/doc/assets/images/1757342338586-0171695736537e1503e3a4593c9f1867.png" width="1080" height="162" class="img_ev3q">
ConsumeQueue：消息消费队列，引入的目的主要是提高消息消费的性能，由于 RocketMQ 是基于主题 topic 的订阅模式，消息消费是针对主题进行的，如果要遍历 commitlog 文件中根据 topic 检索消息是非常低效的。
Consumer 即可根据 ConsumeQueue 来查找待消费的消息。其中，ConsumeQueue（逻辑消费队列）作为消费消息的索引，保存了指定 Topic 下的队列消息在 CommitLog 中的起始物理偏移量 offset，消息大小 size 和消息 Tag 的 HashCode 值。</p>
<p>ConsumeQueue 文件可以看成是基于 Topic 的 CommitLog 索引文件，故 ConsumeQueue 文件夹的组织方式如下：topic/queue/file 三层组织结构，具体存储路径为：$HOME/store/consumequeue/topic/queueId/fileName。同样 ConsumeQueue 文件采取定长设计，每一个条目共 20 个字节，分别为 8 字节的 CommitLog 物理偏移量、4 字节的消息长度、8 字节 tag hashcode，单个文件由 30W 个条目组成，可以像数组一样随机访问每一个条目，每个 ConsumeQueue 文件大小约 5.72M；
<img decoding="async" loading="lazy" alt="1757342359439" src="/doc/assets/images/1757342359439-25dd6301d5293ac8cd620192e9fe9aab.png" width="1080" height="328" class="img_ev3q"></p>
<p>IndexFile：IndexFile（索引文件）提供了一种可以通过 key 或时间区间来查询消息的方法。Index 文件的存储位置是： fileName，文件名 fileName 是以创建时的时间戳命名的，固定的单个 IndexFile 文件大小约为 400M，一个 IndexFile 可以保存 2000W 个索引，IndexFile 的底层存储设计为在文件系统中实现 HashMap 结构，故 RocketMQ 的索引文件其底层实现为 hash 索引。</p>
<p><img decoding="async" loading="lazy" alt="1757342375415" src="/doc/assets/images/1757342375415-c352a382877953b43325a340c6678123.png" width="1080" height="483" class="img_ev3q">
总结一下：RocketMQ 采用的是混合型的存储结构，即为 Broker 单个实例下所有的队列共用一个日志数据文件（即为 CommitLog）来存储。</p>
<p>RocketMQ 的混合型存储结构(多个 Topic 的消息实体内容都存储于一个 CommitLog 中)针对 Producer 和 Consumer 分别采用了数据和索引部分相分离的存储结构，Producer 发送消息至 Broker 端，然后 Broker 端使用同步或者异步的方式对消息刷盘持久化，保存至 CommitLog 中。</p>
<p>只要消息被刷盘持久化至磁盘文件 CommitLog 中，那么 Producer 发送的消息就不会丢失。正因为如此，Consumer 也就肯定有机会去消费这条消息。当无法拉取到消息后，可以等下一次消息拉取，同时服务端也支持长轮询模式，如果一个消息拉取请求未拉取到消息，Broker 允许等待 30s 的时间，只要这段时间内有新消息到达，将直接返回给消费端。</p>
<p>这里，RocketMQ 的具体做法是，使用 Broker 端的后台服务线程—ReputMessageService 不停地分发请求并异步构建 ConsumeQueue（逻辑消费队列）和 IndexFile（索引文件）数据。
<img decoding="async" loading="lazy" alt="1757342387442" src="/doc/assets/images/1757342387442-c2c33e365e5b631cd149d71eb6e3e41e.png" width="1080" height="375" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说-rocketmq-怎么对文件进行读写的">说说 RocketMQ 怎么对文件进行读写的？<a href="#说说-rocketmq-怎么对文件进行读写的" class="hash-link" aria-label="Direct link to 说说 RocketMQ 怎么对文件进行读写的？" title="Direct link to 说说 RocketMQ 怎么对文件进行读写的？">​</a></h3>
<p>RocketMQ 对文件的读写巧妙地利用了操作系统的一些高效文件读写方式——PageCache、顺序读写、零拷贝。</p>
<p>PageCache、顺序读取
在 RocketMQ 中，ConsumeQueue 逻辑消费队列存储的数据较少，并且是顺序读取，在 page cache 机制的预读取作用下，Consume Queue 文件的读性能几乎接近读内存，即使在有消息堆积情况下也不会影响性能。而对于 CommitLog 消息存储的日志数据文件来说，读取消息内容时候会产生较多的随机访问读取，严重影响性能。如果选择合适的系统 IO 调度算法，比如设置调度算法为“Deadline”（此时块存储采用 SSD 的话），随机读的性能也会有所提升。</p>
<p>页缓存（PageCache)是 OS 对文件的缓存，用于加速对文件的读写。一般来说，程序对文件进行顺序读写的速度几乎接近于内存的读写速度，主要原因就是由于 OS 使用 PageCache 机制对读写访问操作进行了性能优化，将一部分的内存用作 PageCache。对于数据的写入，OS 会先写入至 Cache 内，随后通过异步的方式由 pdflush 内核线程将 Cache 内的数据刷盘至物理磁盘上。对于数据的读取，如果一次读取文件时出现未命中 PageCache 的情况，OS 从物理磁盘上访问读取文件的同时，会顺序对其他相邻块的数据文件进行预读取。</p>
<p>零拷贝
另外，RocketMQ 主要通过 MappedByteBuffer 对文件进行读写操作。其中，利用了 NIO 中的 FileChannel 模型将磁盘上的物理文件直接映射到用户态的内存地址中（这种 Mmap 的方式减少了传统 IO，将磁盘文件数据在操作系统内核地址空间的缓冲区，和用户应用程序地址空间的缓冲区之间来回进行拷贝的性能开销），将对文件的操作转化为直接对内存地址进行操作，从而极大地提高了文件的读写效率（正因为需要使用内存映射机制，故 RocketMQ 的文件存储都使用定长结构来存储，方便一次将整个文件映射至内存）</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说什么是零拷贝">说说什么是零拷贝?<a href="#说说什么是零拷贝" class="hash-link" aria-label="Direct link to 说说什么是零拷贝?" title="Direct link to 说说什么是零拷贝?">​</a></h3>
<p>在操作系统中，使用传统的方式，数据需要经历几次拷贝，还要经历用户态/内核态切换。</p>
<p><img decoding="async" loading="lazy" alt="1757343028754" src="/doc/assets/images/1757343028754-be4343b97ffa6313a043fb1e441b17fb.png" width="914" height="568" class="img_ev3q">
从磁盘复制数据到内核态内存；
从内核态内存复制到用户态内存；
然后从用户态内存复制到网络驱动的内核态内存；
最后是从网络驱动的内核态内存复制到网卡中进行传输。</p>
<p>所以，可以通过零拷贝的方式，减少用户态与内核态的上下文切换和内存拷贝的次数，用来提升 I/O 的性能。零拷贝比较常见的实现方式是mmap，这种机制在 Java 中是通过 MappedByteBuffer 实现的。
<img decoding="async" loading="lazy" alt="1757343053587" src="/doc/assets/images/1757343053587-1842e1c8d32949377a5b2e0b4cf56438.png" width="925" height="587" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="消息刷盘怎么实现的呢">消息刷盘怎么实现的呢？<a href="#消息刷盘怎么实现的呢" class="hash-link" aria-label="Direct link to 消息刷盘怎么实现的呢？" title="Direct link to 消息刷盘怎么实现的呢？">​</a></h3>
<p>RocketMQ 提供了两种刷盘策略：同步刷盘和异步刷盘</p>
<p>同步刷盘：在消息达到 Broker 的内存之后，必须刷到 commitLog 日志文件中才算成功，然后返回 Producer 数据已经发送成功。
异步刷盘：异步刷盘是指消息达到 Broker 内存后就返回 Producer 数据已经发送成功，会唤醒一个线程去将数据持久化到 CommitLog 日志文件中。</p>
<p>Broker 在消息的存取时直接操作的是内存（内存映射文件），这可以提供系统的吞吐量，但是无法避免机器掉电时数据丢失，所以需要持久化到磁盘中。</p>
<p>刷盘的最终实现都是使用NIO中的 MappedByteBuffer.force() 将映射区的数据写入到磁盘，如果是同步刷盘的话，在Broker把消息写到CommitLog映射区后，就会等待写入完成。</p>
<p>异步而言，只是唤醒对应的线程，不保证执行的时机，流程如图所示。
<img decoding="async" loading="lazy" alt="1757343118639" src="/doc/assets/images/1757343118639-07bdaf28465c81e16f4a6da79443ae00.png" width="930" height="664" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="能说下-rocketmq-的负载均衡是如何实现的">能说下 RocketMQ 的负载均衡是如何实现的？<a href="#能说下-rocketmq-的负载均衡是如何实现的" class="hash-link" aria-label="Direct link to 能说下 RocketMQ 的负载均衡是如何实现的？" title="Direct link to 能说下 RocketMQ 的负载均衡是如何实现的？">​</a></h3>
<p>RocketMQ 中的负载均衡都在 Client 端完成，具体来说的话，主要可以分为 Producer 端发送消息时候的负载均衡和 Consumer 端订阅消息的负载均衡。</p>
<p>Producer 的负载均衡
Producer 端在发送消息的时候，会先根据 Topic 找到指定的 TopicPublishInfo，在获取了 TopicPublishInfo 路由信息后，RocketMQ 的客户端在默认方式下 selectOneMessageQueue()方法会从 TopicPublishInfo 中的 messageQueueList 中选择一个队列（MessageQueue）进行发送消息。具这里有一个 sendLatencyFaultEnable 开关变量，如果开启，在随机递增取模的基础上，再过滤掉 not available 的 Broker 代理。
<img decoding="async" loading="lazy" alt="1757343142035" src="/doc/assets/images/1757343142035-8f55997107f5dc605731bac3357c167e.png" width="1058" height="522" class="img_ev3q">
所谓的&quot;latencyFaultTolerance&quot;，是指对之前失败的，按一定的时间做退避。例如，如果上次请求的 latency 超过 550Lms，就退避 3000Lms；超过 1000L，就退避 60000L；如果关闭，采用随机递增取模的方式选择一个队列（MessageQueue）来发送消息，latencyFaultTolerance 机制是实现消息发送高可用的核心关键所在。</p>
<p>Consumer 的负载均衡
在 RocketMQ 中，Consumer 端的两种消费模式（Push/Pull）都是基于拉模式来获取消息的，而在 Push 模式只是对 pull 模式的一种封装，其本质实现为消息拉取线程在从服务器拉取到一批消息后，然后提交到消息消费线程池后，又“马不停蹄”的继续向服务器再次尝试拉取消息。如果未拉取到消息，则延迟一下又继续拉取。在两种基于拉模式的消费方式（Push/Pull）中，均需要 Consumer 端知道从 Broker 端的哪一个消息队列中去获取消息。因此，有必要在 Consumer 端来做负载均衡，即 Broker 端中多个 MessageQueue 分配给同一个 ConsumerGroup 中的哪些 Consumer 消费。</p>
<p>Consumer 端的心跳包发送
在 Consumer 启动后，它就会通过定时任务不断地向 RocketMQ 集群中的所有 Broker 实例发送心跳包（其中包含了，消息消费分组名称、订阅关系集合、消息通信模式和客户端 id 的值等信息）。Broker 端在收到 Consumer 的心跳消息后，会将它维护在 ConsumerManager 的本地缓存变量—consumerTable，同时并将封装后的客户端网络通道信息保存在本地缓存变量—channelInfoTable 中，为之后做 Consumer 端的负载均衡提供可以依据的元数据信息。</p>
<p>Consumer 端实现负载均衡的核心类—RebalanceImpl
在 Consumer 实例的启动流程中的启动 MQClientInstance 实例部分，会完成负载均衡服务线程—RebalanceService 的启动（每隔 20s 执行一次）。</p>
<p>通过查看源码可以发现，RebalanceService 线程的 run()方法最终调用的是 RebalanceImpl 类的 rebalanceByTopic()方法，这个方法是实现 Consumer 端负载均衡的核心。</p>
<p>rebalanceByTopic()方法会根据消费者通信类型为“广播模式”还是“集群模式”做不同的逻辑处理。这里主要来看下集群模式下的主要处理流程：</p>
<p><img decoding="async" loading="lazy" alt="1757343176280" src="/doc/assets/images/1757343176280-2be4946fe4ea22ec4f750e2d78cb4732.png" width="1080" height="1453" class="img_ev3q"></p>
<p>(1) 从 rebalanceImpl 实例的本地缓存变量—topicSubscribeInfoTable 中，获取该 Topic 主题下的消息消费队列集合（mqSet）；</p>
<p>(2) 根据 topic 和 consumerGroup 为参数调用 mQClientFactory.findConsumerIdList()方法向 Broker 端发送通信请求，获取该消费组下消费者 Id 列表；</p>
<p>(3) 先对 Topic 下的消息消费队列、消费者 Id 排序，然后用消息队列分配策略算法（默认为：消息队列的平均分配算法），计算出待拉取的消息队列。这里的平均分配算法，类似于分页的算法，将所有 MessageQueue 排好序类似于记录，将所有消费端 Consumer 排好序类似页数，并求出每一页需要包含的平均 size 和每个页面记录的范围 range，最后遍历整个 range 而计算出当前 Consumer 端应该分配到的的 MessageQueue。
<img decoding="async" loading="lazy" alt="1757343204375" src="/doc/assets/images/1757343204375-d195cc21860cceb222f480ed4f5407a3.png" width="493" height="453" class="img_ev3q"></p>
<p>(4) 然后，调用 updateProcessQueueTableInRebalance()方法，具体的做法是，先将分配到的消息队列集合（mqSet）与 processQueueTable 做一个过滤比对。
<img decoding="async" loading="lazy" alt="1757343225237" src="/doc/assets/images/1757343225237-92b198cfb4ac975109d326aba1e0f773.png" width="1080" height="470" class="img_ev3q"></p>
<p>上图中 processQueueTable 标注的红色部分，表示与分配到的消息队列集合 mqSet 互不包含。将这些队列设置 Dropped 属性为 true，然后查看这些队列是否可以移除出 processQueueTable 缓存变量，这里具体执行 removeUnnecessaryMessageQueue()方法，即每隔 1s 查看是否可以获取当前消费处理队列的锁，拿到的话返回 true。如果等待 1s 后，仍然拿不到当前消费处理队列的锁则返回 false。如果返回 true，则从 processQueueTable 缓存变量中移除对应的 Entry；
上图中 processQueueTable 的绿色部分，表示与分配到的消息队列集合 mqSet 的交集。判断该 ProcessQueue 是否已经过期了，在 Pull 模式的不用管，如果是 Push 模式的，设置 Dropped 属性为 true，并且调用 removeUnnecessaryMessageQueue()方法，像上面一样尝试移除 Entry；
最后，为过滤后的消息队列集合（mqSet）中的每个 MessageQueue 创建一个 ProcessQueue 对象并存入 RebalanceImpl 的 processQueueTable 队列中（其中调用 RebalanceImpl 实例的 computePullFromWhere(MessageQueue mq)方法获取该 MessageQueue 对象的下一个进度消费值 offset，随后填充至接下来要创建的 pullRequest 对象属性中），并创建拉取请求对象—pullRequest 添加到拉取列表—pullRequestList 中，最后执行 dispatchPullRequest()方法，将 Pull 消息的请求对象 PullRequest 依次放入 PullMessageService 服务线程的阻塞队列 pullRequestQueue 中，待该服务线程取出后向 Broker 端发起 Pull 消息的请求。其中，可以重点对比下，RebalancePushImpl 和 RebalancePullImpl 两个实现类的 dispatchPullRequest()方法不同，RebalancePullImpl 类里面的该方法为空。
消息消费队列在同一消费组不同消费者之间的负载均衡，其核心设计理念是在一个消息消费队列在同一时间只允许被同一消费组内的一个消费者消费，一个消息消费者能同时消费多个消息队列。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="rocketmq-消息长轮询了解吗">RocketMQ 消息长轮询了解吗？<a href="#rocketmq-消息长轮询了解吗" class="hash-link" aria-label="Direct link to RocketMQ 消息长轮询了解吗？" title="Direct link to RocketMQ 消息长轮询了解吗？">​</a></h3>
<p>所谓的长轮询，就是 Consumer 拉取消息，如果对应的 Queue 如果没有数据，Broker 不会立即返回，而是把 PullReuqest hold 起来，等待 queue 有了消息后，或者长轮询阻塞时间到了，再重新处理该 queue 上的所有 PullRequest。
<img decoding="async" loading="lazy" alt="1757343606964" src="/doc/assets/images/1757343606964-b880263789b81632dd5242b74521ae99.png" width="581" height="256" class="img_ev3q"></p>
<p>PullMessageProcessor#processRequest</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//如果没有拉到数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">caseResponseCode.PULL_NOT_FOUND:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//broker和consumer都允许suspend，默认开启</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if(brokerAllowSuspend&amp;&amp;hasSuspendFlag){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    longpollingTimeMills=suspendTimeoutMillisLong;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(!this.brokerController.getBrokerConfig().isLongPollingEnable()){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pollingTimeMills=this.brokerController.getBrokerConfig().getShortPollingTimeMills();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Stringtopic=requestHeader.getTopic();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    longoffset=requestHeader.getQueueOffset();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    intqueueId=requestHeader.getQueueId();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //封装一个PullRequest</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    PullRequestpullRequest=newPullRequest(request,channel,pollingTimeMills,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.brokerController.getMessageStore().now(),offset,subscriptionData,messageFilter);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //把PullRequest挂起来</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.brokerController.getPullRequestHoldService().suspendPullRequest(topic,queueId,pullRequest);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    response=null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>挂起的请求，有一个服务线程会不停地检查，看 queue 中是否有数据，或者超时。</p>
<p>PullRequestHoldService#run()</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">publicvoidrun(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    log.info(&quot;{}servicestarted&quot;,this.getServiceName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while(!this.isStopped()){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(this.brokerController.getBrokerConfig().isLongPollingEnable()){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                this.waitForRunning(5*1000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }else{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                this.waitForRunning(this.brokerController.getBrokerConfig().getShortPollingTimeMills());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            longbeginLockTimestamp=this.systemClock.now();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //检查hold住的请求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.checkHoldRequest();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            longcostTime=this.systemClock.now()-beginLockTimestamp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(costTime&gt;5*1000){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                log.info(&quot;[NOTIFYME]checkholdrequestcost{}ms.&quot;,costTime);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }catch(Throwablee){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            log.warn(this.getServiceName()+&quot;servicehasexception.&quot;,e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    log.info(&quot;{}serviceend&quot;,this.getServiceName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-tags-row"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a rel="tag" class="tag_zVej tagRegular_sFm0" href="/doc/docs/tags/interview">INTERVIEW</a></li><li class="tag_QGVx"><a rel="tag" class="tag_zVej tagRegular_sFm0" href="/doc/docs/tags/rocketmq">ROCKETMQ</a></li><li class="tag_QGVx"><a rel="tag" class="tag_zVej tagRegular_sFm0" href="/doc/docs/tags/mq">MQ</a></li></ul></div></div><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/MQ/rocketmq-review.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/doc/docs/INTERVIEW/JAVA/JAVA-BASE"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">JAVA-BASE</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/doc/docs/INTERVIEW/MYSQL/MYSQL-REVIEW"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">MYSQL-REVIEW</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#基础" class="table-of-contents__link toc-highlight">基础</a><ul><li><a href="#为什么要使用消息队列呢" class="table-of-contents__link toc-highlight">为什么要使用消息队列呢？</a></li><li><a href="#如何用rocketmq做削峰填谷的" class="table-of-contents__link toc-highlight">如何用RocketMQ做削峰填谷的？</a></li><li><a href="#为什么要选择-rocketmq" class="table-of-contents__link toc-highlight">为什么要选择 RocketMQ?</a></li><li><a href="#rocketmq-有什么优缺点" class="table-of-contents__link toc-highlight">RocketMQ 有什么优缺点？</a></li><li><a href="#说说你对-rocketmq-的理解" class="table-of-contents__link toc-highlight">说说你对 RocketMQ 的理解？</a></li><li><a href="#消息队列有哪些消息模型" class="table-of-contents__link toc-highlight">消息队列有哪些消息模型？</a></li><li><a href="#那-rocketmq-的消息模型呢" class="table-of-contents__link toc-highlight">那 RocketMQ 的消息模型呢？</a></li><li><a href="#消息的消费模式了解吗" class="table-of-contents__link toc-highlight">消息的消费模式了解吗？</a></li><li><a href="#roctetmq-基本架构了解吗" class="table-of-contents__link toc-highlight">RoctetMQ 基本架构了解吗？</a></li><li><a href="#那能介绍一下这四部分吗" class="table-of-contents__link toc-highlight">那能介绍一下这四部分吗？</a></li></ul></li><li><a href="#进阶" class="table-of-contents__link toc-highlight">进阶</a><ul><li><a href="#如何保证消息的可用性可靠性不丢失呢" class="table-of-contents__link toc-highlight">如何保证消息的可用性/可靠性/不丢失呢？</a></li><li><a href="#如何处理消息重复的问题呢" class="table-of-contents__link toc-highlight">如何处理消息重复的问题呢？</a></li><li><a href="#如何保证消息的幂等性" class="table-of-contents__link toc-highlight">如何保证消息的幂等性？</a></li><li><a href="#雪花算法了解吗" class="table-of-contents__link toc-highlight">雪花算法了解吗？</a></li><li><a href="#怎么处理消息积压" class="table-of-contents__link toc-highlight">怎么处理消息积压？</a></li><li><a href="#顺序消息如何实现" class="table-of-contents__link toc-highlight">顺序消息如何实现？</a></li><li><a href="#如何实现消息过滤" class="table-of-contents__link toc-highlight">如何实现消息过滤？</a></li><li><a href="#延时消息了解吗" class="table-of-contents__link toc-highlight">延时消息了解吗？</a></li><li><a href="#rocketmq-怎么实现延时消息的" class="table-of-contents__link toc-highlight">RocketMQ 怎么实现延时消息的？</a></li><li><a href="#怎么实现分布式消息事务的半消息" class="table-of-contents__link toc-highlight">怎么实现分布式消息事务的？半消息？</a></li><li><a href="#死信队列知道吗" class="table-of-contents__link toc-highlight">死信队列知道吗？</a></li><li><a href="#如何保证-rocketmq-的高可用" class="table-of-contents__link toc-highlight">如何保证 RocketMQ 的高可用？</a></li></ul></li><li><a href="#原理" class="table-of-contents__link toc-highlight">原理</a><ul><li><a href="#说一下-rocketmq-的整体工作流程" class="table-of-contents__link toc-highlight">说一下 RocketMQ 的整体工作流程？</a></li><li><a href="#为什么-rocketmq-不使用-zookeeper-作为注册中心呢" class="table-of-contents__link toc-highlight">为什么 RocketMQ 不使用 Zookeeper 作为注册中心呢？</a></li><li><a href="#broker-是怎么保存数据的呢" class="table-of-contents__link toc-highlight">Broker 是怎么保存数据的呢？</a></li><li><a href="#说说-rocketmq-怎么对文件进行读写的" class="table-of-contents__link toc-highlight">说说 RocketMQ 怎么对文件进行读写的？</a></li><li><a href="#说说什么是零拷贝" class="table-of-contents__link toc-highlight">说说什么是零拷贝?</a></li><li><a href="#消息刷盘怎么实现的呢" class="table-of-contents__link toc-highlight">消息刷盘怎么实现的呢？</a></li><li><a href="#能说下-rocketmq-的负载均衡是如何实现的" class="table-of-contents__link toc-highlight">能说下 RocketMQ 的负载均衡是如何实现的？</a></li><li><a href="#rocketmq-消息长轮询了解吗" class="table-of-contents__link toc-highlight">RocketMQ 消息长轮询了解吗？</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/doc/docs/intro">Tutorial</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://x.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">X<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/doc/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>