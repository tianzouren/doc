<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-MQ/KAFKA_REVIEW" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.8.1">
<title data-rh="true">KAFKA_REVIEW | My Site</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://your-docusaurus-site.example.com/doc/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://your-docusaurus-site.example.com/doc/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://your-docusaurus-site.example.com/doc/docs/INTERVIEW/MQ"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="KAFKA_REVIEW | My Site"><meta data-rh="true" name="description" content="KAFKA_REVIEW"><meta data-rh="true" property="og:description" content="KAFKA_REVIEW"><link data-rh="true" rel="icon" href="/doc/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://your-docusaurus-site.example.com/doc/docs/INTERVIEW/MQ"><link data-rh="true" rel="alternate" href="https://your-docusaurus-site.example.com/doc/docs/INTERVIEW/MQ" hreflang="en"><link data-rh="true" rel="alternate" href="https://your-docusaurus-site.example.com/doc/docs/INTERVIEW/MQ" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"KAFKA_REVIEW","item":"https://your-docusaurus-site.example.com/doc/docs/INTERVIEW/MQ"}]}</script><link rel="alternate" type="application/rss+xml" href="/doc/blog/rss.xml" title="My Site RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/doc/blog/atom.xml" title="My Site Atom Feed"><link rel="stylesheet" href="/doc/assets/css/styles.8d5b4fe0.css">
<script src="/doc/assets/js/runtime~main.1f9c75d1.js" defer="defer"></script>
<script src="/doc/assets/js/main.01ab3953.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t="light";var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",e||t),document.documentElement.setAttribute("data-theme-choice",e||t)}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/doc/img/logo.svg"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/doc/"><div class="navbar__logo"><img src="/doc/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/doc/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">My Site</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/doc/docs/intro">Tutorial</a><a class="navbar__item navbar__link" href="/doc/blog">Blog</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="Switch between dark and light mode (currently system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/doc/docs/intro">Tutorial Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/doc/docs/category/tutorial---basics">Tutorial - Basics</a><button aria-label="Expand sidebar category &#x27;Tutorial - Basics&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/doc/docs/category/tutorial---extras">Tutorial - Extras</a><button aria-label="Expand sidebar category &#x27;Tutorial - Extras&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/doc/docs/JAVA/">java</a><button aria-label="Expand sidebar category &#x27;java&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" href="/doc/docs/INTERVIEW/MQ">MQ</a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/doc/docs/INTERVIEW/MQ">KAFKA_REVIEW</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/doc/docs/INTERVIEW/MQ">ROCKETMQ_REVIEW</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/MYSQL/MYSQL-REVIEW">MYSQL</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/NGINX/NGINX-REVIEW">NGINX</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/intereview/redis">REDIS</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/SPRING/SPRING-REVIEW">SPRING</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/doc/docs/tmp">tmp</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/分布式/分布式-REVIEW">分布式</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/微服务/微服务-REVIEW">微服务</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/doc/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">MQ</span></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">KAFKA_REVIEW</span></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>KAFKA_REVIEW</h1></header><h3 class="anchor anchorWithStickyNavbar_LWe7" id="kafka-的设计">Kafka 的设计？<a href="#kafka-的设计" class="hash-link" aria-label="Direct link to Kafka 的设计？" title="Direct link to Kafka 的设计？">​</a></h3>
<p>Kafka 将消息以 topic 为单位进行归纳，发布消息的程序称为 Producer，消费消息的程序称为 Consumer。它是以集群的方式运行，可以由一个或多个服务组成，每个服务叫做一个 Broker，Producer 通过网络将消息发送到 kafka 集群，集群向消费者提供消息，broker 在中间起到一个代理保存消息的中转站。</p>
<p>Kafka 中重要的组件</p>
<ol>
<li>Producer：消息生产者，发布消息到Kafka集群的终端或服务</li>
<li>Broker：一个 Kafka 节点就是一个 Broker，多个Broker可组成一个Kafka 集群。</li>
</ol>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">如果某个 Topic 下有 n 个Partition 且集群有 n 个Broker，那么每个 Broker会存储该 Topic 下的一个 Partition</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">如果某个 Topic 下有 n 个Partition 且集群中有 m+n 个Broker，那么只有 n 个Broker会存储该Topic下的一个 Partition</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">如果某个 Topic 下有 n 个Partition 且集群中的Broker数量小于 n，那么一个 Broker 会存储该 Topic 下的一个或多个 Partition，这种情况尽量避免，会导致集群数据不均衡</span><br></span></code></pre></div></div>
<ol start="3">
<li>Topic：消息主题，每条发布到Kafka集群的消息都会归集于此，Kafka是面向Topic 的</li>
<li>Partition：Partition 是Topic在物理上的分区，一个Topic可以分为多个Partition，每个Partition是一个有序的不可变的记录序列。单一主题中的分区有序，但无法保证主题中所有分区的消息有序。</li>
<li>Consumer：从Kafka集群中消费消息的终端或服务</li>
<li>Consumer Group：每个Consumer都属于一个Consumer Group，每条消息只能被Consumer Group中的一个Consumer消费，但可以被多个Consumer Group消费。</li>
<li>Replica：Partition 的副本，用来保障Partition的高可用性。</li>
<li>Controller： Kafka 集群中的其中一个服务器，用来进行Leader election以及各种 Failover 操作。</li>
<li>Zookeeper：Kafka 通过Zookeeper来存储集群中的 meta 消息</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kafka-性能高原因">Kafka 性能高原因<a href="#kafka-性能高原因" class="hash-link" aria-label="Direct link to Kafka 性能高原因" title="Direct link to Kafka 性能高原因">​</a></h3>
<ol>
<li>利用了 PageCache 缓存</li>
<li>磁盘顺序写</li>
<li>零拷贝技术</li>
<li>pull 拉模式</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kafka-文件高效存储设计原理">Kafka 文件高效存储设计原理<a href="#kafka-文件高效存储设计原理" class="hash-link" aria-label="Direct link to Kafka 文件高效存储设计原理" title="Direct link to Kafka 文件高效存储设计原理">​</a></h3>
<ol>
<li>Kafka把Topic中一个Partition大文件分成多个小文件段，通过多个小文件段，就容易定期清除或删除已经消费完成的文件，减少磁盘占用</li>
<li>通过索引信息可以快速定位Message和确定response的最大大小</li>
<li>通过将索引元数据全部映射到 memory，可以避免 Segment 文件的磁盘I/O操作</li>
<li>通过索引文件稀疏存储，可以大幅降低索引文件元数据占用空间大小</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kafka-的优缺点">Kafka 的优缺点<a href="#kafka-的优缺点" class="hash-link" aria-label="Direct link to Kafka 的优缺点" title="Direct link to Kafka 的优缺点">​</a></h3>
<ul>
<li>
<p>优点<br>
<!-- -->高性能、高吞吐量、低延迟：Kafka 生产和消费消息的速度都达到每秒10万级<br>
<!-- -->高可用：所有消息持久化存储到磁盘，并支持数据备份防止数据丢失<br>
<!-- -->高并发：支持数千个客户端同时读写<br>
<!-- -->容错性：允许集群中节点失败（若副本数量为n，则允许 n-1 个节点失败）<br>
<!-- -->高扩展性：Kafka 集群支持热伸缩，无须停机</p>
</li>
<li>
<p>缺点
没有完整的监控工具集
不支持通配符主题选择</p>
</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kafka-的应用场景">Kafka 的应用场景<a href="#kafka-的应用场景" class="hash-link" aria-label="Direct link to Kafka 的应用场景" title="Direct link to Kafka 的应用场景">​</a></h3>
<ol>
<li>日志聚合：可收集各种服务的日志写入kafka的消息队列进行存储</li>
<li>消息系统：广泛用于消息中间件</li>
<li>系统解耦：在重要操作完成后，发送消息，由别的服务系统来完成其他操作</li>
<li>流量削峰：一般用于秒杀或抢购活动中，来缓冲网站短时间内高流量带来的压力</li>
<li>异步处理：通过异步处理机制，可以把一个消息放入队列中，但不立即处理它，在需要的时候再进行处理</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kafka-中分区的概念">Kafka 中分区的概念<a href="#kafka-中分区的概念" class="hash-link" aria-label="Direct link to Kafka 中分区的概念" title="Direct link to Kafka 中分区的概念">​</a></h3>
<p>主题是一个逻辑上的概念，还可以细分为多个分区，一个分区只属于单个主题，很多时候也会把分区称为主题分区（Topic-Partition）。同一主题下的不同分区包含的消息是不同的，分区在存储层面可以看做一个可追加的日志文件 ，消息在被追加到分区日志文件的时候都会分配一个特定的偏移量（offset）。offset 是消息在分区中的唯一标识，kafka 通过它来保证消息在分区内的顺序性，不过 offset 并不跨越分区，也就是说，kafka保证的是分区有序而不是主题有序。</p>
<p>在分区中又引入了多副本（replica）的概念，通过增加副本数量可以提高容灾能力。同一分区的不同副本中保存的是相同的消息。副本之间是一主多从的关系，其中主副本负责读写，从副本只负责消息同步。副本处于不同的 broker 中，当主副本出现异常，便会在从副本中提升一个为主副本。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kafka-中分区的原则">Kafka 中分区的原则<a href="#kafka-中分区的原则" class="hash-link" aria-label="Direct link to Kafka 中分区的原则" title="Direct link to Kafka 中分区的原则">​</a></h3>
<p>指明Partition的情况下，直接将指明的值作为Partition值<br>
<!-- -->没有指明Partition值但有 key 的情况下，将 key 的 Hash 值与 topic 的Partition值进行取余得到Partition值<br>
<!-- -->既没有Partition值又没有 key 值的情况下，第一次调用时随机生成一个整数（后面每次调用在这个整数上自增），将这个值与Topic可用的Partition总数取余得到Parittion值，也就是常说的 round-robin 算法</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kafka-为什么要把消息分区">Kafka 为什么要把消息分区<a href="#kafka-为什么要把消息分区" class="hash-link" aria-label="Direct link to Kafka 为什么要把消息分区" title="Direct link to Kafka 为什么要把消息分区">​</a></h3>
<ol>
<li>方便在集群中扩展，每个 Partition 可用通过调整以适应它所在的机器，而一个Topic又可以有多个Partition组成，因此整个集群就可以适应任意大小的数据了</li>
<li>可以提高并发，因为可以以Partition为单位进行读写</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kafka-中生产者运行流程">Kafka 中生产者运行流程<a href="#kafka-中生产者运行流程" class="hash-link" aria-label="Direct link to Kafka 中生产者运行流程" title="Direct link to Kafka 中生产者运行流程">​</a></h3>
<ol>
<li>一条消息发过来首先会被封装成一个 ProducerRecord 对象</li>
<li>对该对象进行序列化处理（可以使用默认，也可以自定义序列化）</li>
<li>对消息进行分区处理，分区的时候需要获取集群的元数据，决定这个消息会被发送到哪个主题的哪个分区</li>
<li>分好区的消息不会直接发送到服务端，而是放入生产者的缓存区，多条消息会被封装成一个批次（Batch），默认一个批次的大小是 16KB</li>
<li>Sender 线程启动以后会从缓存里面去获取可以发送的批次</li>
<li>Sender 线程把一个一个批次发送到服务端
<img decoding="async" loading="lazy" alt="1759624172972" src="/doc/assets/images/1759624172972-12c6a6a377319f6dca2169ff823bddc2.png" width="850" height="784" class="img_ev3q"></li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kafka-中的消息封装">Kafka 中的消息封装<a href="#kafka-中的消息封装" class="hash-link" aria-label="Direct link to Kafka 中的消息封装" title="Direct link to Kafka 中的消息封装">​</a></h3>
<p>在Kafka 中 Producer 可以 Batch的方式推送数据达到提高效率的作用。Kafka Producer 可以将消息在内存中累积到一定数量后作为一个 Batch 发送请求。Batch 的数量大小可以通过 Producer 的参数进行控制，可以从三个维度进行控制</p>
<ul>
<li>累计的消息的数量（如500条）</li>
<li>累计的时间间隔（如100ms）</li>
<li>累计的数据大小（如64KB）<br>
<!-- -->通过增加 Batch 的大小，可以减少网络请求和磁盘I/O的频次，具体参数配置需要在效率和时效性做一个权衡。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kafka-消息的消费模式">Kafka 消息的消费模式<a href="#kafka-消息的消费模式" class="hash-link" aria-label="Direct link to Kafka 消息的消费模式" title="Direct link to Kafka 消息的消费模式">​</a></h3>
<p>Kafka采用大部分消息系统遵循的传统模式：Producer将消息推送到Broker，Consumer从Broker获取消息。<br>
<!-- -->如果采用 Push 模式，则Consumer难以处理不同速率的上游推送消息。</p>
<p>采用 Pull 模式的好处是Consumer可以自主决定是否批量的从Broker拉取数据。Pull模式有个缺点是，如果Broker没有可供消费的消息，将导致Consumer不断在循环中轮询，直到新消息到达。为了避免这点，Kafka有个参数可以让Consumer阻塞直到新消息到达。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kafka-如何实现负载均衡与故障转移">Kafka 如何实现负载均衡与故障转移<a href="#kafka-如何实现负载均衡与故障转移" class="hash-link" aria-label="Direct link to Kafka 如何实现负载均衡与故障转移" title="Direct link to Kafka 如何实现负载均衡与故障转移">​</a></h3>
<p>负载均衡是指让系统的负载根据一定的规则均衡地分配在所有参与工作的服务器上，从而最大限度保证系统整体运行效率与稳定性</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="负载均衡">负载均衡<a href="#负载均衡" class="hash-link" aria-label="Direct link to 负载均衡" title="Direct link to 负载均衡">​</a></h4>
<p>Kakfa 的负载均衡就是每个 Broker 都有均等的机会为 Kafka 的客户端（生产者与消费者）提供服务，可以负载分散到所有集群中的机器上。Kafka 通过智能化的分区领导者选举来实现负载均衡，提供智能化的 Leader 选举算法，可在集群的所有机器上均匀分散各个Partition的Leader，从而整体上实现负载均衡。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="故障转移">故障转移<a href="#故障转移" class="hash-link" aria-label="Direct link to 故障转移" title="Direct link to 故障转移">​</a></h3>
<p>Kafka 的故障转移是通过使用会话机制实现的，每台 Kafka 服务器启动后会以会话的形式把自己注册到 Zookeeper 服务器上。一旦服务器运转出现问题，就会导致与Zookeeper 的会话不能维持从而超时断连，此时Kafka集群会选举出另一台服务器来完全替代这台服务器继续提供服务。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kafka-中-zookeeper-的作用">Kafka 中 Zookeeper 的作用<a href="#kafka-中-zookeeper-的作用" class="hash-link" aria-label="Direct link to Kafka 中 Zookeeper 的作用" title="Direct link to Kafka 中 Zookeeper 的作用">​</a></h3>
<p>Kafka 是一个使用 Zookeeper 构建的分布式系统。Kafka 的各 Broker 在启动时都要在Zookeeper上注册，由Zookeeper统一协调管理。如果任何节点失败，可通过Zookeeper从先前提交的偏移量中恢复，因为它会做周期性提交偏移量工作。同一个Topic的消息会被分成多个分区并将其分布在多个Broker上，这些分区信息及与Broker的对应关系也是Zookeeper在维护。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kafka-中消费者与消费者组的关系与负载均衡实现">Kafka 中消费者与消费者组的关系与负载均衡实现<a href="#kafka-中消费者与消费者组的关系与负载均衡实现" class="hash-link" aria-label="Direct link to Kafka 中消费者与消费者组的关系与负载均衡实现" title="Direct link to Kafka 中消费者与消费者组的关系与负载均衡实现">​</a></h3>
<p>Consumer Group 是Kafka独有的可扩展且具有容错性的消费者机制。一个组内可以有多个Consumer，它们共享一个全局唯一的Group ID。组内的所有Consumer协调在一起来消费订阅主题（Topic）内的所有分区（Partition）。当然，每个Partition只能由同一个Consumer Group内的一个Consumer 来消费。消费组内的消费者可以使用多线程的方式实现，消费者的数量通常不超过分区的数量，且二者最好保持整数倍的关系，这样不会造成有空闲的消费者。</p>
<p>Consumer 订阅的是Topic的Partition，而不是Message。所以在同一时间点上，订阅到同一个分区的Consumer必然属于不同的Consumer Group</p>
<p>Consumer Group与Consumer的关系是动态维护的，当一个Consumer进程挂掉或者是卡住时，该Consumer所订阅的Partition会被重新分配到改组内的其他Consumer上，当一个Consumer加入到一个Consumer Group中时，同样会从其他的Consumer中分配出一个或者多个Partition到这个新加入的Consumer。</p>
<p>负载均衡
当启动一个Consumer时，会指定它要加入的Group，使用的配置项是：Group.id<br>
<!-- -->为了维持Consumer与Consumer Group之间的关系，Consumer 会周期性地发送 hearbeat 到 coodinator（协调者），如果有 hearbeat 超时或未收到 hearbeat，coordinator 会认为该Consumer已经退出，那么它所订阅的Partition会分配到同一组内的其他Consumer上，这个过程称为 rebalance（再平衡）</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kafka-中消息偏移的作用">Kafka 中消息偏移的作用<a href="#kafka-中消息偏移的作用" class="hash-link" aria-label="Direct link to Kafka 中消息偏移的作用" title="Direct link to Kafka 中消息偏移的作用">​</a></h3>
<p>生产过程中给分区中的消息提供一个顺序ID号，称之为偏移量，偏移量的主要作用为了唯一地区别分区中的每条消息。Kafka的存储文件都是按照offset.kafka来命名</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="生产过程中何时会发生queuefullexpection以及如何处理">生产过程中何时会发生QueueFullExpection以及如何处理<a href="#生产过程中何时会发生queuefullexpection以及如何处理" class="hash-link" aria-label="Direct link to 生产过程中何时会发生QueueFullExpection以及如何处理" title="Direct link to 生产过程中何时会发生QueueFullExpection以及如何处理">​</a></h3>
<p>何时发生<br>
<!-- -->当生产者试图发送消息的速度快于Broker可以处理的速度时，通常会发生 QueueFullException</p>
<p>如何解决<br>
<!-- -->首先先进行判断生产者是否能够降低生产速率，如果生产者不能阻止这种情况，为了处理增加的负载，用户需要添加足够的 Broker。或者选择生产阻塞，设置Queue.enQueueTimeout.ms 为 -1，通过这样处理，如果队列已满的情况，生产者将组织而不是删除消息。或者容忍这种异常，进行消息丢弃。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="consumer-如何消费指定分区消息">Consumer 如何消费指定分区消息<a href="#consumer-如何消费指定分区消息" class="hash-link" aria-label="Direct link to Consumer 如何消费指定分区消息" title="Direct link to Consumer 如何消费指定分区消息">​</a></h3>
<p>Cosumer 消费消息时，想Broker 发出 fetch 请求去消费特定分区的消息，Consumer 可以通过指定消息在日志中的偏移量 offset，就可以从这个位置开始消息消息，Consumer 拥有了 offset 的控制权，也可以向后回滚去重新消费之前的消息。
也可以使用 seek(Long topicPartition) 来指定消费的位置。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="replicaleader-和-follower-三者的概念">Replica、Leader 和 Follower 三者的概念<a href="#replicaleader-和-follower-三者的概念" class="hash-link" aria-label="Direct link to Replica、Leader 和 Follower 三者的概念" title="Direct link to Replica、Leader 和 Follower 三者的概念">​</a></h3>
<p>Kafka 中的 Partition 是有序消息日志，为了实现高可用性，需要采用备份机制，将相同的数据复制到多个Broker上，而这些备份日志就是 Replica，目的是为了 防止数据丢失。<br>
<!-- -->所有Partition 的副本默认情况下都会均匀地分布到所有 Broker 上,一旦领导者副本所在的Broker宕机，Kafka 会从追随者副本中选举出新的领导者继续提供服务。</p>
<ul>
<li>Leader： 副本中的领导者。负责对外提供服务，与客户端进行交互。生产者总是向 Leader副本些消息，消费者总是从 Leader 读消息</li>
<li>Follower： 副本中的追随者。被动地追随 Leader，不能与外界进行交付。只是向Leader发送消息，请求Leader把最新生产的消息发给它，进而保持同步</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="replica-的重要性">Replica 的重要性<a href="#replica-的重要性" class="hash-link" aria-label="Direct link to Replica 的重要性" title="Direct link to Replica 的重要性">​</a></h3>
<p>Replica 可以确保发布的消息不会丢失，保证了Kafka的高可用性。并且可以在发生任何机器错误、程序错误或软件升级、扩容时都能生产使用。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kafka-中-arisrosr-三者的概念">Kafka 中 AR、ISR、OSR 三者的概念<a href="#kafka-中-arisrosr-三者的概念" class="hash-link" aria-label="Direct link to Kafka 中 AR、ISR、OSR 三者的概念" title="Direct link to Kafka 中 AR、ISR、OSR 三者的概念">​</a></h3>
<p>-AR：分区中所有副本称为 AR<br>
<!-- -->ISR：所有与主副本保持一定程度同步的副本（包括主副本）称为 ISR<br>
<!-- -->OSR：与主副本滞后过多的副本组成 OSR</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="分区副本什么情况下会从-isr-中剔出">分区副本什么情况下会从 ISR 中剔出<a href="#分区副本什么情况下会从-isr-中剔出" class="hash-link" aria-label="Direct link to 分区副本什么情况下会从 ISR 中剔出" title="Direct link to 分区副本什么情况下会从 ISR 中剔出">​</a></h3>
<p>Leader 会维护一个与自己基本保持同步的Replica列表，该列表称为ISR，每个Partition都会有一个ISR，而且是由Leader动态维护。所谓动态维护，就是说如果一个Follower比一个Leader落后太多，或者超过一定时间未发起数据复制请求，则Leader将其从ISR中移除。当ISR中所有Replica都向Leader发送ACK（Acknowledgement确认）时，Leader才commit。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="分区副本中的-leader-如果宕机但-isr-却为空该如何处理">分区副本中的 Leader 如果宕机但 ISR 却为空该如何处理<a href="#分区副本中的-leader-如果宕机但-isr-却为空该如何处理" class="hash-link" aria-label="Direct link to 分区副本中的 Leader 如果宕机但 ISR 却为空该如何处理" title="Direct link to 分区副本中的 Leader 如果宕机但 ISR 却为空该如何处理">​</a></h3>
<p>可以通过配置unclean.leader.election ：</p>
<p>true：允许 OSR 成为 Leader，但是 OSR 的消息较为滞后，可能会出现消息不一致的问题
false：会一直等待旧 leader 恢复正常，降低了可用性</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何判断一个-broker-是否还有效">如何判断一个 Broker 是否还有效<a href="#如何判断一个-broker-是否还有效" class="hash-link" aria-label="Direct link to 如何判断一个 Broker 是否还有效" title="Direct link to 如何判断一个 Broker 是否还有效">​</a></h3>
<p>Broker必须可以维护和ZooKeeper的连接，Zookeeper通过心跳机制检查每个结点的连接。
如果Broker是个Follower，它必须能及时同步Leader的写操作，延时不能太久。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kafka-可接收的消息最大默认多少字节如何修改">Kafka 可接收的消息最大默认多少字节，如何修改<a href="#kafka-可接收的消息最大默认多少字节如何修改" class="hash-link" aria-label="Direct link to Kafka 可接收的消息最大默认多少字节，如何修改" title="Direct link to Kafka 可接收的消息最大默认多少字节，如何修改">​</a></h3>
<p>Kafka可以接收的最大消息默认为1000000字节，如果想调整它的大小，可在Broker中修改配置参数：Message.max.bytes的值</p>
<p>但要注意的是，修改这个值，还要同时注意其他对应的参数值是正确的，否则就可能引发一些系统异常。首先这个值要比消费端的fetch.Message.max.bytes（默认值1MB，表示消费者能读取的最大消息的字节数）参数值要小才是正确的设置，否则Broker就会因为消费端无法使用这个消息而挂起。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kafka-的-ack-机制">Kafka 的 ACK 机制<a href="#kafka-的-ack-机制" class="hash-link" aria-label="Direct link to Kafka 的 ACK 机制" title="Direct link to Kafka 的 ACK 机制">​</a></h3>
<p>Kafka的Producer有三种ack机制，参数值有0、1 和 -1</p>
<p>0： 相当于异步操作，Producer 不需要Leader给予回复，发送完就认为成功，继续发送下一条（批）Message。此机制具有最低延迟，但是持久性可靠性也最差，当服务器发生故障时，很可能发生数据丢失。<br>
<!-- -->1： Kafka 默认的设置。表示 Producer 要 Leader 确认已成功接收数据才发送下一条（批）Message。不过 Leader 宕机，Follower 尚未复制的情况下，数据就会丢失。此机制提供了较好的持久性和较低的延迟性。<br>
<!-- -->-1： Leader 接收到消息之后，还必须要求ISR列表里跟Leader保持同步的那些Follower都确认消息已同步，Producer 才发送下一条（批）Message。此机制持久性可靠性最好，但延时性最差。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kafka-的-consumer-如何消费数据">Kafka 的 consumer 如何消费数据<a href="#kafka-的-consumer-如何消费数据" class="hash-link" aria-label="Direct link to Kafka 的 consumer 如何消费数据" title="Direct link to Kafka 的 consumer 如何消费数据">​</a></h3>
<p>在Kafka中，Producers将消息推送给Broker端，在Consumer和Broker建立连接之后，会主动去 Pull（或者说Fetch）消息。这种模式有些优点，首先Consumer端可以根据自己的消费能力适时的去fetch消息并处理，且可以控制消息消费的进度（offset）；此外，消费者可以控制每次消费的数，实现批量消费。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kafka-提供的api有哪些">Kafka 提供的API有哪些<a href="#kafka-提供的api有哪些" class="hash-link" aria-label="Direct link to Kafka 提供的API有哪些" title="Direct link to Kafka 提供的API有哪些">​</a></h3>
<p>Kafka 提供了两套 Consumer API，分为 High-level API 和 Sample API</p>
<p>Sample API</p>
<p>这是一个底层API，它维持了一个与单一 Broker 的连接，并且这个API 是完全无状态的，每次请求都需要指定 offset 值，因此这套 API 也是最灵活的。</p>
<p>High-level API</p>
<p>该API封装了对集群中一系列Broker的访问，可以透明地消费下一个Topic，它自己维护了已消费消息的状态，即每次消费的都会下一个消息。High-level API 还支持以组的形式消费Topic，如果 Consumers 有同一个组名，那么Kafka就相当于一个队列消息服务，而各个 Consumer 均衡地消费相应Partition中的数据。若Consumers有不同的组名，那么此时Kafka就相当于一个广播服务，会把Topic中的所有消息广播到每个Consumer</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kafka-的topic中-partition-数据是怎么存储到磁盘的">Kafka 的Topic中 Partition 数据是怎么存储到磁盘的<a href="#kafka-的topic中-partition-数据是怎么存储到磁盘的" class="hash-link" aria-label="Direct link to Kafka 的Topic中 Partition 数据是怎么存储到磁盘的" title="Direct link to Kafka 的Topic中 Partition 数据是怎么存储到磁盘的">​</a></h3>
<p>Topic 中的多个 Partition 以文件夹的形式保存到 Broker，每个分区序号从0递增，且消息有序。Partition 文件下有多个Segment（xxx.index，xxx.log），Segment文件里的大小和配置文件大小一致。默认为1GB，但可以根据实际需要修改。如果大小大于1GB时，会滚动一个新的Segment并且以上一个Segment最后一条消息的偏移量命名。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kafka-创建topic后如何将分区放置到不同的-broker-中">Kafka 创建Topic后如何将分区放置到不同的 Broker 中<a href="#kafka-创建topic后如何将分区放置到不同的-broker-中" class="hash-link" aria-label="Direct link to Kafka 创建Topic后如何将分区放置到不同的 Broker 中" title="Direct link to Kafka 创建Topic后如何将分区放置到不同的 Broker 中">​</a></h3>
<p>Kafka创建Topic将分区放置到不同的Broker时遵循以下规则：</p>
<p>副本因子不能大于Broker的个数。
第一个分区（编号为0）的第一个副本放置位置是随机从Broker List中选择的。<br>
<!-- -->其他分区的第一个副本放置位置相对于第0个分区依次往后移。也就是如果有3个Broker，3个分区，假设第一个分区放在第二个Broker上，那么第二个分区将会放在第三个Broker上；第三个分区将会放在第一个Broker上，更多Broker与更多分区依此类推。剩余的副本相对于第一个副本放置位置其实是由nextReplicaShift决定的，而这个数也是随机产生的。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kafka-的日志保留期与数据清理策略">Kafka 的日志保留期与数据清理策略<a href="#kafka-的日志保留期与数据清理策略" class="hash-link" aria-label="Direct link to Kafka 的日志保留期与数据清理策略" title="Direct link to Kafka 的日志保留期与数据清理策略">​</a></h3>
<ul>
<li>
<p>概念<br>
<!-- -->保留期内保留了Kafka群集中的所有已发布消息，超过保期的数据将被按清理策略进行清理。默认保留时间是7天，如果想修改时间，在server.properties里更改参数log.retention.hours/minutes/ms 的值便可。</p>
</li>
<li>
<p>清理策略<br>
<!-- -->删除： log.cleanup.policy=delete 表示启用删除策略，这也是默认策略。一开始只是标记为delete，文件无法被索引。只有过了log.Segment.delete.delay.ms这个参数设置的时间，才会真正被删除。<br>
<!-- -->压缩： log.cleanup.policy=compact 表示启用压缩策略，将数据压缩，只保留每个Key最后一个版本的数据。首先在Broker的配置中设置log.cleaner.enable=true 启用 cleaner，这个默认是关闭的。</p>
</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kafka-日志存储的message是什么格式">Kafka 日志存储的Message是什么格式<a href="#kafka-日志存储的message是什么格式" class="hash-link" aria-label="Direct link to Kafka 日志存储的Message是什么格式" title="Direct link to Kafka 日志存储的Message是什么格式">​</a></h3>
<p>Kafka一个Message由固定长度的header和一个变长的消息体body组成。将Message存储在日志时采用不同于Producer发送的消息格式。每个日志文件都是一个log entries（日志项）序列：
每一个log entry包含一个四字节整型数（Message长度，值为1+4+N）。
1个字节的magic，magic表示本次发布Kafka服务程序协议版本号。<br>
<!-- -->4个字节的CRC32值，CRC32用于校验Message。<br>
<!-- -->最终是N个字节的消息数据。每条消息都有一个当前Partition下唯一的64位offset。<br>
<!-- -->Kafka没有限定单个消息的大小，但一般推荐消息大小不要超过1MB，通常一般消息大小都在1～10KB之间。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kafka-中如何进行主从同步">Kafka 中如何进行主从同步<a href="#kafka-中如何进行主从同步" class="hash-link" aria-label="Direct link to Kafka 中如何进行主从同步" title="Direct link to Kafka 中如何进行主从同步">​</a></h3>
<p>Kafka动态维护了一个同步状态的副本的集合（a set of In-SyncReplicas），简称ISR，在这个集合中的结点都是和Leader保持高度一致的，任何一条消息只有被这个集合中的每个结点读取并追加到日志中，才会向外部通知“这个消息已经被提交”。<br>
<!-- -->kafka 通过配置 producer.type 来确定是异步还是同步，默认是同步</p>
<ul>
<li>同步复制<br>
<!-- -->Producer 会先通过Zookeeper识别到Leader，然后向 Leader 发送消息，Leader 收到消息后写入到本地 log文件。这个时候Follower 再向 Leader Pull 消息，Pull 回来的消息会写入的本地 log 中，写入完成后会向 Leader 发送 Ack 回执，等到 Leader 收到所有 Follower 的回执之后，才会向 Producer 回传 Ack。</li>
<li>异步复制<br>
<!-- -->Kafka 中 Producer 异步发送消息是基于同步发送消息的接口来实现的，异步发送消息的实现很简单，客户端消息发送过来以后，会先放入一个 BlackingQueue 队列中然后就返回了。Producer 再开启一个线程 ProducerSendTread 不断从队列中取出消息，然后调用同步发送消息的接口将消息发送给 Broker。</li>
</ul>
<p>Producer的这种在内存缓存消息，当累计达到阀值时批量发送请求，小数据I/O太多，会拖慢整体的网络延迟，批量延迟发送事实上提升了网络效率。但是如果在达到阀值前，Producer不可用了，缓存的数据将会丢失。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kafka-中什么情况下会出现消息丢失不一致的问题">Kafka 中什么情况下会出现消息丢失/不一致的问题<a href="#kafka-中什么情况下会出现消息丢失不一致的问题" class="hash-link" aria-label="Direct link to Kafka 中什么情况下会出现消息丢失/不一致的问题" title="Direct link to Kafka 中什么情况下会出现消息丢失/不一致的问题">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="消息发送时">消息发送时<a href="#消息发送时" class="hash-link" aria-label="Direct link to 消息发送时" title="Direct link to 消息发送时">​</a></h4>
<p>消息发送有两种方式：同步 - sync 和 异步 - async。默认是同步的方式，可以通过 producer.type 属性进行配置，kafka 也可以通过配置 acks 属性来确认消息的生产</p>
<ul>
<li>0：表示不进行消息接收是否成功的确认</li>
<li>1：表示当 leader 接收成功时的确认</li>
<li>-1：表示 leader 和 follower 都接收成功的确认<br>
<!-- -->当 acks = 0 时，不和 Kafka 进行消息接收确认，可能会因为网络异常，缓冲区满的问题，导致消息丢失<br>
<!-- -->当 acks = 1 时，只有 leader 同步成功而 follower 尚未完成同步，如果 leader 挂了，就会造成数据丢失</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="消息消费时">消息消费时<a href="#消息消费时" class="hash-link" aria-label="Direct link to 消息消费时" title="Direct link to 消息消费时">​</a></h4>
<p>Kafka 有两个消息消费的 consumer 接口，分别是 low-level 和 hign-level<br>
<!-- -->low-level：消费者自己维护 offset 等值，可以实现对 kafka 的完全控制<br>
<!-- -->high-level：封装了对 partition 和 offset，使用简单<br>
<!-- -->如果使用高级接口，可能存在一个消费者提取了一个消息后便提交了 offset，那么还没来得及消费就已经挂了，下次消费时的数据就是 offset + 1 的位置，那么原先 offset 的数据就丢失了。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kafka-作为流处理平台的特点">Kafka 作为流处理平台的特点<a href="#kafka-作为流处理平台的特点" class="hash-link" aria-label="Direct link to Kafka 作为流处理平台的特点" title="Direct link to Kafka 作为流处理平台的特点">​</a></h3>
<p>流处理就是连续、实时、并发和以逐条记录的方式处理数据的意思。Kafka 是一个分布式流处理平台，它的高吞吐量、低延时、高可靠性、容错性、高可扩展性都使得Kafka非常适合作为流式平台。</p>
<p>它是一个简单的、轻量级的Java类库，能够被集成到任何Java应用中
除了Kafka之外没有任何其他的依赖，利用Kafka的分区模型支持水平扩容和保证顺序性
支持本地状态容错，可以执行非常快速有效的有状态操作
支持 eexactly-once 语义
支持一次处理一条记录，实现 ms 级的延迟</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="消费者故障出现活锁问题如何解决">消费者故障，出现活锁问题如何解决<a href="#消费者故障出现活锁问题如何解决" class="hash-link" aria-label="Direct link to 消费者故障，出现活锁问题如何解决" title="Direct link to 消费者故障，出现活锁问题如何解决">​</a></h3>
<p>活锁的概念：消费者持续的维持心跳，但没有进行消息处理。</p>
<p>为了预防消费者在这种情况一直持有分区，通常会利用 max.poll.interval.ms活跃检测机制，如果调用 Poll 的频率大于最大间隔，那么消费者将会主动离开消费组，以便其他消费者接管该分区</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kafa-中如何保证顺序消费">Kafa 中如何保证顺序消费<a href="#kafa-中如何保证顺序消费" class="hash-link" aria-label="Direct link to Kafa 中如何保证顺序消费" title="Direct link to Kafa 中如何保证顺序消费">​</a></h3>
<p>Kafka 的消费单元是 Partition，同一个 Partition 使用 offset 作为唯一标识保证顺序性，但这只是保证了在 Partition 内部的顺序性而不是 Topic 中的顺序，因此我们需要将所有消息发往统一 Partition 才能保证消息顺序消费，那么可以在发送的时候指定 MessageKey，同一个 key 的消息会发到同一个 Partition 中。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-tags-row"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a rel="tag" class="tag_zVej tagRegular_sFm0" href="/doc/docs/tags/interview">INTERVIEW</a></li><li class="tag_QGVx"><a rel="tag" class="tag_zVej tagRegular_sFm0" href="/doc/docs/tags/kafka">KAFKA</a></li><li class="tag_QGVx"><a rel="tag" class="tag_zVej tagRegular_sFm0" href="/doc/docs/tags/mq">MQ</a></li></ul></div></div><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/MQ/kafka-review.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/doc/docs/INTERVIEW/JAVA/JAVA-BASE"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">JAVA-BASE</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/doc/docs/INTERVIEW/MQ"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">ROCKETMQ_REVIEW</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#kafka-的设计" class="table-of-contents__link toc-highlight">Kafka 的设计？</a></li><li><a href="#kafka-性能高原因" class="table-of-contents__link toc-highlight">Kafka 性能高原因</a></li><li><a href="#kafka-文件高效存储设计原理" class="table-of-contents__link toc-highlight">Kafka 文件高效存储设计原理</a></li><li><a href="#kafka-的优缺点" class="table-of-contents__link toc-highlight">Kafka 的优缺点</a></li><li><a href="#kafka-的应用场景" class="table-of-contents__link toc-highlight">Kafka 的应用场景</a></li><li><a href="#kafka-中分区的概念" class="table-of-contents__link toc-highlight">Kafka 中分区的概念</a></li><li><a href="#kafka-中分区的原则" class="table-of-contents__link toc-highlight">Kafka 中分区的原则</a></li><li><a href="#kafka-为什么要把消息分区" class="table-of-contents__link toc-highlight">Kafka 为什么要把消息分区</a></li><li><a href="#kafka-中生产者运行流程" class="table-of-contents__link toc-highlight">Kafka 中生产者运行流程</a></li><li><a href="#kafka-中的消息封装" class="table-of-contents__link toc-highlight">Kafka 中的消息封装</a></li><li><a href="#kafka-消息的消费模式" class="table-of-contents__link toc-highlight">Kafka 消息的消费模式</a></li><li><a href="#kafka-如何实现负载均衡与故障转移" class="table-of-contents__link toc-highlight">Kafka 如何实现负载均衡与故障转移</a></li><li><a href="#故障转移" class="table-of-contents__link toc-highlight">故障转移</a></li><li><a href="#kafka-中-zookeeper-的作用" class="table-of-contents__link toc-highlight">Kafka 中 Zookeeper 的作用</a></li><li><a href="#kafka-中消费者与消费者组的关系与负载均衡实现" class="table-of-contents__link toc-highlight">Kafka 中消费者与消费者组的关系与负载均衡实现</a></li><li><a href="#kafka-中消息偏移的作用" class="table-of-contents__link toc-highlight">Kafka 中消息偏移的作用</a></li><li><a href="#生产过程中何时会发生queuefullexpection以及如何处理" class="table-of-contents__link toc-highlight">生产过程中何时会发生QueueFullExpection以及如何处理</a></li><li><a href="#consumer-如何消费指定分区消息" class="table-of-contents__link toc-highlight">Consumer 如何消费指定分区消息</a></li><li><a href="#replicaleader-和-follower-三者的概念" class="table-of-contents__link toc-highlight">Replica、Leader 和 Follower 三者的概念</a></li><li><a href="#replica-的重要性" class="table-of-contents__link toc-highlight">Replica 的重要性</a></li><li><a href="#kafka-中-arisrosr-三者的概念" class="table-of-contents__link toc-highlight">Kafka 中 AR、ISR、OSR 三者的概念</a></li><li><a href="#分区副本什么情况下会从-isr-中剔出" class="table-of-contents__link toc-highlight">分区副本什么情况下会从 ISR 中剔出</a></li><li><a href="#分区副本中的-leader-如果宕机但-isr-却为空该如何处理" class="table-of-contents__link toc-highlight">分区副本中的 Leader 如果宕机但 ISR 却为空该如何处理</a></li><li><a href="#如何判断一个-broker-是否还有效" class="table-of-contents__link toc-highlight">如何判断一个 Broker 是否还有效</a></li><li><a href="#kafka-可接收的消息最大默认多少字节如何修改" class="table-of-contents__link toc-highlight">Kafka 可接收的消息最大默认多少字节，如何修改</a></li><li><a href="#kafka-的-ack-机制" class="table-of-contents__link toc-highlight">Kafka 的 ACK 机制</a></li><li><a href="#kafka-的-consumer-如何消费数据" class="table-of-contents__link toc-highlight">Kafka 的 consumer 如何消费数据</a></li><li><a href="#kafka-提供的api有哪些" class="table-of-contents__link toc-highlight">Kafka 提供的API有哪些</a></li><li><a href="#kafka-的topic中-partition-数据是怎么存储到磁盘的" class="table-of-contents__link toc-highlight">Kafka 的Topic中 Partition 数据是怎么存储到磁盘的</a></li><li><a href="#kafka-创建topic后如何将分区放置到不同的-broker-中" class="table-of-contents__link toc-highlight">Kafka 创建Topic后如何将分区放置到不同的 Broker 中</a></li><li><a href="#kafka-的日志保留期与数据清理策略" class="table-of-contents__link toc-highlight">Kafka 的日志保留期与数据清理策略</a></li><li><a href="#kafka-日志存储的message是什么格式" class="table-of-contents__link toc-highlight">Kafka 日志存储的Message是什么格式</a></li><li><a href="#kafka-中如何进行主从同步" class="table-of-contents__link toc-highlight">Kafka 中如何进行主从同步</a></li><li><a href="#kafka-中什么情况下会出现消息丢失不一致的问题" class="table-of-contents__link toc-highlight">Kafka 中什么情况下会出现消息丢失/不一致的问题</a></li><li><a href="#kafka-作为流处理平台的特点" class="table-of-contents__link toc-highlight">Kafka 作为流处理平台的特点</a></li><li><a href="#消费者故障出现活锁问题如何解决" class="table-of-contents__link toc-highlight">消费者故障，出现活锁问题如何解决</a></li><li><a href="#kafa-中如何保证顺序消费" class="table-of-contents__link toc-highlight">Kafa 中如何保证顺序消费</a></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/doc/docs/intro">Tutorial</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://x.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">X<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/doc/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>