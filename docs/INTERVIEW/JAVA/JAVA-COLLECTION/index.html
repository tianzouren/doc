<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-JAVA/JAVA-COLLECTION" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.8.1">
<title data-rh="true">JAVA-COLLECTION | My Site</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://your-docusaurus-site.example.com/doc/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://your-docusaurus-site.example.com/doc/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://your-docusaurus-site.example.com/doc/docs/INTERVIEW/JAVA/JAVA-COLLECTION"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="JAVA-COLLECTION | My Site"><meta data-rh="true" name="description" content="JAVA-COLLECTION"><meta data-rh="true" property="og:description" content="JAVA-COLLECTION"><link data-rh="true" rel="icon" href="/doc/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://your-docusaurus-site.example.com/doc/docs/INTERVIEW/JAVA/JAVA-COLLECTION"><link data-rh="true" rel="alternate" href="https://your-docusaurus-site.example.com/doc/docs/INTERVIEW/JAVA/JAVA-COLLECTION" hreflang="en"><link data-rh="true" rel="alternate" href="https://your-docusaurus-site.example.com/doc/docs/INTERVIEW/JAVA/JAVA-COLLECTION" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"java","item":"https://your-docusaurus-site.example.com/doc/docs/JAVA/"},{"@type":"ListItem","position":2,"name":"JAVA-COLLECTION","item":"https://your-docusaurus-site.example.com/doc/docs/INTERVIEW/JAVA/JAVA-COLLECTION"}]}</script><link rel="alternate" type="application/rss+xml" href="/doc/blog/rss.xml" title="My Site RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/doc/blog/atom.xml" title="My Site Atom Feed"><link rel="stylesheet" href="/doc/assets/css/styles.8d5b4fe0.css">
<script src="/doc/assets/js/runtime~main.76c25152.js" defer="defer"></script>
<script src="/doc/assets/js/main.2ba6fd96.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t="light";var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",e||t),document.documentElement.setAttribute("data-theme-choice",e||t)}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/doc/img/logo.svg"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/doc/"><div class="navbar__logo"><img src="/doc/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/doc/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">My Site</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/doc/docs/intro">Tutorial</a><a class="navbar__item navbar__link" href="/doc/blog">Blog</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="Switch between dark and light mode (currently system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/doc/docs/intro">Tutorial Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/doc/docs/category/tutorial---basics">Tutorial - Basics</a><button aria-label="Expand sidebar category &#x27;Tutorial - Basics&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/doc/docs/category/tutorial---extras">Tutorial - Extras</a><button aria-label="Expand sidebar category &#x27;Tutorial - Extras&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/doc/docs/JAVA/">java</a><button aria-label="Collapse sidebar category &#x27;java&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/doc/docs/INTERVIEW/JAVA/JAVA-AQS">JAVA-AQS</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/doc/docs/INTERVIEW/JAVA/JVM">JAVA-JVM</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/doc/docs/INTERVIEW/JAVA/JAVA-COLLECTION">JAVA-COLLECTION</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/doc/docs/INTERVIEW/JAVA/JAVA-JUC">JAVA-JUC</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/doc/docs/INTERVIEW/JAVA/JAVA-BASE">JAVA-BASE</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/MQ">MQ</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/MYSQL/MYSQL-REVIEW">MYSQL</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/NGINX/NGINX-REVIEW">NGINX</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/intereview/redis">REDIS</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/SPRING/SPRING-REVIEW">SPRING</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/doc/docs/tmp">tmp</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/分布式/分布式-REVIEW">分布式</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/微服务/微服务-REVIEW">微服务</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/doc/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><a class="breadcrumbs__link" href="/doc/docs/JAVA/"><span>java</span></a></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">JAVA-COLLECTION</span></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>JAVA-COLLECTION</h1></header><h2 class="anchor anchorWithStickyNavbar_LWe7" id="基础语法">基础语法<a href="#基础语法" class="hash-link" aria-label="Direct link to 基础语法" title="Direct link to 基础语法">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说有哪些常见的集合框架">🌟说说有哪些常见的集合框架？<a href="#说说有哪些常见的集合框架" class="hash-link" aria-label="Direct link to 🌟说说有哪些常见的集合框架？" title="Direct link to 🌟说说有哪些常见的集合框架？">​</a></h3>
<p>推荐阅读：二哥的 Java 进阶之路：Java 集合框架
推荐阅读：阻塞队列 BlockingQueue。
<img decoding="async" loading="lazy" alt="集合继承关系" src="/doc/assets/images/集合继承关系-3dc7e16339d94d3d1ba1545f310c0f93.png" width="1240" height="572" class="img_ev3q">
集合框架可以分为两条大的支线：
①、第一条支线 Collection，主要由 List、Set、Queue 组成：
List 代表有序、可重复的集合，典型代表就是封装了动态数组的 ArrayList 和封装了链表的 LinkedList；
Set 代表无序、不可重复的集合，典型代表就是 HashSet 和 TreeSet；
Queue 代表队列，典型代表就是双端队列 ArrayDeque，以及优先级队列 PriorityQueue。</p>
<p>②、第二条支线 Map，代表键值对的集合，典型代表就是 HashMap。</p>
<p>另外一个回答版本：
①、Collection 接口：最基本的集合框架表示方式，提供了添加、删除、清空等基本操作，它主要有三个子接口：
List：一个有序的集合，可以包含重复的元素。实现类包括 ArrayList、LinkedList 等。
Set：一个不包含重复元素的集合。实现类包括 HashSet、LinkedHashSet、TreeSet 等。
Queue：一个用于保持元素队列的集合。实现类包括 PriorityQueue、ArrayDeque 等。
②、Map 接口：表示键值对的集合，一个键映射到一个值。键不能重复，每个键只能对应一个值。Map 接口的实现类包括 HashMap、LinkedHashMap、TreeMap 等</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="集合框架有哪几个常用工具类">集合框架有哪几个常用工具类？<a href="#集合框架有哪几个常用工具类" class="hash-link" aria-label="Direct link to 集合框架有哪几个常用工具类？" title="Direct link to 集合框架有哪几个常用工具类？">​</a></h3>
<p>集合框架位于 java.util 包下，提供了两个常用的工具类：
Collections：提供了一些对集合进行排序、二分查找、同步的静态方法。
Arrays：提供了一些对数组进行排序、打印、和 List 进行转换的静态方法。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="简单介绍一下队列">简单介绍一下队列<a href="#简单介绍一下队列" class="hash-link" aria-label="Direct link to 简单介绍一下队列" title="Direct link to 简单介绍一下队列">​</a></h3>
<p>Java 中的队列主要通过 Queue 接口和并发包下的 BlockingQueue 两个接口来实现。</p>
<p>优先级队列 PriorityQueue 实现了 Queue 接口，是一个无界队列，它的元素按照自然顺序排序或者 Comparator 比较器进行排序。
<img decoding="async" loading="lazy" alt="PriorityQueue结构" src="/doc/assets/images/PriorityQueue结构-2d2ef198362404830da7313912aee833.png" width="1200" height="1088" class="img_ev3q">
双端队列 ArrayDeque 也实现了 Queue 接口，是一个基于数组的，可以在两端插入和删除元素的队列。
<img decoding="async" loading="lazy" alt="ArrayDeque结构" src="/doc/assets/images/ArrayDeque结构-3d81977c442b2f7b4272c53d6b6cced9.png" width="800" height="496" class="img_ev3q">
LinkedList 实现了 Queue 接口的子类 Deque，所以也可以当做双端队列来使用。
<img decoding="async" loading="lazy" alt="LinkedList结构" src="/doc/assets/images/LinkedList结构-03d0aad0ae9300093f8f6d3dcbb6059f.png" width="1194" height="1170" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="用过哪些集合类它们的优劣">用过哪些集合类，它们的优劣？<a href="#用过哪些集合类它们的优劣" class="hash-link" aria-label="Direct link to 用过哪些集合类，它们的优劣？" title="Direct link to 用过哪些集合类，它们的优劣？">​</a></h3>
<p>我常用的集合类有 ArrayList、LinkedList、HashMap、LinkedHashMap。
ArrayList 可以看作是一个动态数组，可以在需要时动态扩容数组的容量，只不过需要复制元素到新的数组。优点是访问速度快，可以通过索引直接查找到元素。缺点是插入和删除元素可能需要移动或者复制元素。
LinkedList 是一个双向链表，适合频繁的插入和删除操作。优点是插入和删除元素的时候只需要改变节点的前后指针，缺点是访问元素时需要遍历链表。
HashMap 是一个基于哈希表的键值对集合。优点是可以根据键的哈希值快速查找到值，但有可能会发生哈希冲突，并且不保留键值对的插入顺序。
LinkedHashMap 在 HashMap 的基础上增加了一个双向链表来保持键值对的插入顺序。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="队列和栈的区别了解吗">队列和栈的区别了解吗？<a href="#队列和栈的区别了解吗" class="hash-link" aria-label="Direct link to 队列和栈的区别了解吗？" title="Direct link to 队列和栈的区别了解吗？">​</a></h3>
<p>队列是一种先进先出（FIFO, First-In-First-Out）的数据结构，第一个加入队列的元素会成为第一个被移除的元素。
<img decoding="async" loading="lazy" alt="队列" src="/doc/assets/images/队列-83b6015962b0a60d6799f471bc4f9705.png" width="863" height="522" class="img_ev3q">
栈是一种后进先出（LIFO, Last-In-First-Out）的数据结构，最后一个加入栈的元素会成为第一个被移除的元素。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="哪些是线程安全的容器">哪些是线程安全的容器？<a href="#哪些是线程安全的容器" class="hash-link" aria-label="Direct link to 哪些是线程安全的容器？" title="Direct link to 哪些是线程安全的容器？">​</a></h3>
<p>像 Vector、Hashtable、ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentLinkedQueue、ArrayBlockingQueue、LinkedBlockingQueue 都是线程安全的。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="collection-继承了哪些接口">Collection 继承了哪些接口？<a href="#collection-继承了哪些接口" class="hash-link" aria-label="Direct link to Collection 继承了哪些接口？" title="Direct link to Collection 继承了哪些接口？">​</a></h3>
<p>Collection 继承了 Iterable 接口，这意味着所有实现 Collection 接口的类都必须实现 iterator() 方法，之后就可以使用增强型 for 循环遍历集合中的元素了。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="list">List<a href="#list" class="hash-link" aria-label="Direct link to List" title="Direct link to List">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="arraylist-和-linkedlist-有什么区别">🌟ArrayList 和 LinkedList 有什么区别？<a href="#arraylist-和-linkedlist-有什么区别" class="hash-link" aria-label="Direct link to 🌟ArrayList 和 LinkedList 有什么区别？" title="Direct link to 🌟ArrayList 和 LinkedList 有什么区别？">​</a></h3>
<p>推荐阅读：二哥的 Java 进阶之路：ArrayList 和 LinkedList
ArrayList 是基于数组实现的，LinkedList 是基于链表实现的。
<img decoding="async" loading="lazy" alt="ArrayList结构" src="/doc/assets/images/ArrayList结构-cb3181d87434ffc99418eed7bf6d7027.png" width="1042" height="427" class="img_ev3q">
ArrayList 和 LinkedList 的用途有什么不同？
多数情况下，ArrayList 更利于查找，LinkedList 更利于增删。
①、由于 ArrayList 是基于数组实现的，所以 get(int index) 可以直接通过数组下标获取，时间复杂度是 O(1)；LinkedList 是基于链表实现的，get(int index) 需要遍历链表，时间复杂度是 O(n)。
当然，get(E element) 这种查找，两种集合都需要遍历通过 equals 比较获取元素，所以时间复杂度都是 O(n)。
②、ArrayList 如果增删的是数组的尾部，时间复杂度是 O(1)；如果 add 的时候涉及到扩容，时间复杂度会上升到 O(n)。
但如果插入的是中间的位置，就需要把插入位置后的元素向前或者向后移动，甚至还有可能触发扩容，效率就会低很多，变成 O(n)。
<img decoding="async" loading="lazy" alt="ArrayList插入数据" src="/doc/assets/images/ArrayList插入数据-1abeffc88a0940ed44e7d3f9cf2865d0.png" width="923" height="667" class="img_ev3q"></p>
<p>LinkedList 因为是链表结构，插入和删除只需要改变前置节点、后置节点和插入节点的引用，因此不需要移动元素。
如果是在链表的头部插入或者删除，时间复杂度是 O(1)；如果是在链表的中间插入或者删除，时间复杂度是 O(n)，因为需要遍历链表找到插入位置；如果是在链表的尾部插入或者删除，时间复杂度是 O(1)。
ps: 适合头尾进行节点修改的场景， 比如lru缓存
<img decoding="async" loading="lazy" alt="LinkedList插入数据" src="/doc/assets/images/LinkedList插入数据-7d9e958f03cb37286a68cae8ad64427e.png" width="925" height="649" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="arraylist-和-linkedlist-是否支持随机访问">ArrayList 和 LinkedList 是否支持随机访问？<a href="#arraylist-和-linkedlist-是否支持随机访问" class="hash-link" aria-label="Direct link to ArrayList 和 LinkedList 是否支持随机访问？" title="Direct link to ArrayList 和 LinkedList 是否支持随机访问？">​</a></h3>
<p>①、ArrayList 是基于数组的，也实现了 RandomAccess 接口，所以它支持随机访问，可以通过下标直接获取元素。
②、LinkedList 是基于链表的，所以它没法根据下标直接获取元素，不支持随机访问。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="arraylist-和-linkedlist-内存占用有何不同">ArrayList 和 LinkedList 内存占用有何不同？<a href="#arraylist-和-linkedlist-内存占用有何不同" class="hash-link" aria-label="Direct link to ArrayList 和 LinkedList 内存占用有何不同？" title="Direct link to ArrayList 和 LinkedList 内存占用有何不同？">​</a></h3>
<p>ArrayList 是基于数组的，是一块连续的内存空间，所以它的内存占用是比较紧凑的；但如果涉及到扩容，就会重新分配内存，空间是原来的 1.5 倍。
LinkedList 是基于链表的，每个节点都有一个指向下一个节点和上一个节点的引用，于是每个节点占用的内存空间比 ArrayList 稍微大一点</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="arraylist-和-linkedlist-的使用场景有什么不同">ArrayList 和 LinkedList 的使用场景有什么不同？<a href="#arraylist-和-linkedlist-的使用场景有什么不同" class="hash-link" aria-label="Direct link to ArrayList 和 LinkedList 的使用场景有什么不同？" title="Direct link to ArrayList 和 LinkedList 的使用场景有什么不同？">​</a></h3>
<ol>
<li>
<p>ArrayList 适用于：
随机访问频繁：需要频繁通过索引访问元素的场景。
读取操作远多于写入操作：如存储不经常改变的列表。
末尾添加元素：需要频繁在列表末尾添加元素的场景。</p>
</li>
<li>
<p>LinkedList 适用于：
频繁插入和删除：在列表中间频繁插入和删除元素的场景。
不需要快速随机访问：顺序访问多于随机访问的场景。
队列和栈：由于其双向链表的特性，LinkedList 可以实现队列（FIFO）和栈（LIFO）。</p>
</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="链表和数组有什么区别">链表和数组有什么区别？<a href="#链表和数组有什么区别" class="hash-link" aria-label="Direct link to 链表和数组有什么区别？" title="Direct link to 链表和数组有什么区别？">​</a></h3>
<p>数组在内存中占用的是一块连续的存储空间，因此我们可以通过数组下标快速访问任意元素。数组在创建时必须指定大小，一旦分配内存，数组的大小就固定了。
链表的元素存储在于内存中的任意位置，每个节点通过指针指向下一个节点。
<img decoding="async" loading="lazy" alt="链表和数组的区别" src="/doc/assets/images/链表和数组的区别-bb6d4b621c1b4eae653b1ecb101abb35.png" width="1404" height="626" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="arraylist-的扩容机制了解吗">ArrayList 的扩容机制了解吗？<a href="#arraylist-的扩容机制了解吗" class="hash-link" aria-label="Direct link to ArrayList 的扩容机制了解吗？" title="Direct link to ArrayList 的扩容机制了解吗？">​</a></h3>
<p>了解。当往 ArrayList 中添加元素时，会先检查是否需要扩容，如果当前容量+1 超过数组长度，就会进行扩容。
扩容后的新数组长度是原来的 1.5 倍，然后再把原数组的值拷贝到新数组中。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="arraylist-怎么序列化的知道吗">ArrayList 怎么序列化的知道吗？<a href="#arraylist-怎么序列化的知道吗" class="hash-link" aria-label="Direct link to ArrayList 怎么序列化的知道吗？" title="Direct link to ArrayList 怎么序列化的知道吗？">​</a></h3>
<p>在 ArrayList 中，writeObject 方法被重写了，用于自定义序列化逻辑：只序列化有效数据，因为 elementData 数组的容量一般大于实际的元素数量，声明的时候也加了 transient 关键字。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么-arraylist-不直接序列化元素数组呢">为什么 ArrayList 不直接序列化元素数组呢？<a href="#为什么-arraylist-不直接序列化元素数组呢" class="hash-link" aria-label="Direct link to 为什么 ArrayList 不直接序列化元素数组呢？" title="Direct link to 为什么 ArrayList 不直接序列化元素数组呢？">​</a></h3>
<p>出于效率的考虑，数组可能长度 100，但实际只用了 50，剩下的 50 没用到，也就不需要序列化。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private void writeObject(java.io.ObjectOutputStream s)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    throws java.io.IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 将当前 ArrayList 的结构进行序列化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int expectedModCount = modCount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s.defaultWriteObject(); // 序列化非 transient 字段</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 序列化数组的大小</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s.writeInt(size);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 序列化每个元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; size; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        s.writeObject(elementData[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 检查是否在序列化期间发生了并发修改</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (modCount != expectedModCount) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new ConcurrentModificationException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="快速失败fail-fast了解吗">快速失败fail-fast了解吗？<a href="#快速失败fail-fast了解吗" class="hash-link" aria-label="Direct link to 快速失败fail-fast了解吗？" title="Direct link to 快速失败fail-fast了解吗？">​</a></h3>
<p>fail—fast 是 Java 集合的一种错误检测机制。
在用迭代器遍历集合对象时，如果线程 A 遍历过程中，线程 B 对集合对象的内容进行了修改，就会抛出 Concurrent Modification Exception。
迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。
每当迭代器使用 hashNext()/next()遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。
异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改 modCount 值刚好又设置为了 expectedmodCount 值，则异常不会抛出。
因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的 bug。
java.util 包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改），比如 ArrayList 类。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是安全失败failsafe呢">什么是安全失败（fail—safe）呢？<a href="#什么是安全失败failsafe呢" class="hash-link" aria-label="Direct link to 什么是安全失败（fail—safe）呢？" title="Direct link to 什么是安全失败（fail—safe）呢？">​</a></h3>
<p><strong>没问过</strong>
采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。
原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发 Concurrent Modification Exception。
缺点：基于拷贝内容的优点是避免了 Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。
场景：java.util.concurrent 包下的容器都是安全失败，可以在多线程下并发使用，并发修改，比如 CopyOnWriteArrayList 类。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="有哪几种实现-arraylist-线程安全的方法">有哪几种实现 ArrayList 线程安全的方法？<a href="#有哪几种实现-arraylist-线程安全的方法" class="hash-link" aria-label="Direct link to 有哪几种实现 ArrayList 线程安全的方法？" title="Direct link to 有哪几种实现 ArrayList 线程安全的方法？">​</a></h3>
<p>常用的有两种。
可以使用 Collections.synchronizedList() 方法，它可以返回一个线程安全的 List。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">SynchronizedList list = Collections.synchronizedList(new ArrayList());</span><br></span></code></pre></div></div>
<p>内部是通过 synchronized 关键字加锁来实现的。
也可以直接使用 CopyOnWriteArrayList，它是线程安全的 ArrayList，遵循写时复制的原则，
每当对列表进行修改时，都会创建一个新副本，这个新副本会替换旧的列表，而对旧列表的所有读取操作仍然在原有的列表上进行。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">CopyOnWriteArrayList list = new CopyOnWriteArrayList();</span><br></span></code></pre></div></div>
<p>通俗的讲，CopyOnWrite 就是当我们往一个容器添加元素的时候，不直接往容器中添加，而是先复制出一个新的容器，然后在新的容器里添加元素，添加完之后，再将原容器的引用指向新的容器。多个线程在读的时候，不需要加锁，因为当前容器不会添加任何元素。这样就实现了线程安全。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="arraylist-和-vector-的区别">ArrayList 和 Vector 的区别？<a href="#arraylist-和-vector-的区别" class="hash-link" aria-label="Direct link to ArrayList 和 Vector 的区别？" title="Direct link to ArrayList 和 Vector 的区别？">​</a></h3>
<p>Vector 属于 JDK 1.0 时期的遗留类，不推荐使用，仍然保留着是因为 Java 希望向后兼容。
ArrayList 是在 JDK 1.2 时引入的，用于替代 Vector 作为主要的非同步动态数组实现。因为 Vector 所有的方法都使用了 synchronized 关键字进行同步，所以单线程环境下效率较低。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="copyonwritearraylist-了解多少">CopyOnWriteArrayList 了解多少？<a href="#copyonwritearraylist-了解多少" class="hash-link" aria-label="Direct link to CopyOnWriteArrayList 了解多少？" title="Direct link to CopyOnWriteArrayList 了解多少？">​</a></h3>
<p>CopyOnWriteArrayList 就是线程安全版本的 ArrayList。
CopyOnWrite——写时复制，已经明示了它的原理。
CopyOnWriteArrayList 采用了一种读写分离的并发策略。CopyOnWriteArrayList 容器允许并发读，读操作是无锁的。至于写操作，比如说向容器中添加一个元素，首先将当前容器复制一份，然后在新副本上执行写操作，结束之后再将原容器的引用指向新容器。
<img decoding="async" loading="lazy" alt="CopyOnWriteArrayList" src="/doc/assets/images/CopyOnWriteArrayList-12d3f9a5718dc95a833e8711710394cd.png" width="1140" height="619" class="img_ev3q"></p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private transient volatile Object[] array;</span><br></span></code></pre></div></div>
<p>ps：
可见性：写线程对数组引用的修改能立即对所有读线程可见。<br>
<!-- -->有序性：防止指令重排序，确保新数组完全准备就绪后，才会替换旧的引用，避免读线程看到构造中的中间状态</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="map">Map<a href="#map" class="hash-link" aria-label="Direct link to Map" title="Direct link to Map">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="能说一下-hashmap-的底层数据结构吗">🌟能说一下 HashMap 的底层数据结构吗？<a href="#能说一下-hashmap-的底层数据结构吗" class="hash-link" aria-label="Direct link to 🌟能说一下 HashMap 的底层数据结构吗？" title="Direct link to 🌟能说一下 HashMap 的底层数据结构吗？">​</a></h3>
<p>推荐阅读：二哥的 Java 进阶之路：详解 HashMap
JDK 8 中 HashMap 的数据结构是数组+链表+红黑树。
<img decoding="async" loading="lazy" alt="HashMap结构" src="/doc/assets/images/HashMap结构-79d612d3a73bc63dd83760258f6d581f.png" width="1116" height="593" class="img_ev3q">
数组用来存储键值对，每个键值对可以通过索引直接拿到，索引是通过对键的哈希值进行进一步的 hash() 处理得到的。<br>
<!-- -->当多个键经过哈希处理后得到相同的索引时，需要通过链表来解决哈希冲突——将具有相同索引的键值对通过链表存储起来。<br>
<!-- -->不过，链表过长时，查询效率会比较低，于是当链表的长度超过 8 时（且数组的长度大于 64），链表就会转换为红黑树。红黑树的查询效率是 O(logn)，比链表的 O(n) 要快。<br>
<!-- -->hash() 方法的目标是尽量减少哈希冲突，保证元素能够均匀地分布在数组的每个位置上。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static final int hash(Object key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int h;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>如果键的哈希值已经在数组中存在，其对应的值将被新值覆盖。
HashMap 的初始容量是 16，随着元素的不断添加，HashMap 就需要进行扩容，阈值是capacity * loadFactor，capacity 为容量，loadFactor 为负载因子，默认为 0.75。
扩容后的数组大小是原来的 2 倍，然后把原来的元素重新计算哈希值，放到新的数组中。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="你对红黑树了解多少">你对红黑树了解多少？<a href="#你对红黑树了解多少" class="hash-link" aria-label="Direct link to 你对红黑树了解多少？" title="Direct link to 你对红黑树了解多少？">​</a></h3>
<p>红黑树是一种自平衡的二叉查找树：
每个节点要么是红色，要么是黑色；
根节点永远是黑色；
所有的叶子节点都是是黑色的（下图中的 NULL 节点）；
红色节点的子节点一定是黑色的；
从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。
<img decoding="async" loading="lazy" alt="红黑树" src="/doc/assets/images/红黑树-e0626cee546763acd82039866e34207a.png" width="734" height="406" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么不用二叉树">为什么不用二叉树？<a href="#为什么不用二叉树" class="hash-link" aria-label="Direct link to 为什么不用二叉树？" title="Direct link to 为什么不用二叉树？">​</a></h3>
<p>二叉树是最基本的树结构，每个节点最多有两个子节点，但是二叉树容易出现极端情况，比如插入的数据是有序的，那么二叉树就会退化成链表，查询效率就会变成 O(n)。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么不用平衡二叉树">为什么不用平衡二叉树？<a href="#为什么不用平衡二叉树" class="hash-link" aria-label="Direct link to 为什么不用平衡二叉树？" title="Direct link to 为什么不用平衡二叉树？">​</a></h3>
<p>平衡二叉树比红黑树的要求更高，每个节点的左右子树的高度最多相差 1，这种高度的平衡保证了极佳的查找效率，但在进行插入和删除操作时，可能需要频繁地进行旋转来维持树的平衡，维护成本更高</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么用红黑树">为什么用红黑树？<a href="#为什么用红黑树" class="hash-link" aria-label="Direct link to 为什么用红黑树？" title="Direct link to 为什么用红黑树？">​</a></h3>
<p>链表的查找时间复杂度是 O(n)，当链表长度较长时，查找性能会下降。红黑树是一种折中的方案，查找、插入、删除的时间复杂度都是 O(log n)。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="红黑树怎么保持平衡的">红黑树怎么保持平衡的？<a href="#红黑树怎么保持平衡的" class="hash-link" aria-label="Direct link to 红黑树怎么保持平衡的？" title="Direct link to 红黑树怎么保持平衡的？">​</a></h3>
<p>旋转和染色。
①、通过左旋和右旋来调整树的结构，避免某一侧过深。
<img decoding="async" loading="lazy" alt="左旋" src="/doc/assets/images/左旋-bb1c397d7797dfd352eaaa67b28f315d.png" width="700" height="271" class="img_ev3q">
<img decoding="async" loading="lazy" alt="右旋" src="/doc/assets/images/右旋-024f0ac0653607b7731657e9731c7afb.png" width="701" height="298" class="img_ev3q">
②、染⾊，修复红黑规则，从而保证树的高度不会失衡。
<img decoding="async" loading="lazy" alt="染⾊，修复红黑" src="/doc/assets/images/染⾊，修复红黑-29544bf022dd95511ebbe8633d4e45c8.png" width="811" height="339" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="hashmap-的-put-流程知道吗">🌟HashMap 的 put 流程知道吗？<a href="#hashmap-的-put-流程知道吗" class="hash-link" aria-label="Direct link to 🌟HashMap 的 put 流程知道吗？" title="Direct link to 🌟HashMap 的 put 流程知道吗？">​</a></h3>
<p>哈希寻址 → 处理哈希冲突（链表还是红黑树） → 插入/覆盖节点 → 判断是否需要扩容。
<img decoding="async" loading="lazy" alt="HashMap的put过程" src="/doc/assets/images/HashMap的put过程-dc7979f648faede3c94e934c7f601677.png" width="1346" height="1416" class="img_ev3q">
详细版：
第一步，通过 hash 方法进一步扰动哈希值，以减少哈希冲突。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static final int hash(Object key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int h;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>第二步，进行第一次的数组扩容；并使用哈希值和数组长度进行取模运算，确定索引位置。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">if ((tab = table) == null || (n = tab.length) == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">n = (tab = resize()).length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">tab[i] = newNode(hash, key, value, null);</span><br></span></code></pre></div></div>
<p>如果当前位置为空，直接将键值对插入该位置；<br>
<!-- -->否则判断当前位置的第一个节点是否与新节点的 key 相同，如果相同直接覆盖 value，如果不同，说明发生哈希冲突。<br>
<!-- -->否则判断节点的类型<br>
<!-- -->如果是链表，将新节点添加到链表的尾部；<br>
<!-- -->如果是红黑树，将加入到红黑树节点中；<br>
<!-- -->ps: 当链表长度 ≥ 8 且 数组长度 ≥ MIN_TREEIFY_CAPACITY = 64时，<br>
<!-- -->链表转为红黑树。如果节点红黑树节点 小于等于  6,红黑树转回链表</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public V put(K key, V value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">return putVal(hash(key), key, value, false, true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 如果 table 为空，先进行初始化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if ((tab = table) == null || (n = tab.length) == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">n = (tab = resize()).length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 计算索引位置，并找到对应的桶</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        tab[i] = newNode(hash, key, value, null); // 如果桶为空，直接插入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Node&lt;K,V&gt; e; K k;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 检查第一个节点是否匹配</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e = p; // 覆盖</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果是树节点，放入树中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else if (p instanceof TreeNode)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果是链表，遍历插入到尾部</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int binCount = 0; ; ++binCount) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if ((e = p.next) == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    p.next = newNode(hash, key, value, null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果链表长度达到阈值，转换为红黑树</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        treeifyBin(tab, hash);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break; // 覆盖</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                p = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (e != null) { // 如果找到匹配的 key，则覆盖旧值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            V oldValue = e.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!onlyIfAbsent || oldValue == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e.value = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            afterNodeAccess(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return oldValue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ++modCount; // 修改计数器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (++size &gt; threshold)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        resize(); // 检查是否需要扩容</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    afterNodeInsertion(evict);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>每次插入新元素后，检查是否需要扩容，如果当前元素个数大于阈值（capacity * loadFactor），则进行扩容，扩容后的数组大小是原来的 2 倍；并且重新计算每个节点的索引，进行数据重新分布。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="只重写元素的-equals-方法没重写-hashcodeput-的时候会发生什么">只重写元素的 equals 方法没重写 hashCode，put 的时候会发生什么?<a href="#只重写元素的-equals-方法没重写-hashcodeput-的时候会发生什么" class="hash-link" aria-label="Direct link to 只重写元素的 equals 方法没重写 hashCode，put 的时候会发生什么?" title="Direct link to 只重写元素的 equals 方法没重写 hashCode，put 的时候会发生什么?">​</a></h3>
<p>如果只重写 equals 方法，没有重写 hashCode 方法，那么会导致 equals 相等的两个对象，hashCode 不相等，这样的话，两个对象会被 put 到数组中不同的位置，导致 get 的时候，无法获取到正确的值。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="hashmap-怎么查找元素的呢">HashMap 怎么查找元素的呢？<a href="#hashmap-怎么查找元素的呢" class="hash-link" aria-label="Direct link to HashMap 怎么查找元素的呢？" title="Direct link to HashMap 怎么查找元素的呢？">​</a></h3>
<p>通过哈希值定位索引 → 定位桶 → 检查第一个节点 → 遍历链表或红黑树查找 → 返回结果。
<img decoding="async" loading="lazy" alt="HashMap查找元素" src="/doc/assets/images/HashMap查找元素-9514ede0b9eb927e9d872febdecd9ed9.png" width="600" height="741" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="hashmap-的-hash-函数是怎么设计的">HashMap 的 hash 函数是怎么设计的?<a href="#hashmap-的-hash-函数是怎么设计的" class="hash-link" aria-label="Direct link to HashMap 的 hash 函数是怎么设计的?" title="Direct link to HashMap 的 hash 函数是怎么设计的?">​</a></h3>
<p>先拿到 key 的哈希值，是一个 32 位的 int 类型数值，然后再让哈希值的高 16 位和低 16 位进行异或操作，这样能保证哈希分布均匀。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static final int hash(Object key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int h;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 如果 key 为 null，返回 0；否则，使用 hashCode 并进行扰动</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么-hash-函数能减少哈希冲突">为什么 hash 函数能减少哈希冲突？<a href="#为什么-hash-函数能减少哈希冲突" class="hash-link" aria-label="Direct link to 为什么 hash 函数能减少哈希冲突？" title="Direct link to 为什么 hash 函数能减少哈希冲突？">​</a></h3>
<p>快速回答：哈希表的索引是通过 h &amp; (n-1) 计算的，n 是底层数组的容量；n-1 和某个哈希值做 &amp; 运算，相当于截取了最低的四位。如果数组的容量很小，只取 h 的低位很容易导致哈希冲突。
通过异或操作将 h 的高位引入低位，可以增加哈希值的随机性，从而减少哈希冲突。</p>
<p>解释一下。
将哈希值无符号右移 16 位，意味着原哈希值的高 16 位被移到了低 16 位的位置。这样，原始哈希值的高 16 位和低 16 位就可以参与到最终用于索引计算的低位中。
选择 16 位是因为它是 32 位整数的一半，这样处理既考虑了高位的信息，又没有完全忽视低位原本的信息，从而达到了一种微妙的平衡状态。
举个例子（数组长度为 16）。</p>
<p>第一个键值对的键：h1 = 0001 0010 0011 0100 0101 0110 0111 1000
第二个键值对的键：h2 = 0001 0010 0011 0101 0101 0110 0111 1000
如果没有 hash 函数，直接取低 4 位，那么 h1 和 h2 的低 4 位都是 1000，也就是说两个键值对都会放在数组的第 8 个位置。
来看一下 hash 函数的处理过程。</p>
<p>①、对于第一个键h1的计算：
原始: 0001 0010 0011 0100 0101 0110 0111 1000
右移: 0000 0000 0000 0000 0001 0010 0011 0100
异或: ---------------------------------------
结果: 0001 0010 0011 0100 0100 0100 0100 1100</p>
<p>②、对于第二个键h2的计算：
原始: 0001 0010 0011 0101 0101 0110 0111 1000
右移: 0000 0000 0000 0000 0001 0010 0011 0101
异或: ---------------------------------------
结果: 0001 0010 0011 0101 0100 0100 0100 1101
通过上述计算，我们可以看到h1和h2经过h ^ (h &gt;&gt;&gt; 16)操作后得到了不同的结果。
现在，考虑数组长度为 16 时（需要最低 4 位来确定索引）：
对于h1的最低 4 位是1100（十进制中为 12）
对于h2的最低 4 位是1101（十进制中为 13）
这样，h1和h2就会被分别放在数组的第 12 个位置和第 13 个位置上，从而避免了哈希冲突。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么-hashmap-的容量是-2-的幂次方">为什么 HashMap 的容量是 2 的幂次方？<a href="#为什么-hashmap-的容量是-2-的幂次方" class="hash-link" aria-label="Direct link to 为什么 HashMap 的容量是 2 的幂次方？" title="Direct link to 为什么 HashMap 的容量是 2 的幂次方？">​</a></h3>
<p><strong>是为了快速定位元素在底层数组中的下标。</strong>
HashMap 是通过 hash &amp; (n-1) 来定位元素下标的，n 为数组的大小，也就是 HashMap 底层数组的容量。
数组长度-1 正好相当于一个“低位掩码”——掩码的低位最好全是 1，这样 &amp; 运算才有意义，否则结果一定是 0。
2 幂次方刚好是偶数，偶数-1 是奇数，奇数的二进制最后一位是 1，也就保证了 hash &amp;(length-1) 的最后一位可能为 0，也可能为 1（取决于 hash 的值），这样可以保证哈希值的均匀分布。
换句话说，&amp; 操作的结果就是将哈希值的高位全部归零，只保留低位值。
a&amp;b 的结果是：a、b 中对应位同时为 1，则结果为 1，否则为 0。例如 5&amp;3=1，5 的二进制是 0101，3 的二进制是 0011，5&amp;3=0001=1。
假设某哈希值的二进制为 10100101 11000100 00100101，用它来做 &amp; 运算，我们来看一下结果。
已知 HashMap 的初始长度为 16，16-1=15，二进制是 00000000 00000000 00001111（高位用 0 来补齐）：</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="10100101-11000100-00100101-00000000-00000000-00001111">10100101 11000100 00100101
&amp;	 00000000 00000000 00001111<a href="#10100101-11000100-00100101-00000000-00000000-00001111" class="hash-link" aria-label="Direct link to 10100101 11000100 00100101
&amp;	 00000000 00000000 00001111" title="Direct link to 10100101 11000100 00100101
&amp;	 00000000 00000000 00001111">​</a></h2>
<p>00000000 00000000 00000101
因为 15 的高位全部是 0，所以 &amp; 运算后的高位结果肯定也是 0，只剩下 4 个低位 0101，也就是十进制的 5。
这样，哈希值为 10100101 11000100 00100101 的键就会放在数组的第 5 个位置上。</p>
<p>对数组长度取模定位数组下标，这块有没有优化策略？
快速回答：HashMap 的策略是将取模运算 hash % table.length 优化为位运算 hash &amp; (length - 1)。
因为当数组的长度是 2 的 N 次幂时，hash &amp; (length - 1) = hash % length。
比如说 9 % 4 = 1，9 的二进制是 1001，4 - 1 = 3，3 的二进制是 0011，9 &amp; 3 = 1001 &amp; 0011 = 0001 = 1。
再比如说 10 % 4 = 2，10 的二进制是 1010，4 - 1 = 3，3 的二进制是 0011，10 &amp; 3 = 1010 &amp; 0011 = 0010 = 2。
当数组的长度不是 2 的 n 次方时，hash % length 和 hash &amp; (length - 1) 的结果就不一致了。
比如说 7 % 3 = 1，7 的二进制是 0111，3 - 1 = 2，2 的二进制是 0010，7 &amp; 2 = 0111 &amp; 0010 = 0010 = 2。</p>
<p>从二进制角度来看，hash / length = hash /
= hash &gt;&gt; n，即把 hash 右移 n 位，此时得到了 hash /
的商。</p>
<p>而被移调的部分，则是 hash %
，也就是余数。</p>
<p>的二进制形式为 1，后面跟着 n 个 0，那</p>
<ul>
<li>1 的二进制则是 n 个 1。例如 8 =
，二进制是 1000，7 =</li>
<li>1，二进制为 0111。</li>
</ul>
<p>hash % length的操作是求 hash 除以
的余数。在二进制中，这个操作的结果就是 hash 的二进制表示中最低 n 位的值。</p>
<p>因为在
取模的操作中，高于
表示位的所有数值对结果没有贡献，只有低于这个阈值的部分才决定余数。
比如说 26 的二进制是 11010，要计算 26 % 8，8 是
，所以我们关注的是 26 的二进制表示中最低 3 位：11010 的最低 3 位是 010。
010 对应于十进制中的 2，26 % 8 的结果是 2。
当执行hash &amp; (length - 1)时，实际上是保留 hash 二进制表示的最低 n 位，其他高位都被清零。
举个例子，hash 为 14，n 为 3，也就是数组长度为 ，也就是 8。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="1110-hash--14-0111-length---1--7">1110 (hash = 14)
&amp; 0111 (length - 1 = 7)<a href="#1110-hash--14-0111-length---1--7" class="hash-link" aria-label="Direct link to 1110 (hash = 14)
&amp; 0111 (length - 1 = 7)" title="Direct link to 1110 (hash = 14)
&amp; 0111 (length - 1 = 7)">​</a></h2>
<p>0110 (结果 = 6)
保留 14 的最低 3 位，高位被清零。</p>
<p>从此，两个运算 hash % length 和 hash &amp; (length - 1) 有了完美的闭环。在计算机中，位运算的速度要远高于取余运算，因为计算机本质上就是二进制嘛</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说什么是取模运算">说说什么是取模运算？<a href="#说说什么是取模运算" class="hash-link" aria-label="Direct link to 说说什么是取模运算？" title="Direct link to 说说什么是取模运算？">​</a></h3>
<p>在 Java 中，通常使用 % 运算符来表示取余，用 Math.floorMod() 来表示取模。
当操作数都是正数的话，取模运算和取余运算的结果是一样的；只有操作数出现负数的情况下，结果才会不同。
取模运算的商向负无穷靠近；取余运算的商向 0 靠近。这是导致它们两个在处理有负数情况下，结果不同的根本原因。
当数组的长度是 2 的 n 次幂时，取模运算/取余运算可以用位运算来代替，效率更高，毕竟计算机本身只认二进制。
比如说，7 对 3 取余，和 7 对 3 取模，结果都是 1。因为两者都是基于除法运算的，7 / 3 的商是 2，余数是 1。
对于 HashMap 来说，它需要通过 hash % table.length 来确定元素在数组中的位置。
比如说，数组长度是 3，hash 是 7，那么 7 % 3 的结果就是 1，也就是此时可以把元素放在下标为 1 的位置。
当 hash 是 8，8 % 3 的结果就是 2，也就是可以把元素放在下标为 2 的位置。
当 hash 是 9，9 % 3 的结果就是 0，也就是可以把元素放在下标为 0 的位置上。
是不是很奇妙，数组的大小为 3，刚好 3 个位置都利用上了。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如果初始化-hashmap传一个-17-的容量它会怎么处理">如果初始化 HashMap，传一个 17 的容量，它会怎么处理？<a href="#如果初始化-hashmap传一个-17-的容量它会怎么处理" class="hash-link" aria-label="Direct link to 如果初始化 HashMap，传一个 17 的容量，它会怎么处理？" title="Direct link to 如果初始化 HashMap，传一个 17 的容量，它会怎么处理？">​</a></h3>
<p>HashMap 会将容量调整到大于等于 17 的最小的 2 的幂次方，也就是 32。
<img decoding="async" loading="lazy" alt="HashMap扩容" src="/doc/assets/images/HashMap扩容-fb59c1d5a11c0f0c294246a90b38015a.png" width="774" height="400" class="img_ev3q">
这是因为哈希表的大小最好是 2 的 N 次幂，这样可以通过 (n - 1) &amp; hash 高效计算出索引值。
解释一下。
在 HashMap 的初始化构造方法中，有这样⼀段代码：</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public HashMap(int initialCapacity, float loadFactor) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">this.loadFactor = loadFactor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">this.threshold = tableSizeFor(initialCapacity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>阀值 threshold 会通过⽅法 tableSizeFor() 进⾏计算。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static final int tableSizeFor(int cap) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int n = cap - 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">n |= n &gt;&gt;&gt; 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">n |= n &gt;&gt;&gt; 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">n |= n &gt;&gt;&gt; 4;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">n |= n &gt;&gt;&gt; 8;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">n |= n &gt;&gt;&gt; 16;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>①、int n = cap - 1; 避免刚好是 2 的幂次方时，容量直接翻倍。
②、接下来通过不断右移（&gt;&gt;&gt;）并与自身进行或运算（|=），将 n 的二进制表示中的所有低位设置为 1。
n |= n &gt;&gt;&gt; 1; 将最高位的 1 扩展到下一位。
n |= n &gt;&gt;&gt; 2; 扩展到后两位。
依此类推，直到 n |= n &gt;&gt;&gt; 16;，扩展到后十六位，这样从最高位的 1 到最低位，就都变成了 1。
③、如果 n 小于 0，说明 cap 是负数，直接返回 1。
如果 n 大于或等于 MAXIMUM_CAPACITY（通常是
），则返回 MAXIMUM_CAPACITY。
否则，返回 n + 1，这是因为 n 的所有低位都是 1，所以 n + 1 就是大于 cap 的最小的 2 的幂次方。</p>
<p>初始化 HashMap 的时候需要传入容量吗？
如果预先知道 Map 将存储大量键值对，提前指定一个足够大的初始容量可以减少因扩容导致的重哈希操作。</p>
<p>因为每次扩容时，HashMap 需要将现有的元素插入到新的数组中，这个过程相对耗时，尤其是当 Map 中已有大量数据时。
当然了，过大的初始容量会浪费内存，特别是当实际存储的元素远少于初始容量时。如果不指定初始容量，HashMap 将使用默认的初始容量 16。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="你还知道哪些哈希函数的构造方法呢">你还知道哪些哈希函数的构造方法呢？<a href="#你还知道哪些哈希函数的构造方法呢" class="hash-link" aria-label="Direct link to 你还知道哪些哈希函数的构造方法呢？" title="Direct link to 你还知道哪些哈希函数的构造方法呢？">​</a></h3>
<p><strong>没问过</strong>
①、除留取余法：<code>H(key)=key%p(p&lt;=N)</code>，关键字除以一个不大于哈希表长度的正整数 p，所得余数为地址，当然 HashMap 里进行了优化改造，效率更高，散列也更均衡。
除此之外，还有这几种常见的哈希函数构造方法：
②、直接定址法：直接根据key来映射到对应的数组位置，例如 1232 放到下标 1232 的位置。
③、数字分析法：取key的某些数字（例如十位和百位）作为映射的位置
④、平方取中法：取key平方的中间几位作为映射的位置
⑤、将key分割成位数相同的几段，然后把它们的叠加和作为映射的位置。
<img decoding="async" loading="lazy" alt="Hash散列" src="/doc/assets/images/Hash散列-7ad619f039fc758f0b3d1e7372b62707.png" width="993" height="452" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="解决哈希冲突有哪些方法">解决哈希冲突有哪些方法？<a href="#解决哈希冲突有哪些方法" class="hash-link" aria-label="Direct link to 解决哈希冲突有哪些方法？" title="Direct link to 解决哈希冲突有哪些方法？">​</a></h3>
<p>简版回答：我知道的有 3 种，<strong>再哈希法、开放地址法和拉链法</strong>。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="什么是再哈希法">什么是再哈希法？<a href="#什么是再哈希法" class="hash-link" aria-label="Direct link to 什么是再哈希法？" title="Direct link to 什么是再哈希法？">​</a></h4>
<p>准备两套哈希算法，当发生哈希冲突的时候，使用另外一种哈希算法，直到找到空槽为止。对哈希算法的设计要求比较高。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="什么是开放地址法">什么是开放地址法？<a href="#什么是开放地址法" class="hash-link" aria-label="Direct link to 什么是开放地址法？" title="Direct link to 什么是开放地址法？">​</a></h4>
<p>遇到哈希冲突的时候，就去寻找下一个空的槽。有 3 种方法：
waitx
线性探测：从冲突的位置开始，依次往后找，直到找到空槽。
二次探测：从冲突的位置 x 开始，第一次增加 个位置，第二次增加 ，直到找到空槽。
双重哈希：和再哈希法类似，准备多个哈希函数，发生冲突的时候，使用另外一个哈希函数。
<img decoding="async" loading="lazy" alt="HASH冲突-线性探测" src="/doc/assets/images/HASH冲突-线性探测-e3e6ad44c9d85454fb2ff05ccdbd0317.png" width="1263" height="554" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是拉链法">什么是拉链法？<a href="#什么是拉链法" class="hash-link" aria-label="Direct link to 什么是拉链法？" title="Direct link to 什么是拉链法？">​</a></h3>
<p>也就是链地址法，当发生哈希冲突的时候，使用链表将冲突的元素串起来。HashMap 采用的正是拉链法。
怎么判断 key 相等呢？
依赖于key的equals()方法和hashCode()方法。
if (e.hash == hash &amp;&amp;
((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
①、hashCode() ：使用key的hashCode()方法计算key的哈希码。
②、equals() ：当两个key的哈希码相同时，HashMap还会调用key的equals()方法进行精确比较。只有当equals()方法返回true时，两个key才被认为是完全相同的。
如果两个key的引用指向了同一个对象，那么它们的hashCode()和equals()方法都会返回true，所以在 equals 判断之前可以先使用==运算符判断一次。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么-hashmap-链表转红黑树的阈值为-8-呢">为什么 HashMap 链表转红黑树的阈值为 8 呢？<a href="#为什么-hashmap-链表转红黑树的阈值为-8-呢" class="hash-link" aria-label="Direct link to 为什么 HashMap 链表转红黑树的阈值为 8 呢？" title="Direct link to 为什么 HashMap 链表转红黑树的阈值为 8 呢？">​</a></h3>
<p>树化发生在 table 数组的长度大于 64，且链表的长度大于 8 的时候。
为什么是 8 呢？源码的注释也给出了答案。
红黑树节点的大小大概是普通节点大小的两倍，所以转红黑树，牺牲了空间换时间，更多的是一种兜底的策略，保证极端情况下的查找效率。
阈值为什么要选 8 呢？和统计学有关。理想情况下，使用随机哈希码，链表里的节点符合泊松分布，出现节点个数的概率是递减的，节点个数为 8 的情况，发生概率仅为0.00000006。
至于红黑树转回链表的阈值为什么是 6，而不是 8？是因为如果这个阈值也设置成 8，假如发生碰撞，节点增减刚好在 8 附近，会发生链表和红黑树的不断转换，导致资源浪费。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="hashmap扩容发生在什么时候呢">HashMap扩容发生在什么时候呢？<a href="#hashmap扩容发生在什么时候呢" class="hash-link" aria-label="Direct link to HashMap扩容发生在什么时候呢？" title="Direct link to HashMap扩容发生在什么时候呢？">​</a></h3>
<p>当键值对数量超过阈值，也就是容量 * 负载因子时。
默认的负载因子是多少？ 0.75。
初始容量是多少？ 16（懒加载的方式)</p>
<p>1 左移 4 位，0000 0001 → 0001 0000，也就是 2 的 4 次方。
<code>static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</code>
为什么使用 <code>1 &lt;&lt; 4</code> 而不是直接写 16？
写 <code>1&lt;&lt;4</code> 主要是为了强调这个值是 2 的幂次方，而不是一个完全随机的选择。</p>
<p>无论 HashMap 是否扩容，其底层的数组长度都应该是 2 的幂次方，因为这样可以通过位运算快速计算出元素的索引。
为什么选择 0.75 作为 HashMap 的默认负载因子呢？
这是一个经验值。如果设置得太低，如 0.5，会浪费空间；如果设置得太高，如 0.9，会增加哈希冲突。
0.75 是 JDK 作者经过大量验证后得出的最优解，能够最大限度减少 rehash 的次数。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="hashmap的扩容机制了解吗">🌟HashMap的扩容机制了解吗？<a href="#hashmap的扩容机制了解吗" class="hash-link" aria-label="Direct link to 🌟HashMap的扩容机制了解吗？" title="Direct link to 🌟HashMap的扩容机制了解吗？">​</a></h3>
<p>扩容时，HashMap 会创建一个新的数组，其容量是原来的两倍。然后遍历旧哈希表中的元素，将其重新分配到新的哈希表中。
如果当前桶中只有一个元素，那么直接通过键的哈希值与数组大小取模锁定新的索引位置：e.hash &amp; (newCap - 1)。
如果当前桶是红黑树，那么会调用 split() 方法分裂树节点，以保证树的平衡。
如果当前桶是链表，会通过旧键的哈希值与旧的数组大小取模 (e.hash &amp; oldCap) == 0 来作为判断条件，如果条件为真，元素保留在原索引的位置；否则元素移动到原索引 + 旧数组大小的位置。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="jdk-7-扩容的时候有什么问题">JDK 7 扩容的时候有什么问题？<a href="#jdk-7-扩容的时候有什么问题" class="hash-link" aria-label="Direct link to JDK 7 扩容的时候有什么问题？" title="Direct link to JDK 7 扩容的时候有什么问题？">​</a></h3>
<p>JDK 7 在扩容的时候使用头插法来重新插入链表节点，这样会导致链表无法保持原有的顺序。
详细解释一下。
JDK 7 是通过哈希值与数组大小-1 进行与运算确定元素下标的。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static int indexFor(int h, int length) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return h &amp; (length-1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>我们来假设：
数组 table 的长度为 2
键的哈希值为 3、7、5
取模运算后，键发生了哈希冲突，它们都需要放到 table[1] 的桶上。那么扩容前就是这个样子：
![JAVA7 HashMap的hashcode冲突处理](image/java_collection_review/JAVA7 HashMap的hashcode冲突处理.png)
假设负载因子 loadFactor 为 1，也就是当元素的个数大于 table 的长度时进行扩容。</p>
<p>扩容后的数组容量为 4。</p>
<p>key 3 取模（3%4）后是 3，放在 table[3] 上。
key 7 取模（7%4）后是 3，放在 table[3] 上的链表头部。
key 5 取模（5%4）后是 1，放在 table[1] 上。
<img decoding="async" loading="lazy" alt="HashMap扩容后处理" src="/doc/assets/images/HashMap扩容后处理-c5f9ba0513be61c18cf69917da5660ae.png" width="1240" height="374" class="img_ev3q">
可以看到，由于 JDK 采用的是头插法，7 跑到 3 的前面了，原来的顺序是 3、7、5，7 在 3 的后面。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">for (Entry&lt;K,V&gt; e : oldTable) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (null != e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Entry&lt;K,V&gt; next = e.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int i = indexFor(e.hash, newCapacity);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        e.next = newTable[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        newTable[i] = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        e = next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>最好的情况就是，扩容后的 7 还在 3 的后面，保持原来的顺序。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="jdk-8-是怎么解决这个问题的">JDK 8 是怎么解决这个问题的？<a href="#jdk-8-是怎么解决这个问题的" class="hash-link" aria-label="Direct link to JDK 8 是怎么解决这个问题的？" title="Direct link to JDK 8 是怎么解决这个问题的？">​</a></h3>
<p>JDK 8 改用了尾插法，并且当 (e.hash &amp; oldCap) == 0 时，元素保留在原索引的位置；否则元素移动到原索引 + 旧数组大小的位置。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Node&lt;K,V&gt; loHead = null, loTail = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Node&lt;K,V&gt; next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">do {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    next = e.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if ((e.hash &amp; oldCap) == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (loTail == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            loHead = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            loTail.next = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        loTail = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (hiTail == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            hiHead = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            hiTail.next = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        hiTail = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} while ((e = next) != null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (loHead != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    newTab[j] = loHead;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (hiHead != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    newTab[j + oldCap] = hiHead;</span><br></span></code></pre></div></div>
<p>由于扩容时，数组长度会翻倍，例如：16 → 32， 因此，新数组的索引范围是原索引范围的两倍。
原索引 index = (n - 1) &amp; hash，扩容后的新索引就是 index = (2n - 1) &amp; hash。
也就是说，如果 (e.hash &amp; oldCap) == 0，元素在新数组中的位置与旧位置相同；否则，元素在新数组中的位置是旧位置 + 旧数组大小。
假设扩容前的数组长度为 16（n-1 也就是二进制的 0000 1111，1X
+1X
+1X
+1X
=1+2+4+8=15），key1 为 5（二进制为 0000 0101），key2 为 21（二进制为 0001 0101）。</p>
<p>key1 和 n-1 做 &amp; 运算后为 0000 0101，也就是 5；
key2 和 n-1 做 &amp; 运算后为 0000 0101，也就是 5。
此时哈希冲突了，用拉链法来解决哈希冲突。
现在，HashMap 进行了扩容，容量为原来的 2 倍，也就是 32（n-1 也就是二进制的 0001 1111，1X
+1X
+1X
+1X
+1X
=1+2+4+8+16=31）。</p>
<p>key1 和 n-1 做 &amp; 运算后为 0000 0101，也就是 5；
key2 和 n-1 做 &amp; 运算后为 0001 0101，也就是 21=5+16，就是数组扩容前的位置+原数组的长度。
<img decoding="async" loading="lazy" alt="取模运算1" src="/doc/assets/images/取模运算1-e29ecfaac2216ddb74b7932d477c6fb0.png" width="876" height="219" class="img_ev3q">
这样可以避免重新计算所有元素的哈希值，只需检查高位的某一位，就可以快速确定新位置。
<img decoding="async" loading="lazy" alt="取模运算2" src="/doc/assets/images/取模运算2-746d75e14dc9b2f97f1bb09340a204fc.png" width="1179" height="568" class="img_ev3q">
扩容的时候每个节点都要进行位运算吗？
不需要。HashMap 会通过 (e.hash &amp; oldCap) 来判断节点是否需要移动，0 的话保留原索引；1 才需要移动到新索引（原索引 + oldCap）。
这样就避免了 hashCode 的重新计算，大大提升了扩容的性能。
所以，哪怕有几十万条数据，可能只有一半的数据才需要移动到新位置。另外，位运算的计算速度非常快，因此，尽管扩容操作涉及到遍历整个哈希表并对每个节点进行判断，但这部分操作的计算成本是相对较低的。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="jdk-8-对-hashmap-做了哪些优化呢">JDK 8 对 HashMap 做了哪些优化呢？<a href="#jdk-8-对-hashmap-做了哪些优化呢" class="hash-link" aria-label="Direct link to JDK 8 对 HashMap 做了哪些优化呢？" title="Direct link to JDK 8 对 HashMap 做了哪些优化呢？">​</a></h3>
<p>①、底层数据结构由数组 + 链表改成了数组 + 链表或红黑树的结构。
如果多个键映射到了同一个哈希值，链表会变得很长，在最坏的情况下，当所有的键都映射到同一个桶中时，性能会退化到 O(n)，而红黑树的时间复杂度是 O(logn)。
②、链表的插入方式由头插法改为了尾插法。头插法在扩容后容易改变原来链表的顺序。
③、扩容的时机由插入时判断改为插入后判断，这样可以避免在每次插入时都进行不必要的扩容检查，因为有可能插入后仍然不需要扩容。
<img decoding="async" loading="lazy" alt="hashMap8扩容1" src="/doc/assets/images/hashMap8扩容1-05222f821a41fac22bf800c7a2947fd8.png" width="904" height="1014" class="img_ev3q">
<img decoding="async" loading="lazy" alt="hashMap8扩容2" src="/doc/assets/images/hashMap8扩容2-05222f821a41fac22bf800c7a2947fd8.png" width="904" height="1014" class="img_ev3q">
④、哈希扰动算法也进行了优化。JDK 7 是通过多次移位和异或运算来实现的。
<img decoding="async" loading="lazy" alt="hashMap7hash运算" src="/doc/assets/images/hashMap7hash运算-a51001d4080d9a3fc719d93e78ad4e92.png" width="1396" height="688" class="img_ev3q">
JDK 8 让 hash 值的高 16 位和低 16 位进行了异或运算，让高位的信息也能参与到低位的计算中，这样可以极大程度上减少哈希碰撞。
<img decoding="async" loading="lazy" alt="hashMap8hash运算" src="/doc/assets/images/hashMap8hash运算-b4c3d5c60b7c4514a6e283e7089a6f55.png" width="1454" height="216" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="你能自己设计实现一个-hashmap-吗">你能自己设计实现一个 HashMap 吗？<a href="#你能自己设计实现一个-hashmap-吗" class="hash-link" aria-label="Direct link to 你能自己设计实现一个 HashMap 吗？" title="Direct link to 你能自己设计实现一个 HashMap 吗？">​</a></h3>
<p>可以，我先说一下整体的设计思路：
第一步，实现一个 hash 函数，对键的 hashCode 进行扰动
第二步，实现一个拉链法的方法来解决哈希冲突
第三步，扩容后，重新计算哈希值，将元素放到新的数组中
<img decoding="async" loading="lazy" alt="hash实现1" src="/doc/assets/images/hash实现1-e4c6797ca6d8111780e8c12a83c1fb04.png" width="1102" height="374" class="img_ev3q">
<img decoding="async" loading="lazy" alt="hash实现2" src="/doc/assets/images/hash实现2-ec6cd36c32150c619a027556e364dffb.png" width="1430" height="7298" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="hashmap-是线程安全的吗">🌟HashMap 是线程安全的吗？<a href="#hashmap-是线程安全的吗" class="hash-link" aria-label="Direct link to 🌟HashMap 是线程安全的吗？" title="Direct link to 🌟HashMap 是线程安全的吗？">​</a></h3>
<p>推荐阅读：HashMap 详解
HashMap 不是线程安全的，主要有以下几个问题：
①、多线程下扩容会死循环。JDK7 中的 HashMap 使用的是头插法来处理链表，在多线程环境下扩容会出现环形链表，造成死循环。
![Java7 HashMap扩容](image/java_collection_review/Java7 HashMap扩容.png)
A -&gt; B
实际就是两个线程
线程1继续执行完成了扩容，然后链表就翻转了 B -&gt; A
线程2在线程1执行前记录了 A的下一个节点为B， 在线程1执行完后线程二继续执行，将A头插入桶中，然后
然后线程2继续执行 他的节点还是按照原来变量的顺序，
先插入A作为头结点， 然后B插入到A前面， 然后B.next因为线程1修改了B -&gt; A,导致循环插入</p>
<p>不过，JDK 8 时通过尾插法修复了这个问题，扩容时会保持链表原来的顺序。
②、多线程在进行 put 元素的时候，可能会导致元素丢失。因为计算出来的位置可能会被其他线程覆盖掉，比如说一个县城 put 3 的时候，另外一个线程 put 了 7，就把 3 给弄丢了。
![Java7 HashMap put方法覆盖](image/java_collection_review/Java7 HashMap put方法覆盖.png)
③、put 和 get 并发时，可能导致 get 为 null。线程 1 执行 put 时，因为元素个数超出阈值而扩容，线程 2 此时执行 get，就有可能出现这个问题。
因为线程 1 执行完 table = newTab 之后，线程 2 中的 table 已经发生了改变，比如说索引 3 的键值对移动到了索引 7 的位置，此时线程 2 去 get 索引 3 的元素就 get 不到了。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="怎么解决-hashmap-线程不安全的问题呢">🌟怎么解决 HashMap 线程不安全的问题呢？<a href="#怎么解决-hashmap-线程不安全的问题呢" class="hash-link" aria-label="Direct link to 🌟怎么解决 HashMap 线程不安全的问题呢？" title="Direct link to 🌟怎么解决 HashMap 线程不安全的问题呢？">​</a></h3>
<p>在早期的 JDK 版本中，可以用 Hashtable 来保证线程安全。Hashtable 在方法上加了 synchronized 关键字。
<img decoding="async" loading="lazy" alt="HashTable" src="/doc/assets/images/HashTable-aab9466eea4fc327417c5327f9c8598c.png" width="1352" height="640" class="img_ev3q">
另外，可以通过 Collections.synchronizedMap 方法返回一个线程安全的 Map，内部是通过 synchronized 对象锁来保证线程安全的，比在方法上直接加 synchronized 关键字更轻量级。
ps:其实就是在原来的结构上封装一层，在对应的方法上都加一层synchronized
<img decoding="async" loading="lazy" alt="synchronizedMap" src="/doc/assets/images/synchronizedMap-2d375beda81086b5a7a400307d724b90.png" width="2266" height="2108" class="img_ev3q">
更优雅的解决方案是使用并发工具包下的 ConcurrentHashMap，使用了CAS+ synchronized 关键字来保证线程安全。
<img decoding="async" loading="lazy" alt="ConcurrentHashMap" src="/doc/assets/images/ConcurrentHashMap-02fb5bc6f5e4126630ef5db8771ffc5a.png" width="1512" height="1165" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="hashmap-内部节点是有序的吗">HashMap 内部节点是有序的吗？<a href="#hashmap-内部节点是有序的吗" class="hash-link" aria-label="Direct link to HashMap 内部节点是有序的吗？" title="Direct link to HashMap 内部节点是有序的吗？">​</a></h3>
<p>无序的，根据 hash 值随机插入。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="讲讲-linkedhashmap-怎么实现有序的">讲讲 LinkedHashMap 怎么实现有序的？<a href="#讲讲-linkedhashmap-怎么实现有序的" class="hash-link" aria-label="Direct link to 讲讲 LinkedHashMap 怎么实现有序的？" title="Direct link to 讲讲 LinkedHashMap 怎么实现有序的？">​</a></h3>
<p>LinkedHashMap 在 <strong>继承HashMap</strong> 的基础上维护了一个双向链表，通过 before 和 after 标识前置节点和后置节点。
<img decoding="async" loading="lazy" alt="LinkedHashMap结构" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAnoAAAE1CAIAAAD/Ltp/AAAmBklEQVR4Xu2dC5AU1b2HNzEmqVQqlUoqZaVIUqk8KpXKNZWHpfGBEQyKj4COWVHUe5X4CiLGKIqKIOugKDHEQAyKAbzexcQkqDeKit6oeF0SAr4AuRqExV1Y2AWW1y77APae7tPd033OzOzuzPRrzvfVr6idMz39OHvmfPPv7h1q+gAAACBkatQGAAAAqDToFgAAIHTQLQAAQOigWwAAgNBBtwAAAKGDbgEAAEIH3QIAAIQOugUAAAgddAsAABA66BYAACB00C0AAEDooFsAAIDQQbcAAAChg24BAABCB90CAACEDroFAAAIHXQLAAAQOugWAAAgdNAtAABA6KBbAACA0EG3AAAAoYNuAQAAQgfdAgAAhA66BQAACB10CwAAEDroFuJk9eo35j+8gBBC4oo6K4UGuoU4Ebo99vihl1wxkRBCos9V4yeqs1JooFuIE6nbVVv6CCEk4kyfvQDdgimgW0JIXEG3YBDolhASV9AtGAS6JYTEFXQLBoFuCSFxBd2CQaBbQkhcQbdgEOiWEBJX0C0YBLolhMQVdAsGgW4JIXEF3YJBoFtCSFxBt2AQ6JYQElfQLRgEuiWExBV0CwaBbgkhcQXdgkGgW0JIXEG3YBDolhASV9AtGAS6JYTEFXQLBoFuCSFxBd2CQaBbQkhcQbdgEOiWEBJX0C0YBLolhMQVdAsGgW4JIXEF3YJBoFtCSFxBt2AQkel2+bt7n3+zxZD8bd0OvQcqntc2dOibrta8uKZV74Ew8vL6dn3r1RpxsHoPRBl0CwYRgW5nzf/TuRdcLLZiVE47a9RtMx949V/79Q4pP3Prl475j8v1jVZ3ho0YecO0XwpJ6B1Skdx5/6Kzzq3Vt1vdEYcsDlzvjWiCbsEgQtXtisbuy8Zff/Kpp94594olDbctWzfdkDy9euqvH51w7oWjzxid+csr7+g9U06unXyn+JVNmXXZ48tv0TddrVn65rQH/nTdRZf/5OThIxb+92t6t5STZW9uq734spGjzrz34aufWnm7vvVqjThYccjiwMXhi07QeybsoFswiFB1e9X1t5530TnL1k5f3TbLzEy8bawwbgVr3Jvqfj3irJHis4u+LUMiPmeccPKwp/+xSe+cknPBpVdcds35r31wt745EyIOXBy+6AS9Z8IOugWDCE+3v39iuVjzf//zdv3tbVREjXvbzAf0/ikhS5b/n+jS/3xukr4VozJuwpjxN07V+6e0/HL+n4edNuKV92foGzIn4vBFJ4iu0Psn1KBbMIjwdDv+xmnX3jJWf2Obll8/OuG0s0bp/VNCptzzu4su/4m+CdMiPnCIQfvahg69i0qIqOqm/mqcvhXTIjoh+gIX3YJBhKfbUT+54FePXKO/q03L06unih6uyL3Kl46/fsqsy/RNmJaGppmiS//00lq9i0rIiT8c/sizN+pbMS2iE0RX6P0TatAtGER4uj1jdGbuHybq72rTsmzddNHDFbmf9uLLx9f95nJ9EwZGdOljy97Qu6iEWKt66WZ9E6ZFdEJIU0GRoFswCHQbdtBtGEG3FQ+6BQgXdBt20G0YQbcVD7oFCBd0G3bQbRhBtxUPugUIF3QbdtBtGEG3FQ+6BQgXdBt20G0YQbcVD7oFCBd0G3bQbRhBtxUPuoXSaKmvrcmuUFtBJ926fWvs8FFjl+ntSUq16fbZkTU1Ixfq7dEG3VY86Lb6aaircaitbxGeXJxxH2fqm9SFB8SKrHy9rltv5bmn3IXl1itJU72zMW/N3rYGcWjW54ZBvmRwpFa3U2eMsjsG3UaUCePd4YtuqzLo1gQabAvldCIFnFlcuv6kVnXd9nl2r2uQD10BhyMz17hBuw92W9K4g33VQEmtbmc5AkC3kUZKF93GEvsj5uQJWntlgm5NIA7dOhVnyLVj/gJ3sNtCt4WCbqMPuo0xduej2zJAt3HotiZrl7dy04GtVxJLt9msvUVnZ9BtJYNuow+6jS3LHjza6nt0WwbotrhuvQJUErCO70Jv4FmtPXf2uKEuk61zZSx0WJf1b115obsPjpWzi91q1X7krLEItm4bnBrXXj6o2+DmCh1aJqPoNncNWH1VCVSHbhdOzvXI+GedBfyNnpWdOctZ0r0AbHH0jLf0TVQgidKt//CHPzjVvu/Jf/j+DvEa/dF0661BakB5aCW4zgrZIrm6fWvscOs4j57xrPxB4v+Akr9DcsN11NiFuV+T9Svw/9Y8rF+fvvUygm5NwCsxA9iqc1zr1qn2kt6JWVtjXhHsr2iVW6Kkv92fM/WLrdWIF4rFMovrPd06r8qJ2WmXj5yddLYuH/ZnXKlb/wcIn27l5oKfKoLWl3viyNXdE/nQ2ckKFL7VoVs5y3uiXe1OXk6LnAG9Olg+dKa5cE/QrU6Ybq0EDt/uKKdnHA243Zj35IGm2zZXsV4fBh7KdbraVpYsI8nVbZtn3MDgHFCH2C+0PZpvWFau9/IG3ZpA8erWj7SLK7mAeAIETabpdoVdbtY1iPbsCnXrHsEz0qpfC++kD1e37kXcbIOnW3/JK8kdjrJLfqeqflWOtASqQbf6NKT4VZnjnIe2MzRPVzyJ063/8O0+LFAn+RfzMkjdqr+afC8vKSnQrTf8BtMhdiE7crz1YVHrJfW1FQ66NQFVeKrJvBuOHFTnWQT/jKcf3TbJKjljuzCv23IU0u2APOfp1juoWqsgt7Yl5erfbXmYokU1sV+x+Xcj72eOAZJ63boEnKFOTErd5pydEw/tIlib1yqa5Ok2d/h2RwXPGHuVmUNZupUb8v1q5Mv1c9SDTkp1O4AOcUZ1no+A6qiucNCtCRTTbb4bibVTuLlrmc5T/enWv1rf1oOnbYtXt4PVre9Dg29bfk0ORLfqJw+LfvahP6pBt5NHKnNWvmtdyhQvT9bZLwxt/pJJoG6988m+M8lWnMuHgXPLZek2cPncoTIfblKq2wF0iDuq1dP4Wj9XOujWBArrNr94fPWirzr0+69f3foW8LauXCfuR7f+dRbEr1vvo4NfnP7qVj2ZnE+3Wl+VT+p16788pkxw+oTlizfx5SkjKpok6tZ3t06u0nLqWm/2r4Buw7uZNqW67bdD5AegGf47D7yg27JBt6pC+tOtdaduxr7RKSAeW1cD1K1c2G7pR7fW6V+lCO5TrrzKp/KpN6hb91XOSuy9Uo7a/5S7wuCr1Ko6dyAlUiW6dfXpykO5WJvvpLGcvFSdVD6J1K13AsB3+Pl1e/TwUfrJz2CnBeziityxgrK8/WzRj0EDTEp120+HWEvKQVu4n3ParvDQRbdVj/9aqWUm52KkRa4M1RGCyfOULBZ9fydjeSj3MFP/lGNG+5JtTrEWubO4GrmKs8Z6rbNC16Pe+pULqP7tuk4NfkQodJ04z1MS9xNDsLWMC7d9KdZtrj6zJyDl4Szlym6NXis455PDqhW8JFO3yv3JMvlOwltYXade063xT/f+c6TDR7krkStXX1iBC7erE61b38CzeiD30PnUkr9DcouJ3g7+uVpu5YF+zn+DW+lBt5AQbN3WNZR/a1LSSK1uy45dc2gOrnwSqtuUJ8G6TWvQLSQER7dqc/oxT7dWHTz8wQmVOqvZb9BtGEG3FQ+6hSTgnUmuCVwtrgrM0613pq4yZzX7DboNI+i24kG3AOFioG4jDroNI+i24kG3AOGCbsMOug0j6LbiQbcA4YJuww66DSPotuJBtwDhgm7DzrK1ldTtdHRrp8K6/Ru6nSU6IaSpoEjQLRhEeLq98LIrp9+PG2Yt/h9rFlvR2K130WBzzU3Tr5syVt+EaXnu7TtElz7zz816F5WQ084ePeexa/WtmBbRCaIr9P4JNegWDCI83Yo30rkXjtbf1ablxrpLLrnqWr1/SshvHn36lBEj/rH1Hn0rRmXGA1eenanV+6e0XHfr3T+dOEbfimkRnSC6Qu+fUINuwSDC0+3f1u046ZRTxcyov7HNyX8+N0l07++fWK73T2kRmrkp++/6hszJk/+YcvzQU3758F/0ziktf1m+XvyODC9wxeGLThBdofdPqEG3YBDh6Vbkt4ufEyu//b5xf99iYkH2m8XXHnfiybfcNVfvmZLzX8/+U3TpL+64+OUNWX2LVZ+Hn/rFj844/Zqbpus9U07ufmCx6NWZD12lb9GEiAMXhy86Qe+ZsINuwSBC1a3I/L+8fMbozEnDhv/0ujHXTRlrSH426cIzRp953Aknz5j7qN4nZeaxZW9kxl4ifmuXjj9f33S15pqbLxxV+2Nx1Lfe/Vu9T8rPrxc9dcqI008dedqVv7hA33q1RhysOGRx4OLw9T6JIOgWDCJs3crMe/zFydnfTLz1LkNyw7Rf/mrBEy+9s0vvikplwZOvCvHom67WXH/7vfc8+MfnXt+id0WlsmJT15z/embS9Nn61qs14mDFIYsD13sjmqBbMIhodEsIIXrQLRgEuiWExBV0CwaBbgkhcQXdgkGgW0JIXEG3YBDolhASV9AtGAS6JYTEFXQLBoFuCSFxBd2CQaBbQkhcQbdgEOiWEBJX0C0YBLolhMQVdAsGgW4JIXEF3YJBoFtCSFxBt2AQ6JYQElfQLRgEuiWExBV0CwaBbgkhcQXdgkGgW0JIXEG3YBDolhASV9AtGAS6JYTEFXQLBoFuCSFxBd2CQaBbQkhcQbdgEOiWEBJX0C0YBLolhMQVdAsGIXX72LI3CCEk4qBbMAipW0JKzr99+3t6IyEDDLoFAOifhQsXnnLKKWorQCJBtwCQVoYMGVJTU/PSSy+pTwAkD3QLAKlElLYf/ehHhW5/8IMfqM8BJA90CwCpRJa2EgpcSD7oFgDSh1faSk466SR1CYCEgW4BIH34S1sJBS4kHHQLAClDlLZHHnmk37Wi0qXAhYSDbgEgZRx11FHSskcccYT49yMf+Yh8SIELSQbdAkCaEKWtlOuQIUPGjh371a9+9cQTTxQPP/zhD1PgQpJBtwCQJr74xS8K0Qrpip9nz5793e9+V/wg6lopXQpcSCzoFgBSg7CpFK3kvvvu+/73v+9/dtq0ad5DgESBbgEgrcyaNeuYY45RWwESCboFgLRyzz33HHvssWorQCJBtwCQVu6++26+wRHSAroFgLQyY8aME044QW0FSCToFgDSSjab5Y9/IC2gWwBIK3V1dUOHDlVbARIJugWAtHLHHXf88Ic/VFsBEgm6BYC0MnXq1GHDhqmtAIkE3QJAWpkyZcqpp56qtgIkEnQLAGnltttuGzFihNoKkEjQLQCklVtuueX0009XWwESCboFgLRy8803jxw5Um2Fsjl06NDBgwfVVigPdAsAaWXSpElnnnmm2grl0dHR8d5774l/1SegPNAtAKSVG2644eyzz1ZboVQOHz68bdu2lpYWUd3u2bNn586d6hJQBugWANLK9ddfP2rUKLUVSqKnp2fjxo0bNmzYv3+/eLhv3762tjZ1ISgDdAsAaeXnP//5Oeeco7bC4Nm1a9dbb73V1dXV29u7efNmUd0K6YoCV10OygDdAkBamThx4rnnnqu2wmAQRa2oaHfv3r13796WlhbRstNGVLfy8m1nZ2dTU5PQsPpKGCToFgDSyoQJE8477zy1FQbDQRv5c3Nz84EDB0RpKwpcUdp2d3e3trY2NjZyl3JFQLcAkFbGjx9fW1urtsIgEVWsqG6FZYVrhXFFi3Ct+GHjxo2cT64g6BYA0srVV189ZswYtRUGjzDu2rVr9+/f39LSsm/fvl27djU1Ncm/vt2+fXtbW5tYgPPJZYJuASCtXHXVVRdeeKHaCiVx+PBhIVeh1TVr1gjj+p8Sot2yZcv7778vBOxvh0GBbgEgrVxxxRUXXXSR2go+hD6bm5sHokmhW1HFbt68ubu7e+vWrY2NjfJMsngonlKXhsGDbgEAqhnh2tbW1l27dhWxprDy+vXr/VdqRaUrKlpR14ofmpqahHR9i0MpoFsAgOqkp6fHq2ulPgtJVzwrlxQvEcsotyKLh0LG27dvz/taGCDoFgBSwopsTW299ZehMDA6Ozvfe+89/5lk0bJx40ZR7HZ1dbW1tSk3HgvXijJXLL9t27ZNmzaJBXbs2NHY2Lh69WqxHvFa/8IwWNAtACSOlsWZmpqazOKgW5vqrdaBG1cub5NdoT5pAr29vU1NTUqLKF7b29vXrl2r/ycEoooVopU/i0JW2Le7u1v8S1FbEdAtACSNlvpaS5EN9g8+6TZkpYNFmavL2G7MR6Y+YByDEPqUXxTlPRSl7Zo1awp9bYVo37x5c6FnoUzQLQAkDLsqlTaVZa7lTOuho9uGOruprkF9YRB7MXNd2xfUrfxv9To7O7dv3753797ggg6i9n3//ffRbUigWwBIFrYms45LrZo1U79CCFiIU+q2PtvPyWG7Jq61PO0tZmm7Pz1XH0Kfzc3Nhw8fFtJ9++23e3p6+uzLt1u2bFEXdeG8cXigWwBIErnS1pKrezbYPr1cm3FK3f7F6auDrWu93tnpakPYsampadOmTXk12d3dLWpZUbDu3r1727Zt8l4nseTmzZv5iqjoQbcAkCC80tY+jZypX2xXt03Ww+wK99ptfqRTdbLZKj2rLJQpRFvka407Ojrkf14raLeRP7e1tQkB55aDSEC3AJAUvCu1Eu+uqAI4BnUu5brnme3a11av9YNTIhc9+ZxKhGX7/b96hFO9Knbfvn2eYoufT4aQQLcAkDQ8WbrXbv1aLXIm2XZzts5v6EzGOgs94L8dSgOHDh1qbm5ubW1Vn9Dwf/Wx+Hnnzp2HbOQXRQ3kmx2hgqBbAEgWdo0bvFWqKfh3PvmNK6/vZrPW3w412D/blpUOrpbq1rvBWGkXVeyBAweURj+itG1vbxeKFWsQrt2wYQO6jRh0CwBJImdH7wbjwD3J8pbjPNdiA1r1Xcetq8/VyulHaFW/K0qoVOiz+Ncay2+SUlshQtAtACQG5UqtcKTXYpWq3q1S9hXZwCliu8W/vPeS2voGf7lcXXgnlnUH+xGL7dixQ22FaEG3AJBgHH1KWRa8Mznwp7oW8sSy62Pf92ZUE6JaFUWtfmJZZ//+/cVPNUMEoFsASB7u1x3b9z25543zfnejez9z8Oqs72Yr72FN9ZxS7rNPDhf6Bqje3t533323paVFlrziX/3rkSF60C0AJIXAHwLlbnTKXaYVVax605PiYNvT8i90VbkGCuU42bq/d/3O7rfbuv657cC7u7pbOw72Hip2KnhQDOQ6LsQCugWApCBsGixeC31zhYNe6Vq4l2/zPxsrH+ztfbmp41/tPZv39m7r6G3tPLihvef11q7lzZ0t+8v9mif5PxDs2rVLfQKSAboFgKrDqnG1W5djZU/3oYatnVsLOLWlo/eFzR0bd/ds2tMjSt7nGvfLvNLcKVoGUvuKopb/zCfhoFsAgHARRe1bbV2KNTe0dzftzdn3vfYe4dc3W7vau3J/DisqYPHCFVs7i/i2t7e3sbGxyFc5QkJAtwAAIdK0r/e9dvVK6v6ew7J+lQ/X7ex+bUvnzgP5a9N3dnaLwldtte+Bamtro6hNC+gWANLK0KFD6+rq1NYk0X3w8N+3dh7MV5yu29G1wdbwmh1dr2/v6vUtI7z7fOP+zb7ad9W2A93BtXR0dKxbt877Xwcg+aBbAEgrJ554YjabVVuTxPqd3d49UEKuLR3qtdvmfb2ixlXq2l1dh4Rf93bnzir/q926rOtbBNIHugWAtHL88cffddddamuSeHWL8x0UQqhCqy83Bf7+9dDhvleaO9fusL5bcV+PpVjxr38Bj9aOgytb+J6KdINuASCtHHfccTNnzlRbE0PvocOvNue+8klUtxvaAxXqgV7rCu4H9knj7R2Wjwvduty4p0eeeYb0gm4BIK0ce+yx9957r9qaGHZ3HVq5rVhJuqf7kFBsa2f/Nzq93tpV6EYqSAvoFgDSyjHHHDNr1iy1NTEc7utb1thxsPB/HiCr20IVrZ//+YBvYUw96BYA0sr3vve9++67T21NEmt2dLV2FKtK/95y4P929n+WeEN7z8qWAwf8ty9D2kC3AJBWvvOd78yePVttTRL7ew692Vrsf5nd0N79v1s6C90h1Wd908VBscBrWzr/9kHHu7v6FzMkFnQLAGnl29/+9v3336+2JoxN/d3lJI272/dlUpLug4fFa5c3d/q/ZwrSC7oFgLRy9NFHz5kzR21NHitbDry+vUu/JWrz3l4h2te3H9i63/qhYWvnhvYeGfGSFzZ3vL+7J+9XZEAaQbcAkFa+9a1vzZ07V21NJB/s7RV16ivNneJfUc7Kb7dYte2A/35j4WOxmHh2y77ets6DA/iPCSBNoFsASCvf/OY3H3jgAbU1wQiDCr+K4nVZY0cj3xJlGOgWANLKN77xjXnz5qmtyab30OG/txz4B18RZR7oFgDSyte//vWHHnpIbU08r2/v2uP7PmQwBHQLAGnla1/72sMPP6y2Jp4ubn8yEnQLAGnlK1/5yoIFC9RWgESCbgEgrXz5y19euHCh2gqQSNAtAKSVL33pS4888ojaCpBI0C0ApJUvfOELjz76qNoKkEjQLQCklSFDhtTX16utAIkE3QJAWvn85z//2GOPqa0AiQTdAkBaOeqoo/7whz+orQCJBN0CQFr53Oc+9/jjj6utAIkE3QJAWvnsZz/75z//WW0FSCToFgDSymc+85klS5aorQCJBN0CQFr59Kc//eSTT6qtAIkE3QJAWvnUpz711FNPqa0AiQTdAkBa+eQnP/nXv/5VbQVIJOgWANLKJz7xiWeeeUZtBUgk6BYA0srHP/7xZ599Vm0FSCToFgDSysc+9rHnn39ebQVIJOgWANLKkUce+cILL6itAIkE3QJAWjniiCNefPFFtRUgkaBbiI35Dy8gpJx86EMfuvHGm/R2QgYedWIKDXQLsSEG+tX/MYaQknPReWdfUjtKbydkoPnZeHViCg10C7Ehddu36kFCCIk+8++8Bt2CEaBbQkiMQbdgCuiWEBJj0C2YArolhMQYdAumgG4JITEG3YIpoFtCSIxBt2AK6JYQEmPQLZgCuiWExBh0C6aAbgkhMQbdgimgW0JIjEG3YArolhASY9AtmAK6JYTEGHQLpoBuCSExBt2CKaBbQkiMQbdgCuiWEBJj0C2YArolhMQYdAumgG4JITEG3YIpoFtCSIxBt2AK6JYQEmPQLZgCuiWExBh0C6aAbgkhMQbdgikkVrfrl9z93LzJT//2ZkPy6qKpe5bP0fuBxBgGYQRBt2AKCdTtC/NvHXve6GOPH3rmyDNHn/VjQzL05GHikGdOGtfx2ly9T0jEYRDqfRJS0C2YQtJ0u+iua8Ubfs7t07YuW9a3apVReWXBokvOHyNm+dYXZ+s9QyILgzDKQYhuwRQSpdtXF00V09zS383TZwFDcnDlygmXjrvupxfonUOiCYMw4kGIbsEUEqXbKy+uveemyfr736g0Ll0qpnsx6ev9QyIIg7Av2kGIbvPTUFdTU9egtpZEy+JMTW19i9pccVrqayu2z1VJcnTb+uJs8Q5/Z8kT+pvftEy66mczJ43Tu4iEHQahl8gGYWp121SfqfHI1Depz7s0ZOUiA/fQCucVg3hJIbxV2bq1vOuSWdyS2ze7ofAhDIBi+2xr2Ca7wm3z9V6useJ4e6VS3sGWSnJ0+8Yf7xQz3cGVK/V3vmmZd0fdNcn4pZgWBqGXyAZhanXb5zkjqxvGhyubPB4qjFzzoF5SCLkqt7q1imbHtRJp3EroR7ot/z47nZDbrivCEF0rkRvKFffanvSP1UWDWb4gydHt6sfqxEynv+0NzPw7Z1z97+frXUTCDoPQS2SDsOp1WxJVqltlN6y+i1q3fYM+6W13ILqt1kQ20xElDEIvkQ1CdJuPatWt01f5Ti+HRFC39un0wf2+tB4rHXSbwEQ20xElDEIvkQ3CKtZtTiqqV7wXFroA7NOtVwhaS+Qm/cDK1Tuh/KutzQxGt8HV+l7oENhhG8+vjtjszbm4R+2t1t6QbyXaAi7edp3TztmGwIXYAX8+COhWbsX9ffX3W/D3fA55vMoh+PbN6ttA/9e3BNZ/dIP2Hog+zHReIpvpiBIGoZfIBmEV69ZBztpqGRe8iUk95+mvboPlqU3QkXlf627RcYZ2FjeIsyrnWdeg8tYqzc3e8doPVS/mPSLhuUy2zl2b9VQmY/s1sJOFtuutWS7gPByYcQOSlvh+X8X22UHdGT92V2dq7f6uawgeRT61n3Mb1W3SEtlMR5QwCL1ENgjN1q3iSF23eVyrC8ApDfOqS1lDf9VtEHsncwvn25kc8ojyb9fSbf1iZwFrH+rq/fusomxXs6B2FIVRrW9tU9Vtod+CjdbbPtxPNvmftVcuD9BeSebyWZxMTlwim+mIEgahl8gGodm6zS+n3DwuUV5boEKVk35AvRaD1q16XjfgEl+xOJgjsnXbJKvhbLZWvFbbzyLbVdbsKtDfUpCgUNVrt8X22aF/3Rb6/CGPyHrWPvC6Bq7dJjCRzXRECYPQS2SDEN3aFNBtdrH8IVB9asr0o2lsMLp1/zA3cJo674Y85ReUYh7dekIVPRbYz362WzndqhTbZ4cydOsUtbKsF0eKbhOYyGY6ooRB6CWyQVhtulXrp3J0G7hUmVtnHtlYyweuvxY6A6w+G9CtVukW1q2NVGbwEnL+I5K6dffcavTrtr/tqrp1Xlt4x3zk0621G7Kl2D77Fva25etn96G6fBB5aM4yaddtw9XyYMY3aE8NMO4ayl1PBRPZTEeUlDYIS8nSrD3vOGRmPK8uEHciG4TVpVtVDBbl6tbza25adyZx1zfBW5acvfIbdFC6dXfVWY+8FSgnS9+ByOXdwy92RI5ufR7VdVtwu+4HDme33cLa2a770GdBP5puAx9Wiu2zi28Ze1u+X3fe5YP4Ozztuu1b9Xz9j2pK1qR0bXbhKnc9iZj4IpvpiJJSB+EgI137o2yL+HnheGvY5QawPQ6vXqC+JPJENghTq1vXATquzNSLkbmn/K+15nFXijX23O36Js9D5a7gPO02vpe4p6OtHx/yXfS198S/EltXgW0J/wVtne+QHUcWPaK/5gQp2v1nle3WFQParnMDsL/dpphu8+2wxNpo0X32GVTb2z51h+UzgV+Bi9/QZuu2nNeGmMhmOqKk1EE4yNiKLfDBboH1lke3oVE53UJk2F70VdXpIXiWAt2W+toQE9lMR5SUOggHmcK6bZkx3PqcjG5DA92mDX8NWvS0baLwbiXz73PV6DbruwQbmMiCF8ns88arnBpCxedd5xSfg/Mq36pEizMz+hdwz0g7lDppRjbTESWlDkItwfHjjQT/mPGQw7XIU/nWObx+qdWYu/PAOjXtG9XyTHUZiWwQolswhWrRrYX/EmxAkO7U47tS63+tVt3Kec2dItVX+aSbmbHAtzm5NmceVFYyqEQ20xElpQ7CYOSv3h110qO+UVesui04bALtwZEWuN1vfENw6yUnskGIbsEUqka33nTmPx2nmlKdy/LqVpYIublMcban28AEmmflcj2ayweQyGY6oqTUQVg0ulz1luBTmm5Vv8pB7q3B0W3ZivUnskGIbsEUqkW3PjvmPt0Xecr/2qARHZv6G4PiVOzrRpkB82h7wIlspiNKSh2EeRL8A7Mydat+dFMu8aofKyuRyAYhugVTqGrd5rtAG5jICus2YNMB6VaZXm1KKW37IpzpiJJSB2EwyvkPXa56S/ApVbfB+w8k/pej24GDbiE2qk+3vg/+6nlmLfl0q1USql8L6LaC95RGNtMRJaUOwkCk/HI61OWqtwSf0kZRP2dK0O3AQbcQG9WiW+Xe4AL3K9mm9E1zeXWr3tui3upSQLeap+2V51ms/0Q20xElpQ7CQPLr9kfDc2OjiG7l6LJHrD3wnJeolyrsNXhjEt0OHHQLsVEVuh2esY3r4Z931L+vCN4v6iNQOhS48KadnVZsqp70K1iOFE9kMx1RUuogVKKNE0neCxxqIRsYe/oZ4xw5JQeolHQjG4ToFkwh/bqtwkQ20xElDEIvkQ1CdAumgG4TmMhmOqKEQeglskGIbsEU0G0CE9lMR5QwCL1ENgjRLZgCuk1gIpvpiBIGoZfIBiG6BVNAtwlMZDMdUcIg9BLZIES3YAroNoGJbKYjShiEXiIbhOgWTCE5un3jj3eKme7gypX6O9+0zLuj7ppk/FJMC4PQS2SDEN2CKSRHt60vzhYz3TtLntDf+aZl0lU/mzlpnN5FJOwwCL1ENgjRLZhCcnQrcuXFtffcNFl/5xuVxqVLxYz/6qKpev+QCMIg7It2EKJbMIVE6Va8vcWbfOnv5unvf0NycOXKCZeOu+6nF+idQ6IJgzDiQYhuwRQSpVuRRXddKya7ObdP27psmT4RVHdeWbDokvPHjD1vdOuLs/WeIZGFQRjlIES3YApJ063IC/NvFe92Md+dOfLM0Wf92JAMPXmYOOSZk8Z1vDZX7xMScRiEep+EFHQLppBA3cqsX3L3c/MmP/3bmw3Jq4um7lk+R+8HEmMYhBEE3YIpJFa3hBATgm7BFNAtISTGoFswBXRLCIkx6BZMAd0SQmIMugVTQLeEkBiDbsEU0C0hJMagWzAFdEsIiTHoFkwB3RJCYgy6BVNAt4SQGINuwRTQLSEkxqBbMAV0SwiJMegWTAHdEkJiDLoFU0C3hJAYg27BFNAtISTGoFswBXRLCIkx6BZMAd0SQmIMugVTQLeEkBiDbsEU0C0hJMagWzAFdEsIiTHoFkwB3RJCYgy6BVNAt4SQGINuwRSkbgkhJLagWzABoVtCCIk36sQUGugWAAAgdNAtAABA6KBbAACA0EG3AAAAoYNuAQAAQgfdAgAAhA66BQAACB10CwAAEDroFgAAIHTQLQAAQOigWwAAgNBBtwAAAKGDbgEAAEIH3QIAAIQOugUAAAgddAsAABA66BYAACB00C0AAEDooFsAAIDQQbcAAAChg24BAABCB90CAACEzv8Dt0E6QPEOuU0AAAAASUVORK5CYII=" width="634" height="309" class="img_ev3q">
从而实现插入的顺序或访问顺序。
<img decoding="async" loading="lazy" alt="LinkedHashMap实现有序性" src="/doc/assets/images/LinkedHashMap实现有序性-b725d400a9d69f94044013544f3329b6.png" width="727" height="499" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="讲讲-treemap-怎么实现有序的">讲讲 TreeMap 怎么实现有序的？<a href="#讲讲-treemap-怎么实现有序的" class="hash-link" aria-label="Direct link to 讲讲 TreeMap 怎么实现有序的？" title="Direct link to 讲讲 TreeMap 怎么实现有序的？">​</a></h3>
<p>TreeMap 通过 key 的比较器来决定元素的顺序，如果没有指定比较器，那么 key 必须实现 Comparable 接口。
TreeMap 的底层是红黑树，红黑树是一种自平衡的二叉查找树，每个节点都大于其左子树中的任何节点，小于其右子节点树种的任何节点。
<img decoding="async" loading="lazy" alt="TreeMap结构" src="/doc/assets/images/TreeMap结构-4f94b4de753934cec9daff27290dda44.png" width="1231" height="548" class="img_ev3q">
插入或者删除元素时通过旋转和染色来保持树的平衡。
查找的时候从根节点开始，利用二叉查找树的特点，逐步向左子树或者右子树递归查找，直到找到目标元素。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="treemap-和-hashmap-的区别">TreeMap 和 HashMap 的区别<a href="#treemap-和-hashmap-的区别" class="hash-link" aria-label="Direct link to TreeMap 和 HashMap 的区别" title="Direct link to TreeMap 和 HashMap 的区别">​</a></h3>
<p>①、HashMap 是基于数组+链表+红黑树实现的，put 元素的时候会先计算 key 的哈希值，然后通过哈希值计算出元素在数组中的存放下标，然后将元素插入到指定的位置，如果发生哈希冲突，会使用链表来解决，如果链表长度大于 8，会转换为红黑树。
②、TreeMap 是基于红黑树实现的，put 元素的时候会先判断根节点是否为空，如果为空，直接插入到根节点，如果不为空，会通过 key 的比较器来判断元素应该插入到左子树还是右子树。</p>
<p>在没有发生哈希冲突的情况下，HashMap 的查找效率是 O(1)。适用于查找操作比较频繁的场景。
TreeMap 的查找效率是 O(logn)。并且保证了元素的顺序，因此适用于需要大量范围查找或者有序遍历的场景。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="set">Set<a href="#set" class="hash-link" aria-label="Direct link to Set" title="Direct link to Set">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="讲讲-hashset-的底层实现">讲讲 HashSet 的底层实现？<a href="#讲讲-hashset-的底层实现" class="hash-link" aria-label="Direct link to 讲讲 HashSet 的底层实现？" title="Direct link to 讲讲 HashSet 的底层实现？">​</a></h3>
<p>HashSet 是由 HashMap 实现的，只不过值由一个固定的 Object 对象填充，而键用于操作。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class HashSet&lt;E&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    extends AbstractSet&lt;E&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    implements Set&lt;E&gt;, Cloneable, java.io.Serializable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static final long serialVersionUID = -5024744406713321676L;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private transient HashMap&lt;E,Object&gt; map;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Dummy value to associate with an Object in the backing Map</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final Object PRESENT = new Object();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ……</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>实际开发中，HashSet 并不常用，比如，如果我们需要按照顺序存储一组元素，那么 ArrayList 和 LinkedList 更适合；如果我们需要存储键值对并根据键进行查找，那么 HashMap 可能更适合。
HashSet 主要用于去重，比如，我们需要统计一篇文章中有多少个不重复的单词，就可以使用 HashSet 来实现。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 创建一个 HashSet 对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">HashSet&lt;String&gt; set = new HashSet&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 添加元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">set.add(&quot;沉默&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">set.add(&quot;王二&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">set.add(&quot;陈清扬&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">set.add(&quot;沉默&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 输出 HashSet 的元素个数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;HashSet size: &quot; + set.size()); // output: 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 遍历 HashSet</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for (String s : set) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>HashSet 会自动去重，因为它是用 HashMap 实现的，HashMap 的键是唯一的，相同键会覆盖掉原来的键，于是第二次 add 一个相同键的元素会直接覆盖掉第一次的键。
<img decoding="async" loading="lazy" alt="HashSet" src="data:image/png;base64,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" width="449" height="286" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="hashset-和-arraylist-的区别">HashSet 和 ArrayList 的区别<a href="#hashset-和-arraylist-的区别" class="hash-link" aria-label="Direct link to HashSet 和 ArrayList 的区别" title="Direct link to HashSet 和 ArrayList 的区别">​</a></h3>
<p>ArrayList 是基于动态数组实现的，HashSet 是基于 HashMap 实现的。
ArrayList 允许重复元素和 null 值，可以有多个相同的元素；HashSet 保证每个元素唯一，不允许重复元素，基于元素的 hashCode 和 equals 方法来确定元素的唯一性。
ArrayList 保持元素的插入顺序，可以通过索引访问元素；HashSet 不保证元素的顺序，元素的存储顺序依赖于哈希算法，并且可能随着元素的添加或删除而改变。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="hashset-怎么判断元素重复重复了是否-put">HashSet 怎么判断元素重复，重复了是否 put<a href="#hashset-怎么判断元素重复重复了是否-put" class="hash-link" aria-label="Direct link to HashSet 怎么判断元素重复，重复了是否 put" title="Direct link to HashSet 怎么判断元素重复，重复了是否 put">​</a></h3>
<p>HashSet 的 add 方法是通过调用 HashMap 的 put 方法实现的：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public boolean add(E e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return map.put(e, PRESENT)==null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>所以 HashSet 判断元素重复的逻辑底层依然是 HashMap 的底层逻辑：
![HashMap put 流程](image/java_collection_review/HashMap put 流程.png)
HashMap 在插入元素时，通常需要三步：
第一步，通过 hash 方法计算 key 的哈希值。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static final int hash(Object key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int h;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>第二步，数组进行第一次扩容。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">if ((tab = table) == null || (n = tab.length) == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    n = (tab = resize()).length;</span><br></span></code></pre></div></div>
<p>第三步，根据哈希值计算 key 在数组中的下标，如果对应下标正好没有存放数据，则直接插入。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    tab[i] = newNode(hash, key, value, null);</span><br></span></code></pre></div></div>
<p>如果对应下标已经有数据了，就需要判断是否为相同的 key，是则覆盖 value，否则需要判断是否为树节点，是则向树中插入节点，否则向链表中插入数据。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Node&lt;K,V&gt; e; K k;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (p.hash == hash &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        e = p;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else if (p instanceof TreeNode)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int binCount = 0; ; ++binCount) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if ((e = p.next) == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                p.next = newNode(hash, key, value, null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    treeifyBin(tab, hash);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (e.hash == hash &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            p = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>也就是说，HashSet 通过元素的哈希值来判断元素是否重复，如果重复了，会覆盖原来的值。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">if (e != null) { // existing mapping for key</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    V oldValue = e.value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!onlyIfAbsent || oldValue == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        e.value = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    afterNodeAccess(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return oldValue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3></h3>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-1"><a href="#-1" class="hash-link" aria-label="Direct link to -1" title="Direct link to -1">​</a></h3>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-2"><a href="#-2" class="hash-link" aria-label="Direct link to -2" title="Direct link to -2">​</a></h3>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-3"><a href="#-3" class="hash-link" aria-label="Direct link to -3" title="Direct link to -3">​</a></h3>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-4"><a href="#-4" class="hash-link" aria-label="Direct link to -4" title="Direct link to -4">​</a></h3>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-5"><a href="#-5" class="hash-link" aria-label="Direct link to -5" title="Direct link to -5">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="基本类型">基本类型<a href="#基本类型" class="hash-link" aria-label="Direct link to 基本类型" title="Direct link to 基本类型">​</a></h4></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-tags-row"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a rel="tag" class="tag_zVej tagRegular_sFm0" href="/doc/docs/tags/interview">INTERVIEW</a></li><li class="tag_QGVx"><a rel="tag" class="tag_zVej tagRegular_sFm0" href="/doc/docs/tags/java">JAVA</a></li></ul></div></div><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/JAVA/java_collection_review.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/doc/docs/INTERVIEW/JAVA/JVM"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">JAVA-JVM</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/doc/docs/INTERVIEW/JAVA/JAVA-JUC"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">JAVA-JUC</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#基础语法" class="table-of-contents__link toc-highlight">基础语法</a><ul><li><a href="#说说有哪些常见的集合框架" class="table-of-contents__link toc-highlight">🌟说说有哪些常见的集合框架？</a></li><li><a href="#集合框架有哪几个常用工具类" class="table-of-contents__link toc-highlight">集合框架有哪几个常用工具类？</a></li><li><a href="#简单介绍一下队列" class="table-of-contents__link toc-highlight">简单介绍一下队列</a></li><li><a href="#用过哪些集合类它们的优劣" class="table-of-contents__link toc-highlight">用过哪些集合类，它们的优劣？</a></li><li><a href="#队列和栈的区别了解吗" class="table-of-contents__link toc-highlight">队列和栈的区别了解吗？</a></li><li><a href="#哪些是线程安全的容器" class="table-of-contents__link toc-highlight">哪些是线程安全的容器？</a></li><li><a href="#collection-继承了哪些接口" class="table-of-contents__link toc-highlight">Collection 继承了哪些接口？</a></li></ul></li><li><a href="#list" class="table-of-contents__link toc-highlight">List</a><ul><li><a href="#arraylist-和-linkedlist-有什么区别" class="table-of-contents__link toc-highlight">🌟ArrayList 和 LinkedList 有什么区别？</a></li><li><a href="#arraylist-和-linkedlist-是否支持随机访问" class="table-of-contents__link toc-highlight">ArrayList 和 LinkedList 是否支持随机访问？</a></li><li><a href="#arraylist-和-linkedlist-内存占用有何不同" class="table-of-contents__link toc-highlight">ArrayList 和 LinkedList 内存占用有何不同？</a></li><li><a href="#arraylist-和-linkedlist-的使用场景有什么不同" class="table-of-contents__link toc-highlight">ArrayList 和 LinkedList 的使用场景有什么不同？</a></li><li><a href="#链表和数组有什么区别" class="table-of-contents__link toc-highlight">链表和数组有什么区别？</a></li><li><a href="#arraylist-的扩容机制了解吗" class="table-of-contents__link toc-highlight">ArrayList 的扩容机制了解吗？</a></li><li><a href="#arraylist-怎么序列化的知道吗" class="table-of-contents__link toc-highlight">ArrayList 怎么序列化的知道吗？</a></li><li><a href="#为什么-arraylist-不直接序列化元素数组呢" class="table-of-contents__link toc-highlight">为什么 ArrayList 不直接序列化元素数组呢？</a></li><li><a href="#快速失败fail-fast了解吗" class="table-of-contents__link toc-highlight">快速失败fail-fast了解吗？</a></li><li><a href="#什么是安全失败failsafe呢" class="table-of-contents__link toc-highlight">什么是安全失败（fail—safe）呢？</a></li><li><a href="#有哪几种实现-arraylist-线程安全的方法" class="table-of-contents__link toc-highlight">有哪几种实现 ArrayList 线程安全的方法？</a></li><li><a href="#arraylist-和-vector-的区别" class="table-of-contents__link toc-highlight">ArrayList 和 Vector 的区别？</a></li><li><a href="#copyonwritearraylist-了解多少" class="table-of-contents__link toc-highlight">CopyOnWriteArrayList 了解多少？</a></li></ul></li><li><a href="#map" class="table-of-contents__link toc-highlight">Map</a><ul><li><a href="#能说一下-hashmap-的底层数据结构吗" class="table-of-contents__link toc-highlight">🌟能说一下 HashMap 的底层数据结构吗？</a></li><li><a href="#你对红黑树了解多少" class="table-of-contents__link toc-highlight">你对红黑树了解多少？</a></li><li><a href="#为什么不用二叉树" class="table-of-contents__link toc-highlight">为什么不用二叉树？</a></li><li><a href="#为什么不用平衡二叉树" class="table-of-contents__link toc-highlight">为什么不用平衡二叉树？</a></li><li><a href="#为什么用红黑树" class="table-of-contents__link toc-highlight">为什么用红黑树？</a></li><li><a href="#红黑树怎么保持平衡的" class="table-of-contents__link toc-highlight">红黑树怎么保持平衡的？</a></li><li><a href="#hashmap-的-put-流程知道吗" class="table-of-contents__link toc-highlight">🌟HashMap 的 put 流程知道吗？</a></li><li><a href="#只重写元素的-equals-方法没重写-hashcodeput-的时候会发生什么" class="table-of-contents__link toc-highlight">只重写元素的 equals 方法没重写 hashCode，put 的时候会发生什么?</a></li><li><a href="#hashmap-怎么查找元素的呢" class="table-of-contents__link toc-highlight">HashMap 怎么查找元素的呢？</a></li><li><a href="#hashmap-的-hash-函数是怎么设计的" class="table-of-contents__link toc-highlight">HashMap 的 hash 函数是怎么设计的?</a></li><li><a href="#为什么-hash-函数能减少哈希冲突" class="table-of-contents__link toc-highlight">为什么 hash 函数能减少哈希冲突？</a></li><li><a href="#为什么-hashmap-的容量是-2-的幂次方" class="table-of-contents__link toc-highlight">为什么 HashMap 的容量是 2 的幂次方？</a></li></ul></li><li><a href="#10100101-11000100-00100101-00000000-00000000-00001111" class="table-of-contents__link toc-highlight">10100101 11000100 00100101
&amp;	 00000000 00000000 00001111</a></li><li><a href="#1110-hash--14-0111-length---1--7" class="table-of-contents__link toc-highlight">1110 (hash = 14)
&amp; 0111 (length - 1 = 7)</a><ul><li><a href="#说说什么是取模运算" class="table-of-contents__link toc-highlight">说说什么是取模运算？</a></li><li><a href="#如果初始化-hashmap传一个-17-的容量它会怎么处理" class="table-of-contents__link toc-highlight">如果初始化 HashMap，传一个 17 的容量，它会怎么处理？</a></li><li><a href="#你还知道哪些哈希函数的构造方法呢" class="table-of-contents__link toc-highlight">你还知道哪些哈希函数的构造方法呢？</a></li><li><a href="#解决哈希冲突有哪些方法" class="table-of-contents__link toc-highlight">解决哈希冲突有哪些方法？</a></li><li><a href="#什么是拉链法" class="table-of-contents__link toc-highlight">什么是拉链法？</a></li><li><a href="#为什么-hashmap-链表转红黑树的阈值为-8-呢" class="table-of-contents__link toc-highlight">为什么 HashMap 链表转红黑树的阈值为 8 呢？</a></li><li><a href="#hashmap扩容发生在什么时候呢" class="table-of-contents__link toc-highlight">HashMap扩容发生在什么时候呢？</a></li><li><a href="#hashmap的扩容机制了解吗" class="table-of-contents__link toc-highlight">🌟HashMap的扩容机制了解吗？</a></li><li><a href="#jdk-7-扩容的时候有什么问题" class="table-of-contents__link toc-highlight">JDK 7 扩容的时候有什么问题？</a></li><li><a href="#jdk-8-是怎么解决这个问题的" class="table-of-contents__link toc-highlight">JDK 8 是怎么解决这个问题的？</a></li><li><a href="#jdk-8-对-hashmap-做了哪些优化呢" class="table-of-contents__link toc-highlight">JDK 8 对 HashMap 做了哪些优化呢？</a></li><li><a href="#你能自己设计实现一个-hashmap-吗" class="table-of-contents__link toc-highlight">你能自己设计实现一个 HashMap 吗？</a></li><li><a href="#hashmap-是线程安全的吗" class="table-of-contents__link toc-highlight">🌟HashMap 是线程安全的吗？</a></li><li><a href="#怎么解决-hashmap-线程不安全的问题呢" class="table-of-contents__link toc-highlight">🌟怎么解决 HashMap 线程不安全的问题呢？</a></li><li><a href="#hashmap-内部节点是有序的吗" class="table-of-contents__link toc-highlight">HashMap 内部节点是有序的吗？</a></li><li><a href="#讲讲-linkedhashmap-怎么实现有序的" class="table-of-contents__link toc-highlight">讲讲 LinkedHashMap 怎么实现有序的？</a></li><li><a href="#讲讲-treemap-怎么实现有序的" class="table-of-contents__link toc-highlight">讲讲 TreeMap 怎么实现有序的？</a></li><li><a href="#treemap-和-hashmap-的区别" class="table-of-contents__link toc-highlight">TreeMap 和 HashMap 的区别</a></li></ul></li><li><a href="#set" class="table-of-contents__link toc-highlight">Set</a><ul><li><a href="#讲讲-hashset-的底层实现" class="table-of-contents__link toc-highlight">讲讲 HashSet 的底层实现？</a></li><li><a href="#hashset-和-arraylist-的区别" class="table-of-contents__link toc-highlight">HashSet 和 ArrayList 的区别</a></li><li><a href="#hashset-怎么判断元素重复重复了是否-put" class="table-of-contents__link toc-highlight">HashSet 怎么判断元素重复，重复了是否 put</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/doc/docs/intro">Tutorial</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://x.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">X<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/doc/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>