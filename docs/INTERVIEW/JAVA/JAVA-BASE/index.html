<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-JAVA/JAVA-BASE" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.8.1">
<title data-rh="true">JAVA-BASE | My Site</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://your-docusaurus-site.example.com/doc/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://your-docusaurus-site.example.com/doc/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://your-docusaurus-site.example.com/doc/docs/INTERVIEW/JAVA/JAVA-BASE"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="JAVA-BASE | My Site"><meta data-rh="true" name="description" content="JAVA-BASE"><meta data-rh="true" property="og:description" content="JAVA-BASE"><link data-rh="true" rel="icon" href="/doc/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://your-docusaurus-site.example.com/doc/docs/INTERVIEW/JAVA/JAVA-BASE"><link data-rh="true" rel="alternate" href="https://your-docusaurus-site.example.com/doc/docs/INTERVIEW/JAVA/JAVA-BASE" hreflang="en"><link data-rh="true" rel="alternate" href="https://your-docusaurus-site.example.com/doc/docs/INTERVIEW/JAVA/JAVA-BASE" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"java","item":"https://your-docusaurus-site.example.com/doc/docs/JAVA/"},{"@type":"ListItem","position":2,"name":"JAVA-BASE","item":"https://your-docusaurus-site.example.com/doc/docs/INTERVIEW/JAVA/JAVA-BASE"}]}</script><link rel="alternate" type="application/rss+xml" href="/doc/blog/rss.xml" title="My Site RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/doc/blog/atom.xml" title="My Site Atom Feed"><link rel="stylesheet" href="/doc/assets/css/styles.8d5b4fe0.css">
<script src="/doc/assets/js/runtime~main.1f9c75d1.js" defer="defer"></script>
<script src="/doc/assets/js/main.01ab3953.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t="light";var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",e||t),document.documentElement.setAttribute("data-theme-choice",e||t)}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/doc/img/logo.svg"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/doc/"><div class="navbar__logo"><img src="/doc/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/doc/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">My Site</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/doc/docs/intro">Tutorial</a><a class="navbar__item navbar__link" href="/doc/blog">Blog</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="Switch between dark and light mode (currently system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/doc/docs/intro">Tutorial Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/doc/docs/category/tutorial---basics">Tutorial - Basics</a><button aria-label="Expand sidebar category &#x27;Tutorial - Basics&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/doc/docs/category/tutorial---extras">Tutorial - Extras</a><button aria-label="Expand sidebar category &#x27;Tutorial - Extras&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/doc/docs/JAVA/">java</a><button aria-label="Collapse sidebar category &#x27;java&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/doc/docs/INTERVIEW/JAVA/JAVA-AQS">JAVA-AQS</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/doc/docs/INTERVIEW/JAVA/JAVA-COLLECTION">JAVA-COLLECTION</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/doc/docs/INTERVIEW/JAVA/JAVA-JUC">JAVA-JUC</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/doc/docs/INTERVIEW/JAVA/JVM">JAVA-JVM</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/doc/docs/INTERVIEW/JAVA/JAVA-BASE">JAVA-BASE</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/MQ">MQ</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/MYSQL/MYSQL-REVIEW">MYSQL</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/NGINX/NGINX-REVIEW">NGINX</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/intereview/redis">REDIS</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/SPRING/SPRING-REVIEW">SPRING</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/doc/docs/tmp">tmp</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/分布式/分布式-REVIEW">分布式</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/微服务/微服务-REVIEW">微服务</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/doc/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><a class="breadcrumbs__link" href="/doc/docs/JAVA/"><span>java</span></a></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">JAVA-BASE</span></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>JAVA-BASE</h1></header><h2 class="anchor anchorWithStickyNavbar_LWe7" id="基础语法">基础语法<a href="#基础语法" class="hash-link" aria-label="Direct link to 基础语法" title="Direct link to 基础语法">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="java-有哪些数据类型">🌟Java 有哪些数据类型？<a href="#java-有哪些数据类型" class="hash-link" aria-label="Direct link to 🌟Java 有哪些数据类型？" title="Direct link to 🌟Java 有哪些数据类型？">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="基本类型">基本类型<a href="#基本类型" class="hash-link" aria-label="Direct link to 基本类型" title="Direct link to 基本类型">​</a></h4>
<ol>
<li>数值类型<!-- -->
<ul>
<li>浮点： double， float</li>
<li>整数：byte， short， int ， long</li>
</ul>
</li>
<li>字符类型  char</li>
<li>布尔类型  boolean
ps： 布尔类型大小不确定</li>
</ol>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="引用类型">引用类型<a href="#引用类型" class="hash-link" aria-label="Direct link to 引用类型" title="Direct link to 引用类型">​</a></h4>
<p>类  接口  数组</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="boolean-类型实际占用几个字节">boolean 类型实际占用几个字节？<a href="#boolean-类型实际占用几个字节" class="hash-link" aria-label="Direct link to boolean 类型实际占用几个字节？" title="Direct link to boolean 类型实际占用几个字节？">​</a></h3>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="给integer最大值1是什么结果">给Integer最大值+1，是什么结果？<a href="#给integer最大值1是什么结果" class="hash-link" aria-label="Direct link to 给Integer最大值+1，是什么结果？" title="Direct link to 给Integer最大值+1，是什么结果？">​</a></h3>
<p>当给 Integer.MAX_VALUE 加 1 时，会发生溢出，变成 Integer.MIN_VALUE。<br>
<!-- -->这是因为 Java 的整数类型采用的是二进制补码表示法，溢出时值会变成最小值。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="自动类型转换强制类型转换了解吗">自动类型转换、强制类型转换了解吗？<a href="#自动类型转换强制类型转换了解吗" class="hash-link" aria-label="Direct link to 自动类型转换、强制类型转换了解吗？" title="Direct link to 自动类型转换、强制类型转换了解吗？">​</a></h3>
<p>当把一个范围较小的数值或变量赋给另外一个范围较大的变量时，会进行自动类型转换；反之，需要强制转换。</p>
<p>①、float f=3.4，对吗？<br>
<!-- -->不正确。3.4 默认是双精度，将双精度赋值给浮点型属于下转型（down-casting，也称窄化）会造成精度丢失，因此需要强制类型转换float f =(float)3.4;或者写成float f =3.4F</p>
<p>②、short s1 = 1; s1 = s1 + 1；对吗？short s1 = 1; s1 += 1;对吗？<br>
<!-- -->short s1 = 1; s1 = s1 + 1; 会编译出错，由于 1 是 int 类型，因此 s1+1 运算结果也是 int 型，需要强制转换类型才能赋值给 short 型。
而 short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 = (short(s1 + 1); 其中有隐含的强制类型转换</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是自动拆箱装箱">什么是自动拆箱/装箱？<a href="#什么是自动拆箱装箱" class="hash-link" aria-label="Direct link to 什么是自动拆箱/装箱？" title="Direct link to 什么是自动拆箱/装箱？">​</a></h3>
<p>装箱：将基本数据类型转换为包装类型，例如 int 转换为 Integer。
拆箱：将包装类型转换为基本数据类型。
<img decoding="async" loading="lazy" alt="自动拆箱装箱" src="/doc/assets/images/自动拆箱装箱-a6cb2b06cc47bfc0dbf47bebc26bd91c.png" width="945" height="472" class="img_ev3q">
再换句话说，i 是 Integer 类型，n 是 int 类型；变量 i 是包装器类，变量 n 是基本数据类型。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="和有什么区别">&amp;和&amp;&amp;有什么区别？<a href="#和有什么区别" class="hash-link" aria-label="Direct link to &amp;和&amp;&amp;有什么区别？" title="Direct link to &amp;和&amp;&amp;有什么区别？">​</a></h3>
<p>&amp; 是 逻辑与。<br>
<!-- -->&amp;&amp;是短路与运算。逻辑与跟短路与的差别是非常大的， 虽然二者都要求运算符左右两端的布尔值都是 true，整个表达式的值才是 true。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="switch-语句能否用在-bytelongstring-类型上">switch 语句能否用在 byte/long/String 类型上？<a href="#switch-语句能否用在-bytelongstring-类型上" class="hash-link" aria-label="Direct link to switch 语句能否用在 byte/long/String 类型上？" title="Direct link to switch 语句能否用在 byte/long/String 类型上？">​</a></h3>
<p>Java 5 以前 switch(expr) 中，expr 只能是 <code>byte</code>、<code>short</code>、<code>char</code>、<code>int</code>。<br>
<!-- -->从 Java 5 开始，Java 中引入了枚举类型， expr 也可以是 <code>enum</code> 类型。<br>
<!-- -->从 Java 7 开始，expr 还可以是<code>字符串</code>。<br>
<strong><code>byte</code>、<code>short</code>、<code>char</code>、<code>int</code>, <code>enum</code>, <code>String</code></strong></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="breakcontinuereturn-的区别及作用">break,continue,return 的区别及作用？<a href="#breakcontinuereturn-的区别及作用" class="hash-link" aria-label="Direct link to break,continue,return 的区别及作用？" title="Direct link to break,continue,return 的区别及作用？">​</a></h3>
<p>break 跳出整个循环，不再执行循环(结束当前的循环体)<br>
<!-- -->continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)<br>
<!-- -->return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="用效率最高的方法计算-2-乘以-8">用效率最高的方法计算 2 乘以 8？<a href="#用效率最高的方法计算-2-乘以-8" class="hash-link" aria-label="Direct link to 用效率最高的方法计算 2 乘以 8？" title="Direct link to 用效率最高的方法计算 2 乘以 8？">​</a></h3>
<p><code>2 &lt;&lt; 3</code>。位运算，数字的二进制位左移三位相当于乘以 2 的三次方。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说自增自减运算">说说自增自减运算？<a href="#说说自增自减运算" class="hash-link" aria-label="Direct link to 说说自增自减运算？" title="Direct link to 说说自增自减运算？">​</a></h3>
<p>当运算符放在变量之前时(前缀)，先自增/减，再赋值；<br>
<!-- -->当运算符放在变量之后时(后缀)，先赋值，再自增/减。<br>
<!-- -->对于 JVM 而言，它对自增运算的处理，是会先定义一个临时变量来接收 i 的值，然后进行自增运算，<br>
<!-- -->最后又将临时变量赋给了值为 2 的 i，所以最后的结果为 1。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int i  = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">i = i++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(i);</span><br></span></code></pre></div></div>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   int count = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   for(int i = 0;i &lt; 100;i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      count = count++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      System.out.println(count);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   System.out.println(&quot;count = &quot;+count);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>输出0,每次count++返回0赋值给count，每次都在重置<br>
<!-- -->和上面的题目一样的道理，同样是用了临时变量，count 实际是等于临时变量的值。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="float-是怎么表示小数的补充">float 是怎么表示小数的？（补充）<a href="#float-是怎么表示小数的补充" class="hash-link" aria-label="Direct link to float 是怎么表示小数的？（补充）" title="Direct link to float 是怎么表示小数的？（补充）">​</a></h3>
<p>float类型的小数在计算机中是通过 IEEE 754 标准的单精度浮点数格式来表示的。<br>
<img decoding="async" loading="lazy" alt="float计算公式" src="data:image/png;base64,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" width="256" height="70" class="img_ev3q">
S：符号位，0 代表正数，1 代表负数；
M：尾数部分，用于表示数值的精度；<br>
<!-- -->R：基数，十进制中的基数是 10，二进制中的基数是 2；<br>
<!-- -->E：指数部分，例如 中的 -1 就是指数。</p>
<p>这种表示方法可以将非常大或非常小的数值用有限的位数表示出来，但这也意味着可能会有精度上的损失。<br>
<!-- -->单精度浮点数占用 4 字节（32 位），这 32 位被分为三个部分：符号位、指数部分和尾数部分。</p>
<p><img decoding="async" loading="lazy" alt="float存储示意" src="/doc/assets/images/float存储示意-1b5a25272ab48f7e8df08c62b130dd0e.png" width="720" height="164" class="img_ev3q">
符号位（Sign bit）：1 位<br>
<!-- -->指数部分（Exponent）：10 位<br>
<!-- -->尾数部分（Mantissa，或 Fraction）：21 位</p>
<p>按照这个规则，将十进制数 25.125 转换为浮点数，转换过程是这样的：
整数部分：25 转换为二进制是 11001；<br>
<!-- -->小数部分：0.125 转换为二进制是 0.001；<br>
<!-- -->用二进制科学计数法表示：25.125 =<br>
<!-- -->符号位 S 是 0，表示正数；指数部分 E 是 4，转换为二进制是 100；尾数部分 M 是 1.001001。<br>
<img decoding="async" loading="lazy" alt="浮点保存结构" src="/doc/assets/images/浮点保存结构-cddf417942dd3ff81b4ee66ea04c0afd.png" width="732" height="251" class="img_ev3q">
使用浮点数时需要注意，由于精度的限制，进行数学运算时可能会遇到舍入误差，特别是连续运算累积误差可能会变得显著。
对于需要高精度计算的场景（如金融计算），可能需要考虑使用BigDecimal类来避免这种误差。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="讲一下数据准确性高是怎么保证的补充">讲一下数据准确性高是怎么保证的？（补充）<a href="#讲一下数据准确性高是怎么保证的补充" class="hash-link" aria-label="Direct link to 讲一下数据准确性高是怎么保证的？（补充）" title="Direct link to 讲一下数据准确性高是怎么保证的？（补充）">​</a></h3>
<p>在金融计算中，保证数据准确性有两种方案，一种使用 <strong>BigDecimal</strong>，一种将<strong>浮点数转换为整数 int 进行计算</strong>。<br>
<!-- -->肯定不能使用 float 和 double 类型，它们无法避免浮点数运算中常见的精度问题，因为这些数据类型采用二进制浮点数来表示，无法准确地表示，例如 0.1。
在处理小额支付或计算时，通过转换为较小的货币单位（如分），这样不仅提高了运算速度，还保证了计算的准确性。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int priceInCents = 199;  // 商品价格199分</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int quantity = 3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int totalInCents = priceInCents * quantity;  // 计算总价</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;Total price in cents: &quot; + totalInCents);  // 输出597分</span><br></span></code></pre></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="面向对象">面向对象<a href="#面向对象" class="hash-link" aria-label="Direct link to 面向对象" title="Direct link to 面向对象">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="向对象和向过程的区别">⾯向对象和⾯向过程的区别?<a href="#向对象和向过程的区别" class="hash-link" aria-label="Direct link to ⾯向对象和⾯向过程的区别?" title="Direct link to ⾯向对象和⾯向过程的区别?">​</a></h3>
<p>面向过程是以过程为核心，通过函数完成任务，程序结构是函数+步骤组成的顺序流程。
面向对象是以对象为核心，通过对象交互完成任务，程序结构是类和对象组成的模块化结构，代码可以通过继承、组合、多态等方式复用。
在技术派实战项目中，像 VO、DTO 都是业务抽象后的对象实体类，而 Service、Controller 则是业务逻辑的实现，这其实就是面向对象的思想。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="面向对象编程有哪些特性">🌟面向对象编程有哪些特性？<a href="#面向对象编程有哪些特性" class="hash-link" aria-label="Direct link to 🌟面向对象编程有哪些特性？" title="Direct link to 🌟面向对象编程有哪些特性？">​</a></h3>
<p>面向对象编程有三大特性：封装、继承、多态。<br>
<!-- -->封装是指将数据（属性，或者叫字段）和操作数据的方法（行为）捆绑在一起，形成一个独立的对象（类的实例）。<br>
<!-- -->可以看得出，女神类对外没有提供 age 的 getter 方法，因为女神的年龄要保密。<br>
<!-- -->所以，封装是把一个对象的属性私有化，同时提供一些可以被外界访问的方法。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="继承是什么">继承是什么？<a href="#继承是什么" class="hash-link" aria-label="Direct link to 继承是什么？" title="Direct link to 继承是什么？">​</a></h4>
<p>继承允许一个类（子类）继承现有类（父类或者基类）的属性和方法。以提高代码的复用性，建立类之间的层次关系。<br>
<!-- -->同时，子类还可以重写或者扩展从父类继承来的属性和方法，从而实现多态。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="什么是多态">什么是多态？<a href="#什么是多态" class="hash-link" aria-label="Direct link to 什么是多态？" title="Direct link to 什么是多态？">​</a></h4>
<p>多态允许不同类的对象对同一消息做出响应，但表现出不同的行为（即方法的多样性）。<br>
<!-- -->多态其实是一种能力——同一个行为具有不同的表现形式；<br>
<!-- -->换句话说就是，执行一段代码，Java 在运行时能根据对象类型的不同产生不同的结果。
多态的前置条件有三个
<code>子类继承父类</code>
<code>子类重写父类的方法</code>
<code>父类引用指向子类的对象</code></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么java里面要多组合少继承">为什么Java里面要多组合少继承？<a href="#为什么java里面要多组合少继承" class="hash-link" aria-label="Direct link to 为什么Java里面要多组合少继承？" title="Direct link to 为什么Java里面要多组合少继承？">​</a></h3>
<p>继承适合描述“is-a”的关系，但继承容易导致类之间的强耦合，一旦父类发生改变，子类也要随之改变，违背了开闭原则（尽量不修改现有代码，而是添加新的代码来实现）。<br>
<!-- -->组合适合描述“has-a”或“can-do”的关系，通过在类中组合其他类，能够更灵活地扩展功能。组合避免了复杂的类继承体系，同时遵循了开闭原则和松耦合的设计原则。</p>
<p>举个例子，假设我们采用继承，每种形状和样式的组合都会导致类的急剧增加：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 基类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Shape {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void draw() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Drawing a shape&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 圆形</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Circle extends Shape {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void draw() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Drawing a circle&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 带红色的圆形</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class RedCircle extends Circle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void draw() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Drawing a red circle&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 带绿色的圆形</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class GreenCircle extends Circle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void draw() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Drawing a green circle&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 类似的，对于矩形也要创建多个类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Rectangle extends Shape {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void draw() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Drawing a rectangle&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class RedRectangle extends Rectangle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void draw() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Drawing a red rectangle&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>形状干形状的事情。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 圆形的实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Circle implements Shape {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   private Color color;  // 通过组合的方式持有颜色对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   public Circle(Color color) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      this.color = color;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   public void draw() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      System.out.print(&quot;Drawing a circle with &quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      color.applyColor();  // 调用颜色的逻辑</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 矩形的实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Rectangle implements Shape {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   private Color color;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   public Rectangle(Color color) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      this.color = color;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   public void draw() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      System.out.print(&quot;Drawing a rectangle with &quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      color.applyColor();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>颜色干颜色的事情。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 红色的实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class RedColor implements Color {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void applyColor() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;red color&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 绿色的实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class GreenColor implements Color {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void applyColor() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;green color&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="多态解决了什么问题补充">多态解决了什么问题？（补充）<a href="#多态解决了什么问题补充" class="hash-link" aria-label="Direct link to 多态解决了什么问题？（补充）" title="Direct link to 多态解决了什么问题？（补充）">​</a></h3>
<p>多态指同一个接口或方法在不同的类中有不同的实现，比如说动态绑定，父类引用指向子类对象，方法的具体调用会延迟到运行时决定。<br>
<!-- -->举例，现在有一个父类 Wanger，一个子类 Wangxiaoer，都有一个 write 方法。现在有一个父类 Wanger 类型的变量 wanger，它在执行 wanger.write() 时，究竟调用父类 Wanger 的 write() 方法，还是子类 Wangxiaoer 的 write() 方法呢？</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//子类继承父类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Wangxiaoer extends Wanger {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void write() { // 子类覆盖父类方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;记住仇恨，表明我们要奋发图强的心智&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 父类引用指向子类对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Wanger[] wangers = { new Wanger(), new Wangxiaoer() };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (Wanger wanger : wangers) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 对象是王二的时候输出：勿忘国耻</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 对象是王小二的时候输出：记住仇恨，表明我们要奋发图强的心智</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            wanger.write();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Wanger {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void write() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;勿忘国耻&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>答案是在运行时根据对象的类型进行后期绑定，编译器在编译阶段并不知道对象的类型，但是 Java 的方法调用机制能找到正确的方法体，然后执行，得到正确的结果，这就是多态的作用</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="多态的实现原理是什么">多态的实现原理是什么？<a href="#多态的实现原理是什么" class="hash-link" aria-label="Direct link to 多态的实现原理是什么？" title="Direct link to 多态的实现原理是什么？">​</a></h3>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="重载和重写的区别">重载和重写的区别？<a href="#重载和重写的区别" class="hash-link" aria-label="Direct link to 重载和重写的区别？" title="Direct link to 重载和重写的区别？">​</a></h3>
<p>如果一个类有多个名字相同但参数个数不同的方法，我们通常称这些方法为方法重载（overload）。如果方法的功能是一样的，但参数不同，使用相同的名字可以提高程序的可读性。
如果子类具有和父类一样的方法（参数相同、返回类型相同、方法名相同，但方法体可能不同），我们称之为方法重写（override）。方法重写用于提供父类已经声明的方法的特殊实现，是实现多态的基础条件。</p>
<p>方法重载发生在同一个类中，同名的方法如果有不同的参数（参数类型不同、参数个数不同或者二者都不同）。<br>
<!-- -->方法重写发生在子类与父类之间，要求子类与父类具有相同的返回类型，方法名和参数列表，并且不能比父类的方法声明更多的异常，遵守里氏代换原则。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是里氏代换原则">什么是里氏代换原则？<a href="#什么是里氏代换原则" class="hash-link" aria-label="Direct link to 什么是里氏代换原则？" title="Direct link to 什么是里氏代换原则？">​</a></h3>
<p>里氏代换原则也被称为李氏替换原则（Liskov Substitution Principle, LSP），其规定任何父类可以出现的地方，子类也一定可以出现。<br>
<!-- -->LSP 是继承复用的基石，只有当子类可以替换掉父类，并且单位功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。<br>
<!-- -->这意味着子类在扩展父类时，不应改变父类原有的行为。例如，如果有一个方法接受一个父类对象作为参数，那么传入该方法的任何子类对象也应该能正常工作。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Bird {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void fly() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;鸟正在飞&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Duck extends Bird {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void fly() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;鸭子正在飞&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Ostrich extends Bird {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Ostrich违反了LSP，因为鸵鸟不会飞，但却继承了会飞的鸟类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void fly() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new UnsupportedOperationException(&quot;鸵鸟不会飞&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>在这个例子中，Ostrich（鸵鸟）类违反了 LSP 原则，因为它改变了父类 Bird 的行为（即飞行）。设计时应该更加谨慎地使用继承关系，确保遵守 LSP 原则。<br>
<!-- -->除了李氏替换原则外，还有其他几个重要的面向对象设计原则，它们共同构成了 SOLID 原则，分别是：</p>
<p>①、单一职责原则（Single Responsibility Principle, SRP），指一个类应该只有一个引起它变化的原因，即一个类只负责一项职责。这样做的目的是使类更加清晰，更容易理解和维护。<br>
<!-- -->②、开闭原则（Open-Closed Principle, OCP），指软件实体应该对扩展开放，对修改关闭。这意味着一个类应该通过扩展来实现新的功能，而不是通过修改已有的代码来实现。
举个例子，在不遵守开闭原则的情况下，有一个需要处理不同形状的绘图功能类。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class ShapeDrawer {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void draw(Shape shape) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (shape instanceof Circle) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            drawCircle((Circle) shape);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else if (shape instanceof Rectangle) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            drawRectangle((Rectangle) shape);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void drawCircle(Circle circle) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 画圆形</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void drawRectangle(Rectangle rectangle) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 画矩形</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>每增加一种形状，就需要修改一次 draw 方法，这违反了开闭原则。正确的做法是通过继承和多态来实现新的形状类，然后在 ShapeDrawer 中添加新的 draw 方法。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 抽象的 Shape 类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">abstract class Shape {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public abstract void draw();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 具体的 Circle 类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Circle extends Shape {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void draw() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 画圆形</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 具体的 Rectangle 类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Rectangle extends Shape {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void draw() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 画矩形</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 使用开闭原则的 ShapeDrawer 类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class ShapeDrawer {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void draw(Shape shape) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        shape.draw();  // 调用多态的 draw 方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>③、接口隔离原则（Interface Segregation Principle, ISP），指客户端不应该依赖它不需要的接口。这意味着设计接口时应该尽量精简，不应该设计臃肿庞大的接口。<br>
<!-- -->④、依赖倒置原则（Dependency Inversion Principle, DIP），指高层模块不应该依赖低层模块，二者都应该依赖其抽象；<br>
<!-- -->抽象不应该依赖细节，细节应该依赖抽象。这意味着设计时应该尽量依赖接口或抽象类，而不是实现类。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="访问修饰符-publicprivateprotected以及默认时的区别">访问修饰符 public、private、protected、以及默认时的区别？<a href="#访问修饰符-publicprivateprotected以及默认时的区别" class="hash-link" aria-label="Direct link to 访问修饰符 public、private、protected、以及默认时的区别？" title="Direct link to 访问修饰符 public、private、protected、以及默认时的区别？">​</a></h3>
<p>Java 中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。<br>
<!-- -->default （即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。可以修饰在类、接口、变量、方法。<br>
<!-- -->private : 在同一类内可见。可以修饰变量、方法。注意：不能修饰类（外部类）<br>
<!-- -->public : 对所有类可见。可以修饰类、接口、变量、方法<br>
<!-- -->protected : 对同一包内的类和所有子类可见。可以修饰变量、方法。注意：不能修饰类（外部类）。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="this-关键字有什么作用">this 关键字有什么作用？<a href="#this-关键字有什么作用" class="hash-link" aria-label="Direct link to this 关键字有什么作用？" title="Direct link to this 关键字有什么作用？">​</a></h3>
<p>this 是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。<br>
<!-- -->this 的用法在 Java 中大体可以分为 3 种：<br>
<!-- -->普通的直接引用，this 相当于是指向当前对象本身<br>
<!-- -->形参与成员变量名字重名，用 this 来区分
引用本类的构造方法</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="抽象类和接口有什么区别">🌟抽象类和接口有什么区别？<a href="#抽象类和接口有什么区别" class="hash-link" aria-label="Direct link to 🌟抽象类和接口有什么区别？" title="Direct link to 🌟抽象类和接口有什么区别？">​</a></h3>
<p>一个类只能继承一个抽象类；但一个类可以实现多个接口。<br>
<!-- -->所以我们在新建线程类的时候一般推荐使用实现 Runnable 接口的方式，这样线程类还可以继承其他类，而不单单是 Thread 类。</p>
<p>抽象类符合 is-a 的关系，而接口更像是 has-a 的关系，<br>
<!-- -->比如说一个类可以序列化的时候，它只需要实现 Serializable 接口就可以了，不需要去继承一个序列化类。</p>
<p>抽象类更多地是用来为多个相关的类提供一个共同的基础框架，包括状态的初始化，<br>
<!-- -->而接口则是定义一套行为标准，让不同的类可以实现同一接口，提供行为的多样化实现。</p>
<p>还有其他区别： 如抽象类可以有构造函数， 属性， 修饰符没有限制。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="抽象类可以定义构造方法吗">抽象类可以定义构造方法吗？<a href="#抽象类可以定义构造方法吗" class="hash-link" aria-label="Direct link to 抽象类可以定义构造方法吗？" title="Direct link to 抽象类可以定义构造方法吗？">​</a></h3>
<p>可以，抽象类可以有构造方法。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="接口可以定义构造方法吗">接口可以定义构造方法吗？<a href="#接口可以定义构造方法吗" class="hash-link" aria-label="Direct link to 接口可以定义构造方法吗？" title="Direct link to 接口可以定义构造方法吗？">​</a></h3>
<p>不能，接口主要用于定义一组方法规范，没有具体的实现细节。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="java支持多继承吗">Java支持多继承吗？<a href="#java支持多继承吗" class="hash-link" aria-label="Direct link to Java支持多继承吗？" title="Direct link to Java支持多继承吗？">​</a></h3>
<p>Java 不支持多继承，一个类只能继承一个类，多继承会引发菱形继承问题。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="接口可以多继承吗">接口可以多继承吗？<a href="#接口可以多继承吗" class="hash-link" aria-label="Direct link to 接口可以多继承吗？" title="Direct link to 接口可以多继承吗？">​</a></h3>
<p>接口可以多继承，一个接口可以继承多个接口，使用逗号分隔。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="继承和抽象的区别">继承和抽象的区别？<a href="#继承和抽象的区别" class="hash-link" aria-label="Direct link to 继承和抽象的区别？" title="Direct link to 继承和抽象的区别？">​</a></h3>
<p>继承是一种允许子类继承父类属性和方法的机制。通过继承，子类可以重用父类的代码。</p>
<p>抽象是一种隐藏复杂性和只显示必要部分的技术。在面向对象编程中，抽象可以通过抽象类和接口实现。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="抽象类和普通类的区别">抽象类和普通类的区别？<a href="#抽象类和普通类的区别" class="hash-link" aria-label="Direct link to 抽象类和普通类的区别？" title="Direct link to 抽象类和普通类的区别？">​</a></h3>
<p>抽象类使用 abstract 关键字定义，不能被实例化，只能作为其他类的父类。普通类没有 abstract 关键字，可以直接实例化。</p>
<p>抽象类可以包含抽象方法和非抽象方法。抽象方法没有方法体，必须由子类实现。普通类只能包含非抽象方法。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">abstract class Animal {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 抽象方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public abstract void makeSound();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 非抽象方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void eat() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;This animal is eating.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Dog extends Animal {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 实现抽象方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void makeSound() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Woof&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Test {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Dog dog = new Dog();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dog.makeSound(); // 输出 &quot;Woof&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dog.eat(); // 输出 &quot;This animal is eating.&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="成员变量与局部变量的区别有哪些">成员变量与局部变量的区别有哪些？<a href="#成员变量与局部变量的区别有哪些" class="hash-link" aria-label="Direct link to 成员变量与局部变量的区别有哪些？" title="Direct link to 成员变量与局部变量的区别有哪些？">​</a></h3>
<p>从语法形式上看：成员变量是属于类的，⽽局部变量是在⽅法中定义的变量或是⽅法的参数；<br>
<!-- -->成员变量可以被 public , private , static 等修饰符所修饰，⽽局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</p>
<p>从变量在内存中的存储⽅式来看：如果成员变量是使⽤ static 修饰的，那么这个成员变量是属于类的，如果没有使⽤ static 修饰，这个成员变量是属于实例的。<br>
<!-- -->对象存于堆内存，如果局部变量类型为基本数据类型，那么存储在栈内存，如果为引⽤数据类型，那存放的是指向堆内存对象的引⽤或者是指向常量池中的地址。</p>
<p>从变量在内存中的⽣存时间上看：成员变量是对象的⼀部分，它随着对象的创建⽽存在，⽽局部变量随着⽅法的调⽤⽽⾃动消失。<br>
<!-- -->成员变量如果没有被赋初值：则会⾃动以类型的默认值⽽赋值（⼀种情况例外:被 final 修饰的成员变量也必须显式地赋值），⽽局部变量则不会⾃动赋值。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="static-关键字了解吗">static 关键字了解吗？<a href="#static-关键字了解吗" class="hash-link" aria-label="Direct link to static 关键字了解吗？" title="Direct link to static 关键字了解吗？">​</a></h3>
<p>static 关键字可以用来修饰变量、方法、代码块和内部类，以及导入包。</p>
<p>1.静态变量:类级别变量，所有实例共享同一份数据。
2.静态方法:类级别方法，与实例无关。
3.静态代码块:在类加载时初始化一些数据，只执行一次。
4.静态内部类:与外部类绑定但独立于外部类实例。
导入	可以直接访问静态成员，无需通过类名引用，简化代码书写，但会降低代码可读性</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="静态变量和实例变量的区别">静态变量和实例变量的区别？<a href="#静态变量和实例变量的区别" class="hash-link" aria-label="Direct link to 静态变量和实例变量的区别？" title="Direct link to 静态变量和实例变量的区别？">​</a></h4>
<p>静态变量: 是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个副本。<br>
<!-- -->实例变量: 必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="静态法和实例法有何不同">静态⽅法和实例⽅法有何不同?<a href="#静态法和实例法有何不同" class="hash-link" aria-label="Direct link to 静态⽅法和实例⽅法有何不同?" title="Direct link to 静态⽅法和实例⽅法有何不同?">​</a></h4>
<p>类似地。
静态方法：static 修饰的方法，也被称为类方法。在外部调⽤静态⽅法时，可以使⽤&quot;类名.⽅法名&quot;的⽅式，也可以使⽤&quot;对象名.⽅法名&quot;的⽅式。静态方法里不能访问类的非静态成员变量和方法。
实例⽅法：依存于类的实例，需要使用&quot;对象名.⽅法名&quot;的⽅式调用；可以访问类的所有成员变量和方法。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="final-关键字有什么作用">final 关键字有什么作用？<a href="#final-关键字有什么作用" class="hash-link" aria-label="Direct link to final 关键字有什么作用？" title="Direct link to final 关键字有什么作用？">​</a></h3>
<p>①、当 final 修饰一个类时，表明这个类不能被继承。比如，String 类、Integer 类和其他包装类都是用 final 修饰的。<br>
<!-- -->②、当 final 修饰一个方法时，表明这个方法不能被重写（Override）。也就是说，如果一个类继承了某个类，并且想要改变父类中被 final 修饰的方法的行为，是不被允许的。<br>
<!-- -->③、当 final 修饰一个变量时，表明这个变量的值一旦被初始化就不能被修改。</p>
<p>如果是基本数据类型的变量，其数值一旦在初始化之后就不能更改；如果是引用类型的变量，在对其初始化之后就不能再让其指向另一个对象。
但是引用指向的对象内容可以改变。<br>
<img decoding="async" loading="lazy" alt="fianl修饰引用对象.png" src="/doc/assets/images/fianl修饰引用对象-54d659a261194f433026958dfc366258.png" width="849" height="341" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="finalfinallyfinalize-的区别">final、finally、finalize 的区别？<a href="#finalfinallyfinalize-的区别" class="hash-link" aria-label="Direct link to final、finally、finalize 的区别？" title="Direct link to final、finally、finalize 的区别？">​</a></h3>
<p>①、final 是一个修饰符，可以修饰类、方法和变量。当 final 修饰一个类时，表明这个类不能被继承；当 final 修饰一个方法时，表明这个方法不能被重写；当 final 修饰一个变量时，表明这个变量是个常量，一旦赋值后，就不能再被修改了。<br>
<!-- -->②、finally 是 Java 中异常处理的一部分，用来创建 try 块后面的 finally 块。无论 try 块中的代码是否抛出异常，finally 块中的代码总是会被执行。通常，finally 块被用来释放资源，如关闭文件、数据库连接等。<br>
<!-- -->③、finalize 是Object 类的一个方法，用于在垃圾回收器将对象从内存中清除出去之前做一些必要的清理工作。</p>
<p>这个方法在垃圾回收器准备释放对象占用的内存之前被自动调用。我们不能显式地调用 finalize 方法，因为它总是由垃圾回收器在适当的时间自动调用。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么重写-equals-时必须重写-hashcode-法">🌟为什么重写 equals 时必须重写 hashCode ⽅法？<a href="#为什么重写-equals-时必须重写-hashcode-法" class="hash-link" aria-label="Direct link to 🌟为什么重写 equals 时必须重写 hashCode ⽅法？" title="Direct link to 🌟为什么重写 equals 时必须重写 hashCode ⽅法？">​</a></h3>
<p>因为基于哈希的集合类（如 HashMap）需要基于这一点来正确存储和查找对象。<br>
<!-- -->具体地说，HashMap 通过对象的哈希码将其存储在不同的“桶”中，当查找对象时，它需要使用 key 的哈希码来确定对象在哪个桶中，然后再通过 equals() 方法找到对应的对象。
如果重写了 equals()方法而没有重写 hashCode()方法，那么被认为相等的对象可能会有不同的哈希码，从而导致无法在 HashMap 中正确处理这些对象。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是-hashcode-方法">什么是 hashCode 方法？<a href="#什么是-hashcode-方法" class="hash-link" aria-label="Direct link to 什么是 hashCode 方法？" title="Direct link to 什么是 hashCode 方法？">​</a></h3>
<p>hashCode() 方法的作⽤是获取哈希码，它会返回⼀个 int 整数，定义在 Object 类中， 是一个本地⽅法。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么要有-hashcode-方法">为什么要有 hashCode 方法？<a href="#为什么要有-hashcode-方法" class="hash-link" aria-label="Direct link to 为什么要有 hashCode 方法？" title="Direct link to 为什么要有 hashCode 方法？">​</a></h3>
<p>hashCode 方法主要用来获取对象的哈希码，哈希码是由对象的内存地址或者对象的属性计算出来的，它是⼀个 int 类型的整数，通常是不会重复的，因此可以用来作为键值对的建，以提高查询效率。<br>
<!-- -->例如 HashMap 中的 key 就是通过 hashCode 来实现的， 通过调用 hashCode 方法获取键的哈希码，并将其与右移 16 位的哈希码进行异或运算。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static final int hash(Object key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int h;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么两个对象有相同的-hashcode-值它们也不定相等">为什么两个对象有相同的 hashcode 值，它们也不⼀定相等？<a href="#为什么两个对象有相同的-hashcode-值它们也不定相等" class="hash-link" aria-label="Direct link to 为什么两个对象有相同的 hashcode 值，它们也不⼀定相等？" title="Direct link to 为什么两个对象有相同的 hashcode 值，它们也不⼀定相等？">​</a></h3>
<p>这主要是由于哈希码（hashCode）的本质和目的所决定的。<br>
<!-- -->哈希码是通过哈希函数将对象中映射成一个整数值，其主要目的是在哈希表中快速定位对象的存储位置。<br>
<!-- -->由于哈希函数将一个较大的输入域映射到一个较小的输出域，不同的输入值（即不同的对象）可能会产生相同的输出值（即相同的哈希码）。<br>
<!-- -->这种情况被称为哈希冲突。当两个不相等的对象发生哈希冲突时，它们会有相同的 hashCode。<br>
<!-- -->为了解决哈希冲突的问题，哈希表在处理键时，不仅会比较键对象的哈希码，还会使用 equals 方法来检查键对象是否真正相等。<br>
<!-- -->如果两个对象的哈希码相同，但通过 equals 方法比较结果为 false，那么这两个对象就不被视为相等。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">if (p.hash == hash &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    e = p;</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="hashcode-和-equals-方法的关系">hashCode 和 equals 方法的关系？<a href="#hashcode-和-equals-方法的关系" class="hash-link" aria-label="Direct link to hashCode 和 equals 方法的关系？" title="Direct link to hashCode 和 equals 方法的关系？">​</a></h3>
<p>如果两个对象通过 equals 相等，它们的 hashCode 必须相等。否则会导致哈希表类数据结构（如 HashMap、HashSet）的行为异常。<br>
<!-- -->在哈希表中，如果 equals 相等但 hashCode 不相等，哈希表可能无法正确处理这些对象，导致重复元素或键值冲突等问题。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="java-是值传递还是引用传递">Java 是值传递，还是引用传递？<a href="#java-是值传递还是引用传递" class="hash-link" aria-label="Direct link to Java 是值传递，还是引用传递？" title="Direct link to Java 是值传递，还是引用传递？">​</a></h3>
<p>Java 是值传递，不是引用传递。<br>
<!-- -->当一个对象被作为参数传递到方法中时，参数的值就是该对象的引用。引用的值是对象在堆中的地址。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Integer testNumber = Integer.valueOf(11111);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;orginal: &quot; + testNumber);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        testRef(testNumber);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;testRef: &quot; + testNumber);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static void testRef(Integer testNumber) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        testNumber = Integer.valueOf(2222);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre></div></div>
<p>对象是存储在堆中的，所以传递对象的时候，可以理解为把变量存储的对象地址给传递过去。<br>
<img decoding="async" loading="lazy" alt="对象传值到方法中.png" src="/doc/assets/images/对象传值到方法中-6f871c31417f0c6145e0d6599d1ca38c.png" width="1037" height="330" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="引用类型的变量有什么特点">引用类型的变量有什么特点？<a href="#引用类型的变量有什么特点" class="hash-link" aria-label="Direct link to 引用类型的变量有什么特点？" title="Direct link to 引用类型的变量有什么特点？">​</a></h3>
<p>引用类型的变量存储的是对象的地址，而不是对象本身。
因此，引用类型的变量在传递时，传递的是对象的地址，也就是说，传递的是引用的值。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说深拷贝和浅拷贝的区别">说说深拷贝和浅拷贝的区别?<a href="#说说深拷贝和浅拷贝的区别" class="hash-link" aria-label="Direct link to 说说深拷贝和浅拷贝的区别?" title="Direct link to 说说深拷贝和浅拷贝的区别?">​</a></h3>
<p>在 Java 中，深拷贝（Deep Copy）和浅拷贝（Shallow Copy）是两种拷贝对象的方式，它们在拷贝对象的方式上有很大不同。
<img decoding="async" loading="lazy" alt="深拷贝和浅拷贝.png" src="/doc/assets/images/深拷贝和浅拷贝-898380da697863634f4d500516da3b08.png" width="1127" height="515" class="img_ev3q">
浅拷贝会创建一个新对象，但这个新对象的属性（字段）和原对象的属性完全相同。如果属性是基本数据类型，拷贝的是基本数据类型的值；如果属性是引用类型，拷贝的是引用地址，因此新旧对象共享同一个引用对象。</p>
<p>浅拷贝的实现方式为：实现 Cloneable 接口并重写 clone() 方法。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Person implements Cloneable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int age;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Address address;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Person(String name, int age, Address address) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.name = name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.age = age;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.address = address;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected Object clone() throws CloneNotSupportedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return super.clone();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Address {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String city;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Address(String city) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.city = city;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Main {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws CloneNotSupportedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Address address = new Address(&quot;河南省洛阳市&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Person person1 = new Person(&quot;沉默王二&quot;, 18, address);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Person person2 = (Person) person1.clone();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(person1.address == person2.address); // true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>深拷贝也会创建一个新对象，但会递归地复制所有的引用对象，确保新对象和原对象完全独立。新对象与原对象的任何更改都不会相互影响。<br>
<!-- -->深拷贝的实现方式有：手动复制所有的引用对象，或者使用序列化与反序列化。</p>
<p>①、手动拷贝</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Person {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int age;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Address address;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Person(String name, int age, Address address) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.name = name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.age = age;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.address = address;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Person(Person person) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.name = person.name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.age = person.age;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.address = new Address(person.address.city);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Address {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String city;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Address(String city) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.city = city;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Main {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Address address = new Address(&quot;河南省洛阳市&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Person person1 = new Person(&quot;沉默王二&quot;, 18, address);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Person person2 = new Person(person1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(person1.address == person2.address); // false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>②、序列化与反序列化</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">import java.io.*;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Person implements Serializable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int age;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Address address;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Person(String name, int age, Address address) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.name = name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.age = age;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.address = address;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Person deepClone() throws IOException, ClassNotFoundException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ByteArrayOutputStream bos = new ByteArrayOutputStream();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ObjectOutputStream oos = new ObjectOutputStream(bos);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        oos.writeObject(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ObjectInputStream ois = new ObjectInputStream(bis);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return (Person) ois.readObject();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Address implements Serializable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String city;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Address(String city) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.city = city;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Main {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws IOException, ClassNotFoundException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Address address = new Address(&quot;河南省洛阳市&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Person person1 = new Person(&quot;沉默王二&quot;, 18, address);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Person person2 = person1.deepClone();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(person1.address == person2.address); // false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="java-创建对象有哪几种方式">Java 创建对象有哪几种方式？<a href="#java-创建对象有哪几种方式" class="hash-link" aria-label="Direct link to Java 创建对象有哪几种方式？" title="Direct link to Java 创建对象有哪几种方式？">​</a></h3>
<p>Java 有四种创建对象的方式：<br>
<!-- -->①、new 关键字创建，这是最常见和直接的方式，通过调用类的构造方法来创建对象。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Person person = new Person();  </span><br></span></code></pre></div></div>
<p>②、反射机制创建，反射机制允许在运行时创建对象，并且可以访问类的私有成员，在框架和工具类中比较常见。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Class clazz = Class.forName(&quot;Person&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Person person = (Person) clazz.newInstance();</span><br></span></code></pre></div></div>
<p>③、clone 拷贝创建，通过 clone 方法创建对象，需要实现 Cloneable 接口并重写 clone 方法。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Person person = new Person();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Person person2 = (Person) person.clone();</span><br></span></code></pre></div></div>
<p>④、序列化机制创建，通过序列化将对象转换为字节流，再通过反序列化从字节流中恢复对象。需要实现 Serializable 接口。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Person person = new Person();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;person.txt&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">oos.writeObject(person);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;person.txt&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Person person2 = (Person) ois.readObject();</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="new-子类的时候子类和父类静态代码块构造方法的执行顺序">new 子类的时候，子类和父类静态代码块，构造方法的执行顺序<a href="#new-子类的时候子类和父类静态代码块构造方法的执行顺序" class="hash-link" aria-label="Direct link to new 子类的时候，子类和父类静态代码块，构造方法的执行顺序" title="Direct link to new 子类的时候，子类和父类静态代码块，构造方法的执行顺序">​</a></h3>
<p>在 Java 中，当创建一个子类对象时，子类和父类的静态代码块、构造方法的执行顺序遵循一定的规则。这些规则主要包括以下几个步骤：
首先执行父类的静态代码块（仅在类第一次加载时执行）。<br>
<!-- -->接着执行子类的静态代码块（仅在类第一次加载时执行）。<br>
<!-- -->再执行父类的构造方法。<br>
<!-- -->最后执行子类的构造方法。<br>
<!-- -->静态代码块：在类加载时执行，仅执行一次，按父类-子类的顺序执行。<br>
<!-- -->构造方法：在每次创建对象时执行，按父类-子类的顺序执行，先初始化块后构造方法。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="string">String<a href="#string" class="hash-link" aria-label="Direct link to String" title="Direct link to String">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="string-是-java-基本数据类型吗可以被继承吗">String 是 Java 基本数据类型吗？可以被继承吗？<a href="#string-是-java-基本数据类型吗可以被继承吗" class="hash-link" aria-label="Direct link to String 是 Java 基本数据类型吗？可以被继承吗？" title="Direct link to String 是 Java 基本数据类型吗？可以被继承吗？">​</a></h3>
<p>不是，String 是一个类，属于引用数据类型。Java 的基本数据类型包括八种：四种整型（byte、short、int、long）、两种浮点型（float、double）、一种字符型（char）和一种布尔型（boolean）。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="string-类可以继承吗">String 类可以继承吗？<a href="#string-类可以继承吗" class="hash-link" aria-label="Direct link to String 类可以继承吗？" title="Direct link to String 类可以继承吗？">​</a></h4>
<p>不行。String 类使用 final 修饰，是所谓的不可变类，无法被继承。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="string-有哪些常用方法">String 有哪些常用方法？<a href="#string-有哪些常用方法" class="hash-link" aria-label="Direct link to String 有哪些常用方法？" title="Direct link to String 有哪些常用方法？">​</a></h3>
<p>我自己常用的有：
length() - 返回字符串的长度。
charAt(int index) - 返回指定位置的字符。
substring(int beginIndex, int endIndex) - 返回字符串的一个子串，从 beginIndex 到 endIndex-1。
contains(CharSequence s) - 检查字符串是否包含指定的字符序列。
equals(Object anotherObject) - 比较两个字符串的内容是否相等。
indexOf(int ch) 和 indexOf(String str) - 返回指定字符或字符串首次出现的位置。
replace(char oldChar, char newChar) 和 replace(CharSequence target, CharSequence replacement) - 替换字符串中的字符或字符序列。
trim() - 去除字符串两端的空白字符。
split(String regex) - 根据给定正则表达式的匹配拆分此字符串。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="string-和-stringbuilderstringbuffer-的区别">🌟String 和 StringBuilder、StringBuffer 的区别？<a href="#string-和-stringbuilderstringbuffer-的区别" class="hash-link" aria-label="Direct link to 🌟String 和 StringBuilder、StringBuffer 的区别？" title="Direct link to 🌟String 和 StringBuilder、StringBuffer 的区别？">​</a></h3>
<p>String、StringBuilder和StringBuffer在 Java 中都是用于处理字符串的，它们之间的区别是，
String 是不可变的，平常开发用得最多，
当遇到大量字符串连接时，就用 StringBuilder，它不会生成很多新的对象，
StringBuffer 和 StringBuilder 类似，但每个方法上都加了 synchronized 关键字，所以是线程安全的。</p>
<p>请说说 String 的特点
String类的对象是不可变的。也就是说，一旦一个String对象被创建，它所包含的字符串内容是不可改变的。
每次对String对象进行修改操作（如拼接、替换等）实际上都会生成一个新的String对象，而不是修改原有对象。这可能会导致内存和性能开销，尤其是在大量字符串操作的情况下。
string 多次拼接其实会被优化成StringBuilder进行拼接</p>
<p>请说说 StringBuilder 的特点
StringBuilder提供了一系列的方法来进行字符串的增删改查操作，这些操作都是直接在原有字符串对象的底层数组上进行的，而不是生成新的 String 对象。
StringBuilder不是线程安全的。这意味着在没有外部同步的情况下，它不适用于多线程环境。
相比于String，在进行频繁的字符串修改操作时，StringBuilder能提供更好的性能。 Java 中的字符串连+操作其实就是通过StringBuilder实现的。</p>
<p>请说说 StringBuffer 的特点
StringBuffer和StringBuilder类似，但StringBuffer是线程安全的，方法前面都加了synchronized关键字。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="请总结一下使用场景">请总结一下使用场景<a href="#请总结一下使用场景" class="hash-link" aria-label="Direct link to 请总结一下使用场景" title="Direct link to 请总结一下使用场景">​</a></h4>
<p>String：适用于字符串内容不会改变的场景，比如说作为 HashMap 的 key。
StringBuilder：适用于单线程环境下需要频繁修改字符串内容的场景，比如在循环中拼接或修改字符串，是 String 的完美替代品。
StringBuffer：现在已经不怎么用了，因为一般不会在多线程场景下去频繁的修改字符串内容。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="string-str1--new-stringabc-和-string-str2--abc-的区别">String str1 = new String(&quot;abc&quot;) 和 String str2 = &quot;abc&quot; 的区别？<a href="#string-str1--new-stringabc-和-string-str2--abc-的区别" class="hash-link" aria-label="Direct link to String str1 = new String(&quot;abc&quot;) 和 String str2 = &quot;abc&quot; 的区别？" title="Direct link to String str1 = new String(&quot;abc&quot;) 和 String str2 = &quot;abc&quot; 的区别？">​</a></h3>
<p>直接使用双引号为字符串变量赋值时，Java 首先会检查字符串常量池中是否已经存在相同内容的字符串。</p>
<p>如果存在，Java 就会让新的变量引用池中的那个字符串；如果不存在，它会创建一个新的字符串，放入池中，并让变量引用它。</p>
<p>使用 new String(&quot;abc&quot;) 的方式创建字符串时，实际分为两步：</p>
<p>第一步，先检查字符串字面量 &quot;abc&quot; 是否在字符串常量池中，如果没有则创建一个；如果已经存在，则引用它。
第二步，在堆中再创建一个新的字符串对象，并将其初始化为字符串常量池中 &quot;abc&quot; 的一个副本。
<img decoding="async" loading="lazy" alt="String存储方式.png" src="/doc/assets/images/String存储方式-ee2b5082712453c88cc55ccc4519d706.png" width="913" height="483" class="img_ev3q"></p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">String s1 = &quot;沉默王二&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String s2 = &quot;沉默王二&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String s3 = new String(&quot;沉默王二&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(s1 == s2); // 输出 true，因为 s1 和 s2 引用的是字符串常量池中同一个对象。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(s1 == s3); // 输出 false，因为 s3 是通过 new 关键字显式创建的，指向堆上不同的对象。</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="string-s--new-stringabc创建了几个对象">String s = new String(&quot;abc&quot;)创建了几个对象？<a href="#string-s--new-stringabc创建了几个对象" class="hash-link" aria-label="Direct link to String s = new String(&quot;abc&quot;)创建了几个对象？" title="Direct link to String s = new String(&quot;abc&quot;)创建了几个对象？">​</a></h3>
<p>字符串常量池中如果之前已经有一个，则不再创建新的，直接引用；如果没有，则创建一个。
堆中肯定有一个，因为只要使用了 new 关键字，肯定会在堆中创建一个。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="string-是不可变类吗字符串拼接是如何实现的">String 是不可变类吗？字符串拼接是如何实现的？<a href="#string-是不可变类吗字符串拼接是如何实现的" class="hash-link" aria-label="Direct link to String 是不可变类吗？字符串拼接是如何实现的？" title="Direct link to String 是不可变类吗？字符串拼接是如何实现的？">​</a></h3>
<p>String 是不可变的，这意味着一旦一个 String 对象被创建，其存储的文本内容就不能被改变。这是因为：</p>
<p>①、不可变性使得 String 对象在使用中更加安全。因为字符串经常用作参数传递给其他 Java 方法，例如网络连接、打开文件等。
如果 String 是可变的，这些方法调用的参数值就可能在不知不觉中被改变，从而导致网络连接被篡改、文件被莫名其妙地修改等问题。
②、不可变的对象因为状态不会改变，所以更容易进行缓存和重用。字符串常量池的出现正是基于这个原因。
当代码中出现相同的字符串字面量时，JVM 会确保所有的引用都指向常量池中的同一个对象，从而节约内存。
③、因为 String 的内容不会改变，所以它的哈希值也就固定不变。这使得 String 对象特别适合作为 HashMap 或 HashSet 等集合的键，因为计算哈希值只需要进行一次，提高了哈希表操作的效率。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="字符串拼接是如何实现的">字符串拼接是如何实现的？<a href="#字符串拼接是如何实现的" class="hash-link" aria-label="Direct link to 字符串拼接是如何实现的？" title="Direct link to 字符串拼接是如何实现的？">​</a></h3>
<p>因为 String 是不可变的，因此通过“+”操作符进行的字符串拼接，会生成新的字符串对象。</p>
<p>例如：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">String a = &quot;hello &quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String b = &quot;world!&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String ab = a + b;</span><br></span></code></pre></div></div>
<p>a 和 b 是通过双引号定义的，所以会在字符串常量池中，而 ab 是通过“+”操作符拼接的，所以会在堆中生成一个新的对象。
![String 引用结构](image/java-review/String 引用结构.png)
a 和 b 是通过双引号定义的，所以会在字符串常量池中，而 ab 是通过“+”操作符拼接的，所以会在堆中生成一个新的对象。
<img decoding="async" loading="lazy" alt="img_5.png" src="/doc/assets/images/img_5-27c7f6347d624f6c5919a9df486e10f4.png" width="608" height="406" class="img_ev3q"></p>
<p>Java 8 时，JDK 对“+”号的字符串拼接进行了优化，Java 会在编译期基于 StringBuilder 的 append 方法进行拼接。
下面是通过 javap -verbose 命令反编译后的字节码，能清楚的看到 StringBuilder 的创建和 append 方法的调用。
因此，如果笼统地讲，通过加号拼接字符串时会创建多个 String 对象是不准确的。因为加号拼接在编译期还会创建一个 StringBuilder 对象，最终调用 toString() 方法的时候再返回一个新的 String 对象。
那除了使用 + 号来拼接字符串，还有 StringBuilder.append()、String.join() 等方式。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何保证-string-不可变">如何保证 String 不可变？<a href="#如何保证-string-不可变" class="hash-link" aria-label="Direct link to 如何保证 String 不可变？" title="Direct link to 如何保证 String 不可变？">​</a></h3>
<p>第一，String 类内部使用一个私有的字符数组来存储字符串数据。这个字符数组在创建字符串时被初始化，之后不允许被改变。
private final char value[];</p>
<p>第二，String 类没有提供任何可以修改其内容的公共方法，像 concat 这些看似修改字符串的操作，实际上都是返回一个新创建的字符串对象，而原始字符串对象保持不变。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public String concat(String str) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (str.isEmpty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return this;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int len = value.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int otherLen = str.length();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char buf[] = Arrays.copyOf(value, len + otherLen);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    str.getChars(buf, len);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new String(buf, true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>第三，String 类本身被声明为 final，这意味着它不能被继承。这防止了子类可能通过添加修改方法来改变字符串内容的可能性。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public final class String;</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="intern-方法有什么作用">intern 方法有什么作用？<a href="#intern-方法有什么作用" class="hash-link" aria-label="Direct link to intern 方法有什么作用？" title="Direct link to intern 方法有什么作用？">​</a></h3>
<p>如果当前字符串内容存在于字符串常量池（即 equals()方法为 true，也就是内容一样），直接返回字符串常量池中的字符串<br>
<!-- -->否则，将此 String 对象添加到池中，并返回 String 对象的引用</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="integer-a-127integer-b--127integer-c-128integer-d--128相等吗">Integer a= 127，Integer b = 127；Integer c= 128，Integer d = 128；相等吗?<a href="#integer-a-127integer-b--127integer-c-128integer-d--128相等吗" class="hash-link" aria-label="Direct link to Integer a= 127，Integer b = 127；Integer c= 128，Integer d = 128；相等吗?" title="Direct link to Integer a= 127，Integer b = 127；Integer c= 128，Integer d = 128；相等吗?">​</a></h3>
<p>a 和 b 相等，c 和 d 不相等。
这个问题涉及到 Java 的自动装箱机制以及Integer类的缓存机制。 对于第一对：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Integer a = 127;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Integer b = 127;</span><br></span></code></pre></div></div>
<p>a和b是相等的。这是因为 Java 在自动装箱过程中，会使用Integer.valueOf()方法来创建Integer对象。
Integer.valueOf()方法会针对数值在-128 到 127 之间的Integer对象使用缓存。因此，a和b实际上引用了常量池中相同的Integer对象。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Integer c = 128;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Integer d = 128;</span><br></span></code></pre></div></div>
<p>c和d不相等。这是因为 128 超出了Integer缓存的范围(-128 到 127)。
因此，自动装箱过程会为c和d创建两个不同的Integer对象，它们有不同的引用地址。<br>
<!-- -->可以通过==运算符来检查它们是否相等：<br>
<!-- -->要比较Integer对象的数值是否相等，应该使用equals方法，而不是==运算符：<br>
<!-- -->使用equals方法时，c和d的比较结果为true，因为equals比较的是对象的数值，而不是引用地址。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是-integer-缓存">什么是 Integer 缓存？<a href="#什么是-integer-缓存" class="hash-link" aria-label="Direct link to 什么是 Integer 缓存？" title="Direct link to 什么是 Integer 缓存？">​</a></h3>
<p>就拿 Integer 的缓存吃来说吧。根据实践发现，大部分的数据操作都集中在值比较小的范围，因此 Integer 搞了个缓存池，默认范围是 -128 到 127。<br>
<!-- -->当我们使用自动装箱来创建这个范围内的 Integer 对象时，Java 会直接从缓存中返回一个已存在的对象，而不是每次都创建一个新的对象。这意味着，对于这个值范围内的所有 Integer 对象，它们实际上是引用相同的对象实例。<br>
<!-- -->Integer 缓存的主要目的是优化性能和内存使用。对于小整数的频繁操作，使用缓存可以显著减少对象创建的数量。<br>
<!-- -->可以在运行的时候添加 -Djava.lang.Integer.IntegerCache.high=1000 来调整缓存池的最大值<br>
<!-- -->引用是 Integer 类型，= 右侧是 int 基本类型时，会进行自动装箱，调用的其实是 Integer.valueOf()方法，它会调用 IntegerCache。<br>
<!-- -->IntegerCache 是一个静态内部类，在静态代码块中会初始化好缓存的值。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="new-integer10--new-integer10-相等吗">new Integer(10) == new Integer(10) 相等吗<a href="#new-integer10--new-integer10-相等吗" class="hash-link" aria-label="Direct link to new Integer(10) == new Integer(10) 相等吗" title="Direct link to new Integer(10) == new Integer(10) 相等吗">​</a></h3>
<p>在 Java 中，使用new Integer(10) == new Integer(10)进行比较时，结果是 false。<br>
<!-- -->这是因为 new 关键字会在堆（Heap）上为每个 Integer 对象分配新的内存空间，所以这里创建了两个不同的 Integer 对象，它们有不同的内存地址。<br>
<!-- -->当使用==运算符比较这两个对象时，实际上比较的是它们的内存地址，而不是它们的值，因此即使两个对象代表相同的数值（10），结果也是 false。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="string-怎么转成-integer-的原理">String 怎么转成 Integer 的原理？<a href="#string-怎么转成-integer-的原理" class="hash-link" aria-label="Direct link to String 怎么转成 Integer 的原理？" title="Direct link to String 怎么转成 Integer 的原理？">​</a></h3>
<p>waitx
PS:这道题印象中在一些面经中出场过几次。<br>
<!-- -->String 转成 Integer，主要有两个方法：
Integer.parseInt(String s)
Integer.valueOf(String s)
不管哪一种，最终还是会调用 Integer 类内中的parseInt(String s, int radix)方法。
抛去一些边界之类的看看核心代码：</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="object">Object<a href="#object" class="hash-link" aria-label="Direct link to Object" title="Direct link to Object">​</a></h2>
<p>Object 主要提供了 11 个方法，大致可以分为六类：
<img decoding="async" loading="lazy" alt="Object方法" src="/doc/assets/images/Object方法-375feb66eedc44b0e333800a509cf678.png" width="1006" height="800" class="img_ev3q"></p>
<ol>
<li>
<p>对象比较：
①、public native int hashCode() ：native 方法，用于返回对象的哈希码。
按照约定，相等的对象必须具有相等的哈希码。如果重写了 equals 方法，就应该重写 hashCode 方法。可以使用 Objects.hash() 方法来生成哈希码。<br>
<!-- -->②、public boolean equals(Object obj)：用于比较 2 个对象的内存地址是否相等。
如果比较的是两个对象的值是否相等，就要重写该方法，比如 String 类、Integer 类等都重写了该方法。举个例子，假如有一个 Person 类，我们认为只要年龄和名字相同，就是同一个人，那么就可以这样重写 equals 方法：</p>
</li>
<li>
<p>对象拷贝：<br>
<!-- -->protected native Object clone() throws CloneNotSupportedException：naitive 方法，返回此对象的一个副本。默认实现只做浅拷贝，且类必须实现 Cloneable 接口。
Object 本身没有实现 Cloneable 接口，所以在不重写 clone 方法的情况下直接直接调用该方法会发生 CloneNotSupportedException 异常。</p>
</li>
<li>
<p>对象转字符串：
public String toString()：返回对象的字符串表示。默认实现返回类名@哈希码的十六进制表示，但通常会被重写以返回更有意义的信息。
也可以交给 Lombok，使用 @Data 注解，它会自动生成 toString 方法。</p>
</li>
<li>
<p>多线程调度：
每个对象都可以调用 Object 的 wait/notify 方法来实现等待/通知机制。我们来写一个例子：</p>
</li>
</ol>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class WaitNotifyDemo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object lock = new Object();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new Thread(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            synchronized (lock) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;线程1：我要等待&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    lock.wait();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;线程1：我被唤醒了&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }).start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new Thread(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            synchronized (lock) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;线程2：我要唤醒&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                lock.notify();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;线程2：我已经唤醒了&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }).start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>解释一下：
线程 1 先执行，它调用了 lock.wait() 方法，然后进入了等待状态。<br>
<!-- -->线程 2 后执行，它调用了 lock.notify() 方法，然后线程 1 被唤醒了。<br>
<!-- -->①、public final void wait() throws InterruptedException：调用该方法会导致当前线程等待，直到另一个线程调用此对象的notify()方法或notifyAll()方法。<br>
<!-- -->②、public final native void notify()：唤醒在此对象监视器上等待的单个线程。如果有多个线程等待，选择一个线程被唤醒。<br>
<!-- -->③、public final native void notifyAll()：唤醒在此对象监视器上等待的所有线程。<br>
<!-- -->④、public final native void wait(long timeout) throws InterruptedException：等待 timeout 毫秒，如果在 timeout 毫秒内没有被唤醒，会自动唤醒。<br>
<!-- -->⑥、public final void wait(long timeout, int nanos) throws InterruptedException：更加精确了，等待 timeout 毫秒和 nanos 纳秒，如果在 timeout 毫秒和 nanos 纳秒内没有被唤醒，会自动唤醒。</p>
<p><a href="https://javabetter.cn/basic-extra-meal/fanshe.html" target="_blank" rel="noopener noreferrer">反射</a></p>
<ol start="5">
<li>垃圾回收：
protected void finalize() throws Throwable：当垃圾回收器决定回收对象占用的内存时调用此方法。用于清理资源，但 Java 不推荐使用，因为它不可预测且容易导致问题，Java 9 开始已被弃用。</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="异常处理">异常处理<a href="#异常处理" class="hash-link" aria-label="Direct link to 异常处理" title="Direct link to 异常处理">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="java-中异常处理体系">🌟Java 中异常处理体系?<a href="#java-中异常处理体系" class="hash-link" aria-label="Direct link to 🌟Java 中异常处理体系?" title="Direct link to 🌟Java 中异常处理体系?">​</a></h3>
<p>Java 中的异常处理机制用于处理程序运行过程中可能发生的各种异常情况，通常通过 try-catch-finally 语句和 throw 关键字来实现。<br>
<img decoding="async" loading="lazy" alt="异常继承图" src="/doc/assets/images/异常继承图-af6a6b7e7a2e4ae125fa4b9d7cbc1b87.png" width="1290" height="707" class="img_ev3q">
Throwable 是 Java 语言中所有错误和异常的基类。它有两个主要的子类：Error 和 Exception，这两个类分别代表了 Java 异常处理体系中的两个分支。<br>
<!-- -->Error 类代表那些严重的错误，这类错误通常是程序无法处理的。比如，OutOfMemoryError 表示内存不足，StackOverflowError 表示栈溢出。这些错误通常与 JVM 的运行状态有关，一旦发生，应用程序通常无法恢复。
Exception 类代表程序可以处理的异常。它分为两大类：编译时异常（Checked Exception）和运行时异常（Runtime Exception）。</p>
<p>①、编译时异常（Checked Exception）：这类异常在编译时必须被显式处理（捕获或声明抛出）。
如果方法可能抛出某种编译时异常，但没有捕获它（try-catch）或没有在方法声明中用 throws 子句声明它，那么编译将不会通过。例如：IOException、SQLException 等。</p>
<p>②、运行时异常（Runtime Exception）：这类异常在运行时抛出，它们都是 RuntimeException 的子类。对于运行时异常，Java 编译器不要求必须处理它们（即不需要捕获也不需要声明抛出）。
运行时异常通常是由程序逻辑错误导致的，如 NullPointerException、IndexOutOfBoundsException 等。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="异常的处理方式">异常的处理方式？<a href="#异常的处理方式" class="hash-link" aria-label="Direct link to 异常的处理方式？" title="Direct link to 异常的处理方式？">​</a></h3>
<p><img decoding="async" loading="lazy" alt="异常继承关系" src="/doc/assets/images/异常继承关系-b47523a92577906413103698b939c9d2.png" width="819" height="329" class="img_ev3q">
①、遇到异常时可以不处理，直接通过throw 和 throws 抛出异常，交给上层调用者处理。<br>
<!-- -->throws 关键字用于声明可能会抛出的异常，而 throw 关键字用于抛出异常。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public void test() throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">throw new Exception(&quot;抛出异常&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>②、使用 try-catch 捕获异常，处理异常。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//包含可能会出现异常的代码以及声明异常的方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}catch(Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//捕获异常并进行处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//可选，必执行的代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="catch和finally的异常可以同时抛出吗">catch和finally的异常可以同时抛出吗？<a href="#catch和finally的异常可以同时抛出吗" class="hash-link" aria-label="Direct link to catch和finally的异常可以同时抛出吗？" title="Direct link to catch和finally的异常可以同时抛出吗？">​</a></h3>
<p>如果 catch 块抛出一个异常，而 finally 块中也抛出异常，那么最终抛出的将是 finally 块中的异常。catch 块中的异常会被丢弃，而 finally 块中的异常会覆盖并向上传递。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class Example {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new Exception(&quot;Exception in try&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new RuntimeException(&quot;Exception in catch&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new IllegalArgumentException(&quot;Exception in finally&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>try 块首先抛出一个 Exception。 控制流进入 catch 块，catch 块中又抛出了一个 RuntimeException。<br>
<!-- -->但是在 finally 块中，抛出了一个 IllegalArgumentException，最终程序抛出的异常是 finally 块中的 IllegalArgumentException。<br>
<!-- -->虽然 catch 和 finally 中的异常不能同时抛出，但可以手动捕获 finally 块中的异常，并将 catch 块中的异常保留下来，避免被覆盖。常见的做法是使用一个变量临时存储 catch 中的异常，然后在 finally 中处理该异常：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class Example {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Exception catchException = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new Exception(&quot;Exception in try&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            catchException = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new RuntimeException(&quot;Exception in catch&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw new IllegalArgumentException(&quot;Exception in finally&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (IllegalArgumentException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (catchException != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    System.out.println(&quot;Catch exception: &quot; + catchException.getMessage());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;Finally exception: &quot; + e.getMessage());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="io">I/O<a href="#io" class="hash-link" aria-label="Direct link to I/O" title="Direct link to I/O">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="java-中-io-流分为几种">Java 中 IO 流分为几种?<a href="#java-中-io-流分为几种" class="hash-link" aria-label="Direct link to Java 中 IO 流分为几种?" title="Direct link to Java 中 IO 流分为几种?">​</a></h3>
<p>reviewx
Java IO 流的划分可以根据多个维度进行，包括数据流的方向（输入或输出）、处理的数据单位（字节或字符）、流的功能以及流是否支持随机访问等。</p>
<ol>
<li>
<p>按照数据流方向如何划分？<br>
<!-- -->输入流（Input Stream）：从源（如文件、网络等）读取数据到程序。<br>
<!-- -->输出流（Output Stream）：将数据从程序写出到目的地（如文件、网络、控制台等）。</p>
</li>
<li>
<p>按处理数据单位如何划分？<br>
<!-- -->字节流（Byte Streams）：以字节为单位读写数据，主要用于处理二进制数据，如音频、图像文件等。<br>
<!-- -->字符流（Character Streams）：以字符为单位读写数据，主要用于处理文本数据。</p>
</li>
<li>
<p>按功能如何划分？<br>
<!-- -->节点流（Node Streams）：直接与数据源或目的地相连，如 FileInputStream、FileOutputStream。<br>
<!-- -->处理流（Processing Streams）：对一个已存在的流进行包装，如缓冲流 BufferedInputStream、BufferedOutputStream。<br>
<!-- -->管道流（Piped Streams）：用于线程之间的数据传输，如 PipedInputStream、PipedOutputStream。</p>
</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="io-流用到了什么设计模式">IO 流用到了什么设计模式？<a href="#io-流用到了什么设计模式" class="hash-link" aria-label="Direct link to IO 流用到了什么设计模式？" title="Direct link to IO 流用到了什么设计模式？">​</a></h3>
<p>其实，Java 的 IO 流体系还用到了一个设计模式——装饰器模式。</p>
<p><img decoding="async" loading="lazy" alt="IO流设计模式" src="/doc/assets/images/IO流设计模式-016ffbf6cd513a3139fb0120a01da1fb.png" width="1015" height="455" class="img_ev3q">
Java 缓冲区溢出，如何预防
Java 缓冲区溢出主要是由于向缓冲区写入的数据超过其能够存储的数据量。可以采用这些措施来避免：<br>
<!-- -->①、合理设置缓冲区大小：在创建缓冲区时，应根据实际需求合理设置缓冲区的大小，避免创建过大或过小的缓冲区。<br>
<!-- -->②、控制写入数据量：在向缓冲区写入数据时，应该控制写入的数据量，确保不会超过缓冲区的容量。Java 的 ByteBuffer 类提供了remaining()方法，可以获取缓冲区中剩余的可写入数据量。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">import java.nio.ByteBuffer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ByteBufferExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 模拟接收到的数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        byte[] receivedData = {1, 2, 3, 4, 5};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int bufferSize = 1024;  // 设置一个合理的缓冲区大小</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建ByteBuffer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ByteBuffer buffer = ByteBuffer.allocate(bufferSize);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 写入数据之前检查容量是否足够</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (buffer.remaining() &gt;= receivedData.length) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            buffer.put(receivedData);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;Not enough space in buffer to write data.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 准备读取数据：将limit设置为当前位置，position设回0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        buffer.flip();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 读取数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (buffer.hasRemaining()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            byte data = buffer.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;Read data: &quot; + data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 清空缓冲区以便再次使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        buffer.clear();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="既然有了字节流为什么还要有字符流">既然有了字节流,为什么还要有字符流?<a href="#既然有了字节流为什么还要有字符流" class="hash-link" aria-label="Direct link to 既然有了字节流,为什么还要有字符流?" title="Direct link to 既然有了字节流,为什么还要有字符流?">​</a></h3>
<p>其实字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还比较耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。
所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="文本存储是字节流还是字符流视频文件呢">文本存储是字节流还是字符流，视频文件呢？<a href="#文本存储是字节流还是字符流视频文件呢" class="hash-link" aria-label="Direct link to 文本存储是字节流还是字符流，视频文件呢？" title="Direct link to 文本存储是字节流还是字符流，视频文件呢？">​</a></h3>
<p>在计算机中，文本和视频都是按照字节存储的，只是如果是文本文件的话，我们可以通过字符流的形式去读取，这样更方面的我们进行直接处理。
比如说我们需要在一个大文本文件中查找某个字符串，可以直接通过字符流来读取判断。
处理视频文件时，通常使用字节流（如 Java 中的FileInputStream、FileOutputStream）来读取或写入数据，并且会尽量使用缓冲流（如BufferedInputStream、BufferedOutputStream）来提高读写效率。<br>
<!-- -->在技术派实战项目项目中，对于文本，比如说文章和教程内容，是直接存储在数据库中的，而对于视频和图片等大文件，是存储在 OSS 中的。
因此，无论是文本文件还是视频文件，它们在物理存储层面都是以字节流的形式存在。区别在于，我们如何通过 Java 代码来解释和处理这些字节流：作为编码后的字符还是作为二进制数据。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="bionioaio-之间的区别">🌟BIO、NIO、AIO 之间的区别？<a href="#bionioaio-之间的区别" class="hash-link" aria-label="Direct link to 🌟BIO、NIO、AIO 之间的区别？" title="Direct link to 🌟BIO、NIO、AIO 之间的区别？">​</a></h3>
<p>Java 常见的 IO 模型有三种：BIO、NIO 和 AIO。</p>
<p><img decoding="async" loading="lazy" alt="IO类型" src="/doc/assets/images/IO类型-dc3ba098f833b87016a194e4c4a1cf09.png" width="1360" height="1010" class="img_ev3q">
BIO：采用阻塞式 I/O 模型，线程在执行 I/O 操作时被阻塞，无法处理其他任务，适用于连接数较少的场景。<br>
<!-- -->NIO：采用非阻塞 I/O 模型，线程在等待 I/O 时可执行其他任务，通过 Selector 监控多个 Channel 上的事件，适用于连接数多但连接时间短的场景。
AIO：使用异步 I/O 模型，线程发起 I/O 请求后立即返回，当 I/O 操作完成时通过回调函数通知线程，适用于连接数多且连接时间长的场景。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="简单说一下-bio">简单说一下 BIO？<a href="#简单说一下-bio" class="hash-link" aria-label="Direct link to 简单说一下 BIO？" title="Direct link to 简单说一下 BIO？">​</a></h3>
<p>BIO，也就是传统的 IO，基于字节流或字符流（如 FileInputStream、BufferedReader 等）进行文件读写，基于 Socket 和 ServerSocket 进行网络通信。
对于每个连接，都需要创建一个独立的线程来处理读写操作。
<img decoding="async" loading="lazy" alt="BIO模式" src="/doc/assets/images/BIO模式-77b6a9524bc2309e22cab4ffbe2e5394.png" width="705" height="347" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="简单说下-nio">简单说下 NIO？<a href="#简单说下-nio" class="hash-link" aria-label="Direct link to 简单说下 NIO？" title="Direct link to 简单说下 NIO？">​</a></h3>
<p>NIO，JDK 1.4 时引入，放在 java.nio 包下，提供了 Channel、Buffer、Selector 等新的抽象，基于 RandomAccessFile、FileChannel、ByteBuffer 进行文件读写，基于 SocketChannel 和 ServerSocketChannel 进行网络通信。
实际上，“旧”的 I/O 包已经使用 NIO 重新实现过，所以在进行文件读写时，NIO 并无法体现出比 BIO 更可靠的性能。
NIO 的魅力主要体现在网络编程中，服务器可以用一个线程处理多个客户端连接，通过 Selector 监听多个 Channel 来实现多路复用，极大地提高了网络编程的性能。</p>
<p>图片补充waitx
缓冲区 Buffer 也能极大提升一次 IO 操作的效率。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="简单说下-aio">简单说下 AIO？<a href="#简单说下-aio" class="hash-link" aria-label="Direct link to 简单说下 AIO？" title="Direct link to 简单说下 AIO？">​</a></h3>
<p>AIO 是 Java 7 引入的，放在 java.nio.channels 包下，提供了 AsynchronousFileChannel、AsynchronousSocketChannel 等异步 Channel。<br>
<!-- -->它引入了异步通道的概念，使得 I/O 操作可以异步进行。这意味着线程发起一个读写操作后不必等待其完成，可以立即进行其他任务，并且当读写操作真正完成时，线程会被异步地通知。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="序列化">序列化<a href="#序列化" class="hash-link" aria-label="Direct link to 序列化" title="Direct link to 序列化">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是序列化什么是反序列化">什么是序列化？什么是反序列化？<a href="#什么是序列化什么是反序列化" class="hash-link" aria-label="Direct link to 什么是序列化？什么是反序列化？" title="Direct link to 什么是序列化？什么是反序列化？">​</a></h3>
<p>序列化（Serialization）是指将对象转换为字节流的过程，以便能够将该对象保存到文件、数据库，或者进行网络传输。
反序列化（Deserialization）就是将字节流转换回对象的过程，以便构建原始对象。
<img decoding="async" loading="lazy" alt="序列化和反序列化" src="data:image/png;base64,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" width="800" height="228" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="serializable-接口有什么用">Serializable 接口有什么用？<a href="#serializable-接口有什么用" class="hash-link" aria-label="Direct link to Serializable 接口有什么用？" title="Direct link to Serializable 接口有什么用？">​</a></h3>
<p>waitx</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="java-序列化不包含静态变量吗">Java 序列化不包含静态变量吗？<a href="#java-序列化不包含静态变量吗" class="hash-link" aria-label="Direct link to Java 序列化不包含静态变量吗？" title="Direct link to Java 序列化不包含静态变量吗？">​</a></h4>
<p>是的，序列化机制只会保存对象的状态，而静态变量属于类的状态，不属于对象的状态。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="如果有些变量不想序列化怎么办">如果有些变量不想序列化，怎么办？<a href="#如果有些变量不想序列化怎么办" class="hash-link" aria-label="Direct link to 如果有些变量不想序列化，怎么办？" title="Direct link to 如果有些变量不想序列化，怎么办？">​</a></h4>
<p>可以使用transient关键字修饰不想序列化的变量。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="能解释一下序列化的过程和作用吗">能解释一下序列化的过程和作用吗？<a href="#能解释一下序列化的过程和作用吗" class="hash-link" aria-label="Direct link to 能解释一下序列化的过程和作用吗？" title="Direct link to 能解释一下序列化的过程和作用吗？">​</a></h3>
<p>序列化过程通常涉及到以下几个步骤：<br>
<!-- -->第一步，实现 Serializable 接口。<br>
<!-- -->第二步，使用 ObjectOutputStream 来将对象写入到输出流中。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;person.ser&quot;));</span><br></span></code></pre></div></div>
<p>第三步，调用 ObjectOutputStream 的 writeObject 方法，将对象序列化并写入到输出流中。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Person person = new Person(&quot;沉默王二&quot;, 18);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">out.writeObject(person);</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说有几种序列化方式">说说有几种序列化方式？<a href="#说说有几种序列化方式" class="hash-link" aria-label="Direct link to 说说有几种序列化方式？" title="Direct link to 说说有几种序列化方式？">​</a></h3>
<p>Java 序列化方式有很多，常见的有三种：<br>
<!-- -->Java 对象序列化 ：Java 原生序列化方法即通过 Java 原生流(InputStream 和 OutputStream 之间的转化)的方式进行转化，一般是对象输出流 ObjectOutputStream和对象输入流ObjectInputStream。<br>
<!-- -->Json 序列化：这个可能是我们最常用的序列化方式，Json 序列化的选择很多，一般会使用 jackson 包，通过 ObjectMapper 类来进行一些操作，比如将对象转化为 byte 数组或者将 json 串转化为对象。<br>
<!-- -->ProtoBuff 序列化：ProtocolBuffer 是一种轻便高效的结构化数据存储格式，ProtoBuff 序列化对象可以很大程度上将其压缩，可以大大减少数据传输大小，提高系统性能。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="网络编程">网络编程<a href="#网络编程" class="hash-link" aria-label="Direct link to 网络编程" title="Direct link to 网络编程">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="了解过socket网络套接字吗补充">了解过Socket网络套接字吗？（补充）<a href="#了解过socket网络套接字吗补充" class="hash-link" aria-label="Direct link to 了解过Socket网络套接字吗？（补充）" title="Direct link to 了解过Socket网络套接字吗？（补充）">​</a></h3>
<p>waitx</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="rpc框架了解吗">RPC框架了解吗？<a href="#rpc框架了解吗" class="hash-link" aria-label="Direct link to RPC框架了解吗？" title="Direct link to RPC框架了解吗？">​</a></h3>
<p>RPC是一种协议，允许程序调用位于远程服务器上的方法，就像调用本地方法一样。RPC 通常基于 Socket 通信实现。<br>
<!-- -->RPC，Remote Procedure Call，远程过程调用<br>
<!-- -->RPC 框架支持高效的序列化（如 Protocol Buffers）和通信协议（如 HTTP/2），屏蔽了底层网络通信的细节，开发者只需关注业务逻辑即可。<br>
<img decoding="async" loading="lazy" alt="注册中心" src="/doc/assets/images/注册中心-fcb3d6c427609d6dcc627550e4333ebc.png" width="1052" height="702" class="img_ev3q">
常见的 RPC 框架包括：
gRPC：基于 HTTP/2 和 Protocol Buffers。<br>
<!-- -->Dubbo：阿里开源的分布式 RPC 框架，适合微服务场景。<br>
<!-- -->Spring Cloud OpenFeign：基于 REST 的轻量级 RPC 框架。<br>
<!-- -->Thrift：Apache 的跨语言 RPC 框架，支持多语言代码生成。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="泛型">泛型<a href="#泛型" class="hash-link" aria-label="Direct link to 泛型" title="Direct link to 泛型">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="java-泛型了解么">Java 泛型了解么？<a href="#java-泛型了解么" class="hash-link" aria-label="Direct link to Java 泛型了解么？" title="Direct link to Java 泛型了解么？">​</a></h3>
<p>泛型主要用于提高代码的类型安全，它允许在定义类、接口和方法时使用类型参数，这样可以在编译时检查类型一致性，避免不必要的类型转换和类型错误。<br>
<!-- -->没有泛型的时候，像 List 这样的集合类存储的是 Object 类型，导致从集合中读取数据时，必须进行强制类型转换，否则会引发 ClassCastException。<br>
<!-- -->泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。<br>
<img decoding="async" loading="lazy" alt="泛型使用场景" src="/doc/assets/images/泛型使用场景-f76709dc820e6b9709da641da7df8973.png" width="795" height="410" class="img_ev3q">
1.泛型类：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//在实例化泛型类时，必须指定T的具体类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Generic&lt;T&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private T key;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Generic(T key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.key = key;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public T getKey(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return key;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456);</span><br></span></code></pre></div></div>
<p>2.泛型接口 ：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public interface Generator&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public T method();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class GeneratorImpl&lt;T&gt; implements Generator&lt;String&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   public String method() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return &quot;hello&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>3.泛型方法 ：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">   public static &lt; E &gt; void printArray( E[] inputArray )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         for ( E element : inputArray ){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.printf( &quot;%s &quot;, element );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         System.out.println();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 创建不同类型数组： Integer, Double 和 Character</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Integer[] intArray = { 1, 2, 3 };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String[] stringArray = { &quot;Hello&quot;, &quot;World&quot; };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">printArray( intArray  );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">printArray( stringArray  );</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="泛型常用的通配符有哪些">泛型常用的通配符有哪些？<a href="#泛型常用的通配符有哪些" class="hash-link" aria-label="Direct link to 泛型常用的通配符有哪些？" title="Direct link to 泛型常用的通配符有哪些？">​</a></h3>
<p>常用的通配符为： T，E，K，V，？</p>
<p>？ 表示不确定的 java 类型
T (type) 表示具体的一个 java 类型
K V (key value) 分别代表 java 键值中的 Key Value
E (element) 代表 Element</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是泛型擦除">什么是泛型擦除？<a href="#什么是泛型擦除" class="hash-link" aria-label="Direct link to 什么是泛型擦除？" title="Direct link to 什么是泛型擦除？">​</a></h3>
<p>所谓的泛型擦除，官方名叫“类型擦除”。
Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的类型信息都会被擦掉。
也就是说，在运行的时候是没有泛型的。
例如这段代码，往一群猫里放条狗：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">LinkedList&lt;Cat&gt; cats = new LinkedList&lt;Cat&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LinkedList list = cats;  // 注意我在这里把范型去掉了，但是list和cats是同一个链表！</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">list.add(new Dog());  // 完全没问题！</span><br></span></code></pre></div></div>
<p>因为 Java 的范型只存在于源码里，编译的时候给你静态地检查一下范型类型是否正确，而到了运行时就不检查了。上面这段代码在 JRE（Java运行环境）看来和下面这段没区别：</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么要类型擦除呢">为什么要类型擦除呢？<a href="#为什么要类型擦除呢" class="hash-link" aria-label="Direct link to 为什么要类型擦除呢？" title="Direct link to 为什么要类型擦除呢？">​</a></h3>
<p>主要是为了向下兼容，因为 JDK5 之前是没有泛型的，为了让 JVM 保持向下兼容，就出了类型擦除这个策略。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="注解">注解<a href="#注解" class="hash-link" aria-label="Direct link to 注解" title="Direct link to 注解">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说一下你对注解的理解">说一下你对注解的理解？<a href="#说一下你对注解的理解" class="hash-link" aria-label="Direct link to 说一下你对注解的理解？" title="Direct link to 说一下你对注解的理解？">​</a></h3>
<p>Java 注解本质上是一个标记，可以理解成生活中的一个人的一些小装扮，比如戴什么什么帽子，戴什么眼镜。<br>
<!-- -->注解可以标记在类上、方法上、属性上等，标记自身也可以设置一些值，比如帽子颜色是绿色。<br>
<!-- -->有了标记之后，我们就可以在编译或者运行阶段去识别这些标记，然后搞一些事情，这就是注解的用处。<br>
<!-- -->例如我们常见的 AOP，使用注解作为切点就是运行期注解的应用；比如 lombok，就是注解在编译期的运行。</p>
<p>注解生命周期有三大类，分别是：</p>
<p>RetentionPolicy.SOURCE：给编译器用的，不会写入 class 文件<br>
<!-- -->RetentionPolicy.CLASS：会写入 class 文件，在类加载阶段丢弃，也就是运行的时候就没这个信息了<br>
<!-- -->RetentionPolicy.RUNTIME：会写入 class 文件，永久保存，可以通过反射获取注解信息<br>
<!-- -->所以我上文写的是解析的时候，没写具体是解析啥，因为不同的生命周期的解析动作是不同的。</p>
<p>就是给编译器用的，编译器编译的时候检查没问题就 over 了，class 文件里面不会有 Override 这个标记。
再比如 Spring 常见的 Autowired ，就是 RUNTIME 的，所以在运行的时候可以通过反射得到注解的信息，还能拿到标记的值 required 。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="反射">反射<a href="#反射" class="hash-link" aria-label="Direct link to 反射" title="Direct link to 反射">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是反射应用原理">🌟什么是反射？应用？原理？<a href="#什么是反射应用原理" class="hash-link" aria-label="Direct link to 🌟什么是反射？应用？原理？" title="Direct link to 🌟什么是反射？应用？原理？">​</a></h3>
<p>反射允许 Java 在运行时检查和操作类的方法和字段。通过反射，可以动态地获取类的字段、方法、构造方法等信息，并在运行时调用方法或访问字段。</p>
<p>比如创建一个对象是通过 new 关键字来实现的：<br>
<!-- -->Person 类的信息在编译时就确定了，那假如在编译期无法确定类的信息，但又想在运行时获取类的信息、创建类的实例、调用类的方法，这时候就要用到反射。</p>
<p>反射功能主要通过 java.lang.Class 类及 java.lang.reflect 包中的类如 Method, Field, Constructor 等来实现。<br>
<img decoding="async" loading="lazy" alt="反射相关类" src="/doc/assets/images/反射相关类-053459563f12f6c94d60ab6f7056edb5.png" width="1564" height="956" class="img_ev3q"></p>
<p>比如说我们可以装来动态加载类并创建对象：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   String className = &quot;java.util.Date&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   Class&lt;?&gt; cls = Class.forName(className);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   Object obj = cls.newInstance();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   System.out.println(obj.getClass().getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>比如说我们可以这样来访问字段和方法：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 加载并实例化类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Class&lt;?&gt; cls = Class.forName(&quot;java.util.Date&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Object obj = cls.newInstance();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 获取并调用方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Method method = cls.getMethod(&quot;getTime&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Object result = method.invoke(obj);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(&quot;Time: &quot; + result);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 访问字段</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Field field = cls.getDeclaredField(&quot;fastTime&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    field.setAccessible(true); // 对于私有字段需要这样做</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(&quot;fastTime: &quot; + field.getLong(obj));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="反射有哪些应用场景">反射有哪些应用场景？<a href="#反射有哪些应用场景" class="hash-link" aria-label="Direct link to 反射有哪些应用场景？" title="Direct link to 反射有哪些应用场景？">​</a></h3>
<p>①、Spring 框架就大量使用了反射来动态加载和管理 Bean。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Class&lt;?&gt; clazz = Class.forName(&quot;com.example.MyClass&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Object instance = clazz.newInstance();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>②、Java 的动态代理（Dynamic Proxy）机制就使用了反射来创建代理类。代理类可以在运行时动态处理方法调用，这在实现 AOP 和拦截器时非常有用。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    InvocationHandler handler = new MyInvocationHandler();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MyInterface proxyInstance = (MyInterface) Proxy.newProxyInstance(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            MyInterface.class.getClassLoader(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new Class&lt;?&gt;[]{MyInterface.class},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            handler</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>③、JUnit 和 TestNG 等测试框架使用反射机制来发现和执行测试方法。反射允许框架扫描类，查找带有特定注解（如 @Test）的方法，并在运行时调用它们。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Method testMethod = testClass.getMethod(&quot;testSomething&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">testMethod.invoke(testInstance);</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="反射的原理是什么">反射的原理是什么？<a href="#反射的原理是什么" class="hash-link" aria-label="Direct link to 反射的原理是什么？" title="Direct link to 反射的原理是什么？">​</a></h3>
<p>Java 程序的执行分为编译和运行两步，编译之后会生成字节码(.class)文件，JVM 进行类加载的时候，会加载字节码文件，将类型相关的所有信息加载进方法区，反射就是去获取这些信息，然后进行各种操作。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="jdk18-新特性">JDK1.8 新特性<a href="#jdk18-新特性" class="hash-link" aria-label="Direct link to JDK1.8 新特性" title="Direct link to JDK1.8 新特性">​</a></h2>
<p>JDK 1.8 新增了不少新的特性，如 Lambda 表达式、接口默认方法、Stream API、日期时间 API、Optional 类等。<br>
<!-- -->①、Java 8 允许在接口中添加默认方法和静态方法。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public interface MyInterface {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    default void myDefaultMethod() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;My default method&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static void myStaticMethod() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;My static method&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>②、Lambda 表达式描述了一个代码块（或者叫匿名方法），可以将其作为参数传递给构造方法或者普通方法以便后续执行。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class LamadaTest {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new Thread(() -&gt; System.out.println(&quot;沉默王二&quot;)).start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>③、Stream 是对 Java 集合框架的增强，它提供了一种高效且易于使用的数据处理方式。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    list.add(&quot;中国加油&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    list.add(&quot;世界加油&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    list.add(&quot;世界加油&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long count = list.stream().distinct().count();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(count);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>④、Java 8 引入了一个全新的日期和时间 API，位于java.time包中。这个新的 API 纠正了旧版java.util.Date类中的许多缺陷。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    LocalDate today = LocalDate.now();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(&quot;Today&#x27;s Local date : &quot; + today);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    LocalTime time = LocalTime.now();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(&quot;Local time : &quot; + time);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    LocalDateTime now = LocalDateTime.now();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(&quot;Current DateTime : &quot; + now);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>⑤、引入 Optional 是为了减少空指针异常。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Optional&lt;String&gt; optional = Optional.of(&quot;沉默王二&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    optional.isPresent();           // true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    optional.get();                 // &quot;沉默王二&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    optional.orElse(&quot;沉默王三&quot;);    // &quot;bam&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    optional.ifPresent((s) -&gt; System.out.println(s.charAt(0)));     // &quot;沉&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="lambda-表达式了解多少">Lambda 表达式了解多少？<a href="#lambda-表达式了解多少" class="hash-link" aria-label="Direct link to Lambda 表达式了解多少？" title="Direct link to Lambda 表达式了解多少？">​</a></h3>
<p>Lambda 表达式主要用于提供一种简洁的方式来表示匿名方法，使 Java 具备了函数式编程的特性。
比如说我们可以使用 Lambda 表达式来简化线程的创建：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    new Thread(() -&gt; System.out.println(&quot;Hello World&quot;)).start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>这比以前的匿名内部类要简洁很多。</p>
<p>所谓的函数式编程，就是把函数作为参数传递给方法，或者作为方法的结果返回。比如说我们可以配合 Stream 流进行数据过滤：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;Integer&gt; evenNumbers = numbers.stream()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .filter(n -&gt; n % 2 == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .collect(Collectors.toList());</span><br></span></code></pre></div></div>
<p>其中 n -&gt; n % 2 == 0 就是一个 Lambda 表达式。表示传入一个参数 n，返回 n % 2 == 0 的结果。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="java8-有哪些内置函数式接口">Java8 有哪些内置函数式接口？<a href="#java8-有哪些内置函数式接口" class="hash-link" aria-label="Direct link to Java8 有哪些内置函数式接口？" title="Direct link to Java8 有哪些内置函数式接口？">​</a></h3>
<p>JDK 1.8 API 包含了很多内置的函数式接口。其中就包括我们在老版本中经常见到的 Comparator 和 Runnable，Java 8 为他们都添加了 @FunctionalInterface 注解，以用来支持 Lambda 表达式。<br>
<!-- -->除了这两个之外，还有 Callable、Predicate、Function、Supplier、Consumer 等等。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="optional-了解吗">Optional 了解吗？<a href="#optional-了解吗" class="hash-link" aria-label="Direct link to Optional 了解吗？" title="Direct link to Optional 了解吗？">​</a></h3>
<p>可以将 Optional 看做是包装对象（可能是 null, 也有可能非 null）的容器。当我们定义了 一个方法，这个方法返回的对象可能是空，也有可能非空的时候，我们就可以考虑用 Optional 来包装它，这也是在 Java 8 被推荐使用的做法。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Optional&lt;String&gt; optional = Optional.of(&quot;bam&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    optional.isPresent();           // true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    optional.get();                 // &quot;bam&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    optional.orElse(&quot;fallback&quot;);    // &quot;bam&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    optional.ifPresent((s) -&gt; System.out.println(s.charAt(0)));     // &quot;b&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="stream-流用过吗">Stream 流用过吗？<a href="#stream-流用过吗" class="hash-link" aria-label="Direct link to Stream 流用过吗？" title="Direct link to Stream 流用过吗？">​</a></h3>
<p>Stream 流，简单来说，使用 java.util.Stream 对一个包含一个或多个元素的集合做各种操作。这些操作可能是 中间操作 亦或是 终端操作。 终端操作会返回一个结果，而中间操作会返回一个 Stream 流。<br>
<!-- -->Stream 流一般用于集合，我们对一个集合做几个常见操作：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    List&lt;String&gt; stringCollection = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stringCollection.add(&quot;ddd2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stringCollection.add(&quot;aaa2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stringCollection.add(&quot;bbb1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stringCollection.add(&quot;aaa1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stringCollection.add(&quot;bbb3&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stringCollection.add(&quot;ccc&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stringCollection.add(&quot;bbb2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stringCollection.add(&quot;ddd1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>Filter 过滤
Sorted 排序
Map 转换
Match 匹配
Count 计数
Reduce**</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-tags-row"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a rel="tag" class="tag_zVej tagRegular_sFm0" href="/doc/docs/tags/interview">INTERVIEW</a></li><li class="tag_QGVx"><a rel="tag" class="tag_zVej tagRegular_sFm0" href="/doc/docs/tags/java">JAVA</a></li></ul></div></div><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/JAVA/java-review.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/doc/docs/INTERVIEW/JAVA/JVM"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">JAVA-JVM</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/doc/docs/INTERVIEW/MQ"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">KAFKA_REVIEW</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#基础语法" class="table-of-contents__link toc-highlight">基础语法</a><ul><li><a href="#java-有哪些数据类型" class="table-of-contents__link toc-highlight">🌟Java 有哪些数据类型？</a></li><li><a href="#boolean-类型实际占用几个字节" class="table-of-contents__link toc-highlight">boolean 类型实际占用几个字节？</a></li><li><a href="#给integer最大值1是什么结果" class="table-of-contents__link toc-highlight">给Integer最大值+1，是什么结果？</a></li><li><a href="#自动类型转换强制类型转换了解吗" class="table-of-contents__link toc-highlight">自动类型转换、强制类型转换了解吗？</a></li><li><a href="#什么是自动拆箱装箱" class="table-of-contents__link toc-highlight">什么是自动拆箱/装箱？</a></li><li><a href="#和有什么区别" class="table-of-contents__link toc-highlight">&amp;和&amp;&amp;有什么区别？</a></li><li><a href="#switch-语句能否用在-bytelongstring-类型上" class="table-of-contents__link toc-highlight">switch 语句能否用在 byte/long/String 类型上？</a></li><li><a href="#breakcontinuereturn-的区别及作用" class="table-of-contents__link toc-highlight">break,continue,return 的区别及作用？</a></li><li><a href="#用效率最高的方法计算-2-乘以-8" class="table-of-contents__link toc-highlight">用效率最高的方法计算 2 乘以 8？</a></li><li><a href="#说说自增自减运算" class="table-of-contents__link toc-highlight">说说自增自减运算？</a></li><li><a href="#float-是怎么表示小数的补充" class="table-of-contents__link toc-highlight">float 是怎么表示小数的？（补充）</a></li><li><a href="#讲一下数据准确性高是怎么保证的补充" class="table-of-contents__link toc-highlight">讲一下数据准确性高是怎么保证的？（补充）</a></li></ul></li><li><a href="#面向对象" class="table-of-contents__link toc-highlight">面向对象</a><ul><li><a href="#向对象和向过程的区别" class="table-of-contents__link toc-highlight">⾯向对象和⾯向过程的区别?</a></li><li><a href="#面向对象编程有哪些特性" class="table-of-contents__link toc-highlight">🌟面向对象编程有哪些特性？</a></li><li><a href="#为什么java里面要多组合少继承" class="table-of-contents__link toc-highlight">为什么Java里面要多组合少继承？</a></li><li><a href="#多态解决了什么问题补充" class="table-of-contents__link toc-highlight">多态解决了什么问题？（补充）</a></li><li><a href="#多态的实现原理是什么" class="table-of-contents__link toc-highlight">多态的实现原理是什么？</a></li><li><a href="#重载和重写的区别" class="table-of-contents__link toc-highlight">重载和重写的区别？</a></li><li><a href="#什么是里氏代换原则" class="table-of-contents__link toc-highlight">什么是里氏代换原则？</a></li><li><a href="#访问修饰符-publicprivateprotected以及默认时的区别" class="table-of-contents__link toc-highlight">访问修饰符 public、private、protected、以及默认时的区别？</a></li><li><a href="#this-关键字有什么作用" class="table-of-contents__link toc-highlight">this 关键字有什么作用？</a></li><li><a href="#抽象类和接口有什么区别" class="table-of-contents__link toc-highlight">🌟抽象类和接口有什么区别？</a></li><li><a href="#抽象类可以定义构造方法吗" class="table-of-contents__link toc-highlight">抽象类可以定义构造方法吗？</a></li><li><a href="#接口可以定义构造方法吗" class="table-of-contents__link toc-highlight">接口可以定义构造方法吗？</a></li><li><a href="#java支持多继承吗" class="table-of-contents__link toc-highlight">Java支持多继承吗？</a></li><li><a href="#接口可以多继承吗" class="table-of-contents__link toc-highlight">接口可以多继承吗？</a></li><li><a href="#继承和抽象的区别" class="table-of-contents__link toc-highlight">继承和抽象的区别？</a></li><li><a href="#抽象类和普通类的区别" class="table-of-contents__link toc-highlight">抽象类和普通类的区别？</a></li><li><a href="#成员变量与局部变量的区别有哪些" class="table-of-contents__link toc-highlight">成员变量与局部变量的区别有哪些？</a></li><li><a href="#static-关键字了解吗" class="table-of-contents__link toc-highlight">static 关键字了解吗？</a></li><li><a href="#final-关键字有什么作用" class="table-of-contents__link toc-highlight">final 关键字有什么作用？</a></li><li><a href="#finalfinallyfinalize-的区别" class="table-of-contents__link toc-highlight">final、finally、finalize 的区别？</a></li><li><a href="#为什么重写-equals-时必须重写-hashcode-法" class="table-of-contents__link toc-highlight">🌟为什么重写 equals 时必须重写 hashCode ⽅法？</a></li><li><a href="#什么是-hashcode-方法" class="table-of-contents__link toc-highlight">什么是 hashCode 方法？</a></li><li><a href="#为什么要有-hashcode-方法" class="table-of-contents__link toc-highlight">为什么要有 hashCode 方法？</a></li><li><a href="#为什么两个对象有相同的-hashcode-值它们也不定相等" class="table-of-contents__link toc-highlight">为什么两个对象有相同的 hashcode 值，它们也不⼀定相等？</a></li><li><a href="#hashcode-和-equals-方法的关系" class="table-of-contents__link toc-highlight">hashCode 和 equals 方法的关系？</a></li><li><a href="#java-是值传递还是引用传递" class="table-of-contents__link toc-highlight">Java 是值传递，还是引用传递？</a></li><li><a href="#引用类型的变量有什么特点" class="table-of-contents__link toc-highlight">引用类型的变量有什么特点？</a></li><li><a href="#说说深拷贝和浅拷贝的区别" class="table-of-contents__link toc-highlight">说说深拷贝和浅拷贝的区别?</a></li><li><a href="#java-创建对象有哪几种方式" class="table-of-contents__link toc-highlight">Java 创建对象有哪几种方式？</a></li><li><a href="#new-子类的时候子类和父类静态代码块构造方法的执行顺序" class="table-of-contents__link toc-highlight">new 子类的时候，子类和父类静态代码块，构造方法的执行顺序</a></li></ul></li><li><a href="#string" class="table-of-contents__link toc-highlight">String</a><ul><li><a href="#string-是-java-基本数据类型吗可以被继承吗" class="table-of-contents__link toc-highlight">String 是 Java 基本数据类型吗？可以被继承吗？</a></li><li><a href="#string-有哪些常用方法" class="table-of-contents__link toc-highlight">String 有哪些常用方法？</a></li><li><a href="#string-和-stringbuilderstringbuffer-的区别" class="table-of-contents__link toc-highlight">🌟String 和 StringBuilder、StringBuffer 的区别？</a></li><li><a href="#string-str1--new-stringabc-和-string-str2--abc-的区别" class="table-of-contents__link toc-highlight">String str1 = new String(&quot;abc&quot;) 和 String str2 = &quot;abc&quot; 的区别？</a></li><li><a href="#string-s--new-stringabc创建了几个对象" class="table-of-contents__link toc-highlight">String s = new String(&quot;abc&quot;)创建了几个对象？</a></li><li><a href="#string-是不可变类吗字符串拼接是如何实现的" class="table-of-contents__link toc-highlight">String 是不可变类吗？字符串拼接是如何实现的？</a></li><li><a href="#字符串拼接是如何实现的" class="table-of-contents__link toc-highlight">字符串拼接是如何实现的？</a></li><li><a href="#如何保证-string-不可变" class="table-of-contents__link toc-highlight">如何保证 String 不可变？</a></li><li><a href="#intern-方法有什么作用" class="table-of-contents__link toc-highlight">intern 方法有什么作用？</a></li><li><a href="#integer-a-127integer-b--127integer-c-128integer-d--128相等吗" class="table-of-contents__link toc-highlight">Integer a= 127，Integer b = 127；Integer c= 128，Integer d = 128；相等吗?</a></li><li><a href="#什么是-integer-缓存" class="table-of-contents__link toc-highlight">什么是 Integer 缓存？</a></li><li><a href="#new-integer10--new-integer10-相等吗" class="table-of-contents__link toc-highlight">new Integer(10) == new Integer(10) 相等吗</a></li><li><a href="#string-怎么转成-integer-的原理" class="table-of-contents__link toc-highlight">String 怎么转成 Integer 的原理？</a></li></ul></li><li><a href="#object" class="table-of-contents__link toc-highlight">Object</a></li><li><a href="#异常处理" class="table-of-contents__link toc-highlight">异常处理</a><ul><li><a href="#java-中异常处理体系" class="table-of-contents__link toc-highlight">🌟Java 中异常处理体系?</a></li><li><a href="#异常的处理方式" class="table-of-contents__link toc-highlight">异常的处理方式？</a></li><li><a href="#catch和finally的异常可以同时抛出吗" class="table-of-contents__link toc-highlight">catch和finally的异常可以同时抛出吗？</a></li></ul></li><li><a href="#io" class="table-of-contents__link toc-highlight">I/O</a><ul><li><a href="#java-中-io-流分为几种" class="table-of-contents__link toc-highlight">Java 中 IO 流分为几种?</a></li><li><a href="#io-流用到了什么设计模式" class="table-of-contents__link toc-highlight">IO 流用到了什么设计模式？</a></li><li><a href="#既然有了字节流为什么还要有字符流" class="table-of-contents__link toc-highlight">既然有了字节流,为什么还要有字符流?</a></li><li><a href="#文本存储是字节流还是字符流视频文件呢" class="table-of-contents__link toc-highlight">文本存储是字节流还是字符流，视频文件呢？</a></li><li><a href="#bionioaio-之间的区别" class="table-of-contents__link toc-highlight">🌟BIO、NIO、AIO 之间的区别？</a></li><li><a href="#简单说一下-bio" class="table-of-contents__link toc-highlight">简单说一下 BIO？</a></li><li><a href="#简单说下-nio" class="table-of-contents__link toc-highlight">简单说下 NIO？</a></li><li><a href="#简单说下-aio" class="table-of-contents__link toc-highlight">简单说下 AIO？</a></li></ul></li><li><a href="#序列化" class="table-of-contents__link toc-highlight">序列化</a><ul><li><a href="#什么是序列化什么是反序列化" class="table-of-contents__link toc-highlight">什么是序列化？什么是反序列化？</a></li><li><a href="#serializable-接口有什么用" class="table-of-contents__link toc-highlight">Serializable 接口有什么用？</a></li><li><a href="#能解释一下序列化的过程和作用吗" class="table-of-contents__link toc-highlight">能解释一下序列化的过程和作用吗？</a></li><li><a href="#说说有几种序列化方式" class="table-of-contents__link toc-highlight">说说有几种序列化方式？</a></li></ul></li><li><a href="#网络编程" class="table-of-contents__link toc-highlight">网络编程</a><ul><li><a href="#了解过socket网络套接字吗补充" class="table-of-contents__link toc-highlight">了解过Socket网络套接字吗？（补充）</a></li><li><a href="#rpc框架了解吗" class="table-of-contents__link toc-highlight">RPC框架了解吗？</a></li></ul></li><li><a href="#泛型" class="table-of-contents__link toc-highlight">泛型</a><ul><li><a href="#java-泛型了解么" class="table-of-contents__link toc-highlight">Java 泛型了解么？</a></li><li><a href="#泛型常用的通配符有哪些" class="table-of-contents__link toc-highlight">泛型常用的通配符有哪些？</a></li><li><a href="#什么是泛型擦除" class="table-of-contents__link toc-highlight">什么是泛型擦除？</a></li><li><a href="#为什么要类型擦除呢" class="table-of-contents__link toc-highlight">为什么要类型擦除呢？</a></li></ul></li><li><a href="#注解" class="table-of-contents__link toc-highlight">注解</a><ul><li><a href="#说一下你对注解的理解" class="table-of-contents__link toc-highlight">说一下你对注解的理解？</a></li></ul></li><li><a href="#反射" class="table-of-contents__link toc-highlight">反射</a><ul><li><a href="#什么是反射应用原理" class="table-of-contents__link toc-highlight">🌟什么是反射？应用？原理？</a></li><li><a href="#反射有哪些应用场景" class="table-of-contents__link toc-highlight">反射有哪些应用场景？</a></li><li><a href="#反射的原理是什么" class="table-of-contents__link toc-highlight">反射的原理是什么？</a></li></ul></li><li><a href="#jdk18-新特性" class="table-of-contents__link toc-highlight">JDK1.8 新特性</a><ul><li><a href="#lambda-表达式了解多少" class="table-of-contents__link toc-highlight">Lambda 表达式了解多少？</a></li><li><a href="#java8-有哪些内置函数式接口" class="table-of-contents__link toc-highlight">Java8 有哪些内置函数式接口？</a></li><li><a href="#optional-了解吗" class="table-of-contents__link toc-highlight">Optional 了解吗？</a></li><li><a href="#stream-流用过吗" class="table-of-contents__link toc-highlight">Stream 流用过吗？</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/doc/docs/intro">Tutorial</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://x.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">X<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/doc/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>