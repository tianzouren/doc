<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-java/JAVA-JVM" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.8.1">
<title data-rh="true">JAVA-JVM | My Site</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://your-docusaurus-site.example.com/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://your-docusaurus-site.example.com/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://your-docusaurus-site.example.com/docs/INTERVIEW/JAVA/JVM"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="JAVA-JVM | My Site"><meta data-rh="true" name="description" content="JAVA-JVM"><meta data-rh="true" property="og:description" content="JAVA-JVM"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://your-docusaurus-site.example.com/docs/INTERVIEW/JAVA/JVM"><link data-rh="true" rel="alternate" href="https://your-docusaurus-site.example.com/docs/INTERVIEW/JAVA/JVM" hreflang="en"><link data-rh="true" rel="alternate" href="https://your-docusaurus-site.example.com/docs/INTERVIEW/JAVA/JVM" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"java","item":"https://your-docusaurus-site.example.com/docs/java/"},{"@type":"ListItem","position":2,"name":"JAVA-JVM","item":"https://your-docusaurus-site.example.com/docs/INTERVIEW/JAVA/JVM"}]}</script><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="My Site RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="My Site Atom Feed"><link rel="stylesheet" href="/assets/css/styles.a7778f11.css">
<script src="/assets/js/runtime~main.32c72435.js" defer="defer"></script>
<script src="/assets/js/main.405bc298.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t="light";var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",e||t),document.documentElement.setAttribute("data-theme-choice",e||t)}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/img/logo.svg"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">My Site</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/intro">Tutorial</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="Switch between dark and light mode (currently system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">Tutorial Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/tutorial---basics">Tutorial - Basics</a><button aria-label="Expand sidebar category &#x27;Tutorial - Basics&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/category/tutorial---extras">Tutorial - Extras</a><button aria-label="Expand sidebar category &#x27;Tutorial - Extras&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/docs/java/">java</a><button aria-label="Collapse sidebar category &#x27;java&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java-aqs">java-aqs</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/INTERVIEW/JAVA/JVM">JAVA-JVM</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java_collection_review">java_collection_review</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java_concurrent">java_concurrent</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/java/java_review">java_review</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/intereview/rocketmq">mq</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/mysql/mysql-review">mysql</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/nginx/nginx-review">nginx</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/intereview/redis">redis</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/spring/spring-review">spring</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/tmp">tmp</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/分布式/分布式 -review">分布式</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/微服务/微服务-review">微服务</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><a class="breadcrumbs__link" href="/docs/java/"><span>java</span></a></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">JAVA-JVM</span></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>JAVA-JVM</h1></header><h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说-jvm-的其他特性">说说 JVM 的其他特性？<a href="#说说-jvm-的其他特性" class="hash-link" aria-label="Direct link to 说说 JVM 的其他特性？" title="Direct link to 说说 JVM 的其他特性？">​</a></h3>
<p>①、JVM 可以自动管理内存，通过垃圾回收器回收不再使用的对象并释放内存空间。</p>
<p>②、JVM 包含一个即时编译器 JIT，它可以在运行时将热点代码缓存到 codeCache 中，下次执行的时候不用再一行一行的解释，而是直接执行缓存后的机器码，执行效率会大幅提高。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说-jvm-的组织架构补充">说说 JVM 的组织架构（补充）<a href="#说说-jvm-的组织架构补充" class="hash-link" aria-label="Direct link to 说说 JVM 的组织架构（补充）" title="Direct link to 说说 JVM 的组织架构（补充）">​</a></h3>
<p>推荐阅读：大白话带你认识 JVM
JVM 大致可以划分为三个部分：类加载器、运行时数据区和执行引擎。
<img decoding="async" loading="lazy" alt="1757509455187" src="/assets/images/1757509455187-0796d4552aaebb33764db5f19e1571bf.png" width="1080" height="882" class="img_ev3q">
① 类加载器，负责从文件系统、网络或其他来源加载 Class 文件，将 Class 文件中的二进制数据读入到内存当中。</p>
<p>② 运行时数据区，JVM 在执行 Java 程序时，需要在内存中分配空间来处理各种数据，这些内存区域按照 Java 虚拟机规范可以划分为方法区、堆、虚拟机栈、程序计数器和本地方法栈。</p>
<p>③ 执行引擎，也是 JVM 的心脏，负责执行字节码。它包括一个虚拟处理器、即时编译器 JIT 和垃圾回收器。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="内存管理">内存管理<a href="#内存管理" class="hash-link" aria-label="Direct link to 内存管理" title="Direct link to 内存管理">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="能说一下-jvm-的内存区域吗">🌟能说一下 JVM 的内存区域吗？<a href="#能说一下-jvm-的内存区域吗" class="hash-link" aria-label="Direct link to 🌟能说一下 JVM 的内存区域吗？" title="Direct link to 🌟能说一下 JVM 的内存区域吗？">​</a></h3>
<p>推荐阅读：深入理解 JVM 的运行时数据区
按照 Java 虚拟机规范，JVM 的内存区域可以细分为程序计数器、虚拟机栈、本地方法栈、堆和方法区。
<img decoding="async" loading="lazy" alt="1757509506890" src="/assets/images/1757509506890-177b1d8b09d65fda209360548c173c9f.png" width="683" height="632" class="img_ev3q">
其中方法区和堆是线程共享的，虚拟机栈、本地方法栈和程序计数器是线程私有的。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="介绍一下程序计数器">介绍一下程序计数器？<a href="#介绍一下程序计数器" class="hash-link" aria-label="Direct link to 介绍一下程序计数器？" title="Direct link to 介绍一下程序计数器？">​</a></h3>
<p>程序计数器也被称为 PC 寄存器，是一块较小的内存空间。它可以看作是当前线程所执行的字节码行号指示器。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="介绍一下-java-虚拟机栈">介绍一下 Java 虚拟机栈？<a href="#介绍一下-java-虚拟机栈" class="hash-link" aria-label="Direct link to 介绍一下 Java 虚拟机栈？" title="Direct link to 介绍一下 Java 虚拟机栈？">​</a></h3>
<p>Java 虚拟机栈的生命周期与线程相同。</p>
<p>当线程执行一个方法时，会创建一个对应的栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，然后栈帧会被压入虚拟机栈中。当方法执行完毕后，栈帧会从虚拟机栈中移除。
<img decoding="async" loading="lazy" alt="1757509541681" src="/assets/images/1757509541681-c6cac4178bbb174e6fa8feb03efb696e.png" width="549" height="672" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="一个什么都没有的空方法空的参数都没有那局部变量表里有没有变量">一个什么都没有的空方法，空的参数都没有，那局部变量表里有没有变量？<a href="#一个什么都没有的空方法空的参数都没有那局部变量表里有没有变量" class="hash-link" aria-label="Direct link to 一个什么都没有的空方法，空的参数都没有，那局部变量表里有没有变量？" title="Direct link to 一个什么都没有的空方法，空的参数都没有，那局部变量表里有没有变量？">​</a></h3>
<p>对于静态方法，由于不需要访问实例对象 this，因此在局部变量表中不会有任何变量。</p>
<p>对于非静态方法，即使是一个完全空的方法，局部变量表中也会有一个用于存储 this 引用的变量。this 引用指向当前实例对象，在方法调用时被隐式传入。</p>
<p>详细解释一下：</p>
<p>比如说有这样一段代码：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class VarDemo1 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void emptyMethod() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 什么都没有</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void staticEmptyMethod() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 什么都没有</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>用 javap -v VarDemo1 命令查看编译后的字节码，就可以在 emptyMethod 中看到这样的内容：
<img decoding="async" loading="lazy" alt="1757509587220" src="/assets/images/1757509587220-05b868f6d62059cff36324d03c18a34b.png" width="1500" height="512" class="img_ev3q">
这里的 locals=1 表示局部变量表有一个变量，即 this，Slot 0 位置存储了 this 引用。</p>
<p>而在静态方法 staticEmptyMethod 中，你会看到这样的内容：
<img decoding="async" loading="lazy" alt="1757509630504" src="/assets/images/1757509630504-ce5b9eb2e64585ad1c9588c984aa34cf.png" width="788" height="352" class="img_ev3q">
这里的 locals=0 表示局部变量表为空，因为静态方法属于类级别方法，不需要 this 引用，也就没有局部变量。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="介绍一下本地方法栈">介绍一下本地方法栈？<a href="#介绍一下本地方法栈" class="hash-link" aria-label="Direct link to 介绍一下本地方法栈？" title="Direct link to 介绍一下本地方法栈？">​</a></h3>
<p>本地方法栈与虚拟机栈相似，区别在于虚拟机栈是为 JVM 执行 Java 编写的方法服务的，而本地方法栈是为 Java 调用本地 native 方法服务的，通常由 C/C++ 编写。</p>
<p>在本地方法栈中，主要存放了 native 方法的局部变量、动态链接和方法出口等信息。当一个 Java 程序调用一个 native 方法时，JVM 会切换到本地方法栈来执行这个方法。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="介绍一下本地方法栈的运行场景">介绍一下本地方法栈的运行场景？<a href="#介绍一下本地方法栈的运行场景" class="hash-link" aria-label="Direct link to 介绍一下本地方法栈的运行场景？" title="Direct link to 介绍一下本地方法栈的运行场景？">​</a></h3>
<p>当 Java 应用需要与操作系统底层或硬件交互时，通常会用到本地方法栈。</p>
<p>比如调用操作系统的特定功能，如内存管理、文件操作、系统时间、系统调用等。
详细说明一下：
比如说获取系统时间的 System.currentTimeMillis() 方法就是调用本地方法，来获取操作系统当前时间的。
再比如 JVM 自身的一些底层功能也需要通过本地方法来实现。像 Object 类中的 hashCode() 方法、clone() 方法等。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="native-方法解释一下">native 方法解释一下？<a href="#native-方法解释一下" class="hash-link" aria-label="Direct link to native 方法解释一下？" title="Direct link to native 方法解释一下？">​</a></h3>
<p>推荐阅读：手把手教你用 C语言实现 Java native 本地方法</p>
<p>native 方法是在 Java 中通过 native 关键字声明的，用于调用非 Java 语言，如 C/C++ 编写的代码。Java 可以通过 JNI，也就是 Java Native Interface 与底层系统、硬件设备、或者本地库进行交互。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="介绍一下-java-堆">介绍一下 Java 堆？<a href="#介绍一下-java-堆" class="hash-link" aria-label="Direct link to 介绍一下 Java 堆？" title="Direct link to 介绍一下 Java 堆？">​</a></h3>
<p>堆是 JVM 中最大的一块内存区域，被所有线程共享，在 JVM 启动时创建，主要用来存储 new 出来的对象。
<img decoding="async" loading="lazy" alt="1757509720933" src="/assets/images/1757509720933-5141a349b913e835ddf84401b8a02215.png" width="792" height="556" class="img_ev3q">
Java 中“几乎”所有的对象都会在堆中分配，堆也是垃圾收集器管理的目标区域。</p>
<p>从内存回收的角度来看，由于垃圾收集器大部分都是基于分代收集理论设计的，所以堆又被细分为新生代、老年代、Eden空间、From Survivor空间、To Survivor空间等。
<img decoding="async" loading="lazy" alt="1757509808896" src="/assets/images/1757509808896-59921fe7418b41bd1210bcd8235f72d0.png" width="742" height="375" class="img_ev3q"></p>
<p>随着 JIT 编译器的发展和逃逸技术的逐渐成熟，“所有的对象都会分配到堆上”就不再那么绝对了。</p>
<p>从 JDK 7 开始，JVM 默认开启了逃逸分析，意味着如果某些方法中的对象引用没有被返回或者没有在方法体外使用，也就是未逃逸出去，那么对象可以直接在栈上分配内存。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="堆和栈的区别是什么">堆和栈的区别是什么？<a href="#堆和栈的区别是什么" class="hash-link" aria-label="Direct link to 堆和栈的区别是什么？" title="Direct link to 堆和栈的区别是什么？">​</a></h3>
<p>堆属于线程共享的内存区域，几乎所有 new 出来的对象都会堆上分配，生命周期不由单个方法调用所决定，可以在方法调用结束后继续存在，直到不再被任何变量引用，最后被垃圾收集器回收。</p>
<p>栈属于线程私有的内存区域，主要存储局部变量、方法参数、对象引用等，通常随着方法调用的结束而自动释放，不需要垃圾收集器处理。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="介绍一下方法区">介绍一下方法区？<a href="#介绍一下方法区" class="hash-link" aria-label="Direct link to 介绍一下方法区？" title="Direct link to 介绍一下方法区？">​</a></h3>
<p>方法区并不真实存在，属于 Java 虚拟机规范中的一个逻辑概念，用于存储已被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码缓存等。</p>
<p>在 HotSpot 虚拟机中，方法区的实现称为永久代 PermGen，但在 Java 8 及之后的版本中，已经被元空间 Metaspace 所替代。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="变量存在堆栈的什么位置">变量存在堆栈的什么位置？<a href="#变量存在堆栈的什么位置" class="hash-link" aria-label="Direct link to 变量存在堆栈的什么位置？" title="Direct link to 变量存在堆栈的什么位置？">​</a></h3>
<p>对于局部变量，它存储在当前方法栈帧中的局部变量表中。当方法执行完毕，栈帧被回收，局部变量也会被释放。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public void method() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int localVar = 100;  // 局部变量，存储在栈帧中的局部变量表里</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>对于静态变量来说，它存储在 Java 虚拟机规范中的方法区中，在 Java 7 中是永久带，在 Java8 及以后 是元空间。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class StaticVarDemo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static int staticVar = 100;  // 静态变量，存储在方法区中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说一下-jdk-161718-内存区域的变化">说一下 JDK 1.6、1.7、1.8 内存区域的变化？<a href="#说一下-jdk-161718-内存区域的变化" class="hash-link" aria-label="Direct link to 说一下 JDK 1.6、1.7、1.8 内存区域的变化？" title="Direct link to 说一下 JDK 1.6、1.7、1.8 内存区域的变化？">​</a></h3>
<p>JDK 1.6 使用永久代来实现方法区：</p>
<p><img decoding="async" loading="lazy" alt="alt text" src="/assets/images/image-f89a6da1c07c966dedf7316e59b64a13.png" width="708" height="354" class="img_ev3q"></p>
<p>JDK 1.7 时仍然是永久带，但发生了一些细微变化，比如将字符串常量池、静态变量存放到了堆上。
<img decoding="async" loading="lazy" alt="1757509911757" src="/assets/images/1757509911757-b03e051d500daa5157c873e4c69d803f.png" width="856" height="384" class="img_ev3q">
在 JDK 1.8 时，直接在内存中划出了一块区域，叫元空间，来取代之前放在 JVM 内存中的永久代，并将运行时常量池、类常量池都移动到了元空间。</p>
<p><img decoding="async" loading="lazy" alt="1757510017812" src="/assets/images/1757510017812-8bc0dca280c6d64a7d254303d2dc9d13.png" width="693" height="563" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么使用元空间替代永久代">为什么使用元空间替代永久代？<a href="#为什么使用元空间替代永久代" class="hash-link" aria-label="Direct link to 为什么使用元空间替代永久代？" title="Direct link to 为什么使用元空间替代永久代？">​</a></h3>
<p>客观上，永久代会导致 Java 应用程序更容易出现内存溢出的问题，因为它要受到 JVM 内存大小的限制。</p>
<p>HotSpot 虚拟机的永久代大小可以通过 -XX：MaxPermSize 参数来设置，32 位机器默认的大小为 64M，64 位的机器则为 85M。</p>
<p>而 J9 和 JRockit 虚拟机就不存在这种限制，只要没有触碰到进程可用的内存上限，例如 32 位系统中的 4GB 限制，就不会出问题。</p>
<p>主观上，当 Oracle 收购 BEA 获得了 JRockit 的所有权后，就准备把 JRockit 中的优秀功能移植到 HotSpot 中。</p>
<p>如 Java Mission Control 管理工具。</p>
<p>但因为两个虚拟机对方法区实现有差异，导致这项工作遇到了很多阻力。</p>
<p>考虑到 HotSpot 虚拟机未来的发展，JDK 6 的时候，开发团队就打算放弃永久代了。</p>
<p>JDK 7 的时候，前进了一小步，把原本放在永久代的字符串常量池、静态变量等移动到了堆中。</p>
<p>JDK 8 就终于完成了这项移出工作，这样的好处就是，元空间的大小不再受到 JVM 内存的限制，而是可以像 J9 和 JRockit 那样，只要系统内存足够，就可以一直用。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="对象创建的过程了解吗">🌟对象创建的过程了解吗？<a href="#对象创建的过程了解吗" class="hash-link" aria-label="Direct link to 🌟对象创建的过程了解吗？" title="Direct link to 🌟对象创建的过程了解吗？">​</a></h3>
<p>当我们使用 new 关键字创建一个对象时，JVM 首先会检查 new 指令的参数是否能在常量池中定位到类的符号引用，然后检查这个符号引用代表的类是否已被加载、解析和初始化。如果没有，就先执行类加载。</p>
<p><img decoding="async" loading="lazy" alt="1757510062509" src="/assets/images/1757510062509-851ba181ca7c4c499423e91fe1438fd2.png" width="1208" height="988" class="img_ev3q">
如果已经加载，JVM 会为对象分配内存完成初始化，比如数值类型的成员变量初始值是 0，布尔类型是 false，对象类型是 null。
接下来会设置对象头，里面包含了对象是哪个类的实例、对象的哈希码、对象的 GC 分代年龄等信息。
最后，JVM 会执行构造方法 init 完成赋值操作，将成员变量赋值为预期的值，比如 int age = 18，这样一个对象就创建完成了。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="对象的销毁过程了解吗">对象的销毁过程了解吗？<a href="#对象的销毁过程了解吗" class="hash-link" aria-label="Direct link to 对象的销毁过程了解吗？" title="Direct link to 对象的销毁过程了解吗？">​</a></h3>
<p>当对象不再被任何引用指向时，就会变成垃圾。垃圾收集器会通过可达性分析算法判断对象是否存活，如果对象不可达，就会被回收。</p>
<p>垃圾收集器通过标记清除、标记复制、标记整理等算法来回收内存，将对象占用的内存空间释放出来。</p>
<p>可以通过 java -XX:+PrintCommandLineFlags -version 和 java -XX:+PrintGCDetails -version 命令查看 JVM 的 GC 收集器。</p>
<p>可以看到，我本机安装的 JDK 8 默认使用的是 Parallel Scavenge + Parallel Old。</p>
<p>不同参数代表对应的垃圾收集器表单：
新生代	老年代	JVM参数
Serial	Serial	-XX:+UseSerialGC
Parallel Scavenge	Serial	-XX:+UseParallelGC -XX:-UseParallelOldGC
Parallel Scavenge	Parallel Old	-XX:+UseParallelGC -XX:+UseParallelOldGC
Parallel New	CMS	-XX:+UseParNewGC -XX:+UseConcMarkSweepGC
G1		-XX:+UseG1GC</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="堆内存是如何分配的">堆内存是如何分配的？<a href="#堆内存是如何分配的" class="hash-link" aria-label="Direct link to 堆内存是如何分配的？" title="Direct link to 堆内存是如何分配的？">​</a></h3>
<p>在堆中为对象分配内存时，主要使用两种策略：指针碰撞和空闲列表。</p>
<p><img decoding="async" loading="lazy" alt="1757510103131" src="/assets/images/1757510103131-31641832783e1816add3374d8d502310.png" width="631" height="584" class="img_ev3q"></p>
<p>指针碰撞适用于管理简单、碎片化较少的内存区域，如年轻代；而空闲列表适用于内存碎片化较严重或对象大小差异较大的场景如老年代。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是指针碰撞">什么是指针碰撞？<a href="#什么是指针碰撞" class="hash-link" aria-label="Direct link to 什么是指针碰撞？" title="Direct link to 什么是指针碰撞？">​</a></h3>
<p>假设堆内存是一个连续的空间，分为两个部分，一部分是已经被使用的内存，另一部分是未被使用的内存。</p>
<p>在分配内存时，Java 虚拟机会维护一个指针，指向下一个可用的内存地址，每次分配内存时，只需要将指针向后移动一段距离，如果没有发生碰撞，就将这段内存分配给对象实例。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是空闲列表">什么是空闲列表？<a href="#什么是空闲列表" class="hash-link" aria-label="Direct link to 什么是空闲列表？" title="Direct link to 什么是空闲列表？">​</a></h3>
<p>JVM 维护一个列表，记录堆中所有未占用的内存块，每个内存块都记录有大小和地址信息。</p>
<p>当有新的对象请求内存时，JVM 会遍历空闲列表，寻找足够大的空间来存放新对象。</p>
<p>分配后，如果选中的内存块未被完全利用，剩余的部分会作为一个新的内存块加入到空闲列表中。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="new-对象时堆会发生抢占吗">new 对象时，堆会发生抢占吗？<a href="#new-对象时堆会发生抢占吗" class="hash-link" aria-label="Direct link to new 对象时，堆会发生抢占吗？" title="Direct link to new 对象时，堆会发生抢占吗？">​</a></h3>
<p><img decoding="async" loading="lazy" alt="1757510149853" src="/assets/images/1757510149853-b3c6e650f0157aedb0e8ce0e53f8726f.png" width="1024" height="456" class="img_ev3q"></p>
<p>new 对象时，指针会向右移动一个对象大小的距离，假如一个线程 A 正在给字符串对象 s 分配内存，另外一个线程 B 同时为 ArrayList 对象 l 分配内存，两个线程就发生了抢占。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="jvm-怎么解决堆内存分配的竞争问题">JVM 怎么解决堆内存分配的竞争问题？<a href="#jvm-怎么解决堆内存分配的竞争问题" class="hash-link" aria-label="Direct link to JVM 怎么解决堆内存分配的竞争问题？" title="Direct link to JVM 怎么解决堆内存分配的竞争问题？">​</a></h3>
<p>为了解决堆内存分配的竞争问题，JVM 为每个线程保留了一小块内存空间，被称为 TLAB，也就是线程本地分配缓冲区，用于存放该线程分配的对象。
<img decoding="async" loading="lazy" alt="1757510166426" src="/assets/images/1757510166426-5a06e60751506579b9638bcc41e3769f.png" width="1024" height="564" class="img_ev3q">
当线程需要分配对象时，直接从 TLAB 中分配。只有当 TLAB 用尽或对象太大需要直接在堆中分配时，才会使用全局分配指针。</p>
<p>这里简单测试一下 TLAB。</p>
<p>可以通过 java -XX:+PrintFlagsFinal -version | grep TLAB 命令查看当前 JVM 是否开启了 TLAB。
<img decoding="async" loading="lazy" alt="1757510186896" src="/assets/images/1757510186896-146b0ba8345a695116b9f073d6bf763f.png" width="2090" height="680" class="img_ev3q">
如果开启了 TLAB，会看到类似以下的输出，其中 bool UseTLAB 的值为 true。</p>
<p>我们编写一个简单的测试类，创建大量对象并强制触发垃圾回收，查看 TLAB 的使用情况。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class TLABDemo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; 10_000_000; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            allocate(); // 创建大量对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.gc(); // 强制触发垃圾回收</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static void allocate() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 小对象分配，通常会使用 TLAB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        byte[] bytes = new byte[64];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>在 VM 参数中添加 -XX:+UseTLAB -XX:+PrintTLAB -XX:+PrintGCDetails -XX:+PrintGCDateStamps，运行后可以看到这样的内容：
waste：未使用的 TLAB 空间。
alloc：分配到 TLAB 的空间。
refills：TLAB 被重新填充的次数。
可以看到，当前线程的 TLAB 目标大小为 10,496 KB（desired_size: 10496KB）；未发生慢分配（slow allocs: 0）；分配效率直接拉满（alloc: 1.00000 52494KB）。</p>
<p>当使用 -XX:-UseTLAB -XX:+PrintGCDetails 关闭 TLAB 时，会看到类似以下的输出：</p>
<p>直接出现了两次 GC，因为没有 TLAB，Eden 区更快被填满，导致年轻代 GC。年轻代 GC 频繁触发，一部分长生命周期对象被晋升到老年代，间接导致老年代 GC 触发。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="能说一下对象的内存布局吗">能说一下对象的内存布局吗？<a href="#能说一下对象的内存布局吗" class="hash-link" aria-label="Direct link to 能说一下对象的内存布局吗？" title="Direct link to 能说一下对象的内存布局吗？">​</a></h3>
<p>waitx
对象的内存布局是由 Java 虚拟机规范定义的，但具体的实现细节各有不同，如 HotSpot 和 OpenJ9 就不一样。</p>
<p>就拿我们常用的 HotSpot 来说吧。</p>
<p>对象在内存中包括三部分：对象头、实例数据和对齐填充。
<img decoding="async" loading="lazy" alt="1757510233720" src="/assets/images/1757510233720-3bef9bb290e4269bed2048de441d1acd.png" width="987" height="660" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="jvm-怎么访问对象的">JVM 怎么访问对象的？<a href="#jvm-怎么访问对象的" class="hash-link" aria-label="Direct link to JVM 怎么访问对象的？" title="Direct link to JVM 怎么访问对象的？">​</a></h3>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说一下对象有哪几种引用">说一下对象有哪几种引用？<a href="#说一下对象有哪几种引用" class="hash-link" aria-label="Direct link to 说一下对象有哪几种引用？" title="Direct link to 说一下对象有哪几种引用？">​</a></h3>
<p>四种，分别是强引用、软引用、弱引用和虚引用。
<img decoding="async" loading="lazy" alt="1757510370625" src="/assets/images/1757510370625-3089c91a1d7ed3fda420544ffedd50f5.png" width="780" height="551" class="img_ev3q">
强引用是 Java 中最常见的引用类型。使用 new 关键字赋值的引用就是强引用，只要强引用关联着对象，垃圾收集器就不会回收这部分对象，即使内存不足。
// str 就是一个强引用
String str = new String(&quot;沉默王二&quot;);</p>
<p>软引用于描述一些非必须对象，通过 SoftReference 类实现。软引用的对象在内存不足时会被回收。</p>
<p>// softRef 就是一个软引用</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">SoftReference&lt;String&gt; softRef = new SoftReference&lt;&gt;(new String(&quot;沉默王二&quot;));</span><br></span></code></pre></div></div>
<p>弱引用用于描述一些短生命周期的非必须对象，如 ThreadLocal 中的 Entry，就是通过 WeakReference 类实现的。弱引用的对象会在下一次垃圾回收时会被回收，不论内存是否充足。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /** The value associated with this ThreadLocal. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Object value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //节点类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Entry(ThreadLocal&lt;?&gt; k, Object v) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //key赋值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super(k);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //value赋值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        value = v;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>虚引用主要用来跟踪对象被垃圾回收的过程，通过 PhantomReference 类实现。虚引用的对象在任何时候都可能被回收。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// phantomRef 就是一个虚引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">PhantomReference&lt;String&gt; phantomRef = new PhantomReference&lt;&gt;(new String(&quot;沉默王二&quot;), new ReferenceQueue&lt;&gt;());</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="java-堆的内存分区了解吗">Java 堆的内存分区了解吗？<a href="#java-堆的内存分区了解吗" class="hash-link" aria-label="Direct link to Java 堆的内存分区了解吗？" title="Direct link to Java 堆的内存分区了解吗？">​</a></h3>
<p>了解。Java 堆被划分为新生代和老年代两个区域。<br>
<img decoding="async" loading="lazy" alt="1757510438157" src="/assets/images/1757510438157-45ad872f21ed983de591e77555e20ad2.png" width="919" height="307" class="img_ev3q">
新生代又被划分为 Eden 空间和两个 Survivor 空间（From 和 To）。</p>
<p>新创建的对象会被分配到 Eden 空间。当 Eden 区填满时，会触发一次 Minor GC，清除不再使用的对象。存活下来的对象会从 Eden 区移动到 Survivor 区。</p>
<p>对象在新生代中经历多次 GC 后，如果仍然存活，会被移动到老年代。当老年代内存不足时，会触发 Major GC，对整个堆进行垃圾回收。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说一下新生代的区域划分">说一下新生代的区域划分？<a href="#说一下新生代的区域划分" class="hash-link" aria-label="Direct link to 说一下新生代的区域划分？" title="Direct link to 说一下新生代的区域划分？">​</a></h3>
<p>新生代的垃圾收集主要采用标记-复制算法，因为新生代的存活对象比较少，每次复制少量的存活对象效率比较高。</p>
<p>基于这种算法，虚拟机将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次分配内存只使用 Eden 和其中一块 Survivor。发生垃圾收集时，将 Eden 和 Survivor 中仍然存活的对象一次性复制到另外一块 Survivor 空间上，然后直接清理掉 Eden 和已用过的那块 Survivor 空间。默认 Eden 和 Survivor 的大小比例是 8∶1。
<img decoding="async" loading="lazy" alt="1757510470387" src="/assets/images/1757510470387-df9f965c0a51195439ee6a9eb1e5d9e7.png" width="622" height="294" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="对象什么时候会进入老年代">🌟对象什么时候会进入老年代<a href="#对象什么时候会进入老年代" class="hash-link" aria-label="Direct link to 🌟对象什么时候会进入老年代" title="Direct link to 🌟对象什么时候会进入老年代">​</a></h3>
<p>对象通常会在年轻代中分配，随着时间的推移和垃圾收集的进程，某些满足条件的对象会进入到老年代中，如长期存活的对象。
<img decoding="async" loading="lazy" alt="1757510486144" src="/assets/images/1757510486144-d266d3c13f152e8902713130aa15a2a9.png" width="912" height="340" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="长期存活的对象如何判断">长期存活的对象如何判断？<a href="#长期存活的对象如何判断" class="hash-link" aria-label="Direct link to 长期存活的对象如何判断？" title="Direct link to 长期存活的对象如何判断？">​</a></h3>
<p>JVM 会为对象维护一个“年龄”计数器，记录对象在新生代中经历 Minor GC 的次数。每次 GC 未被回收的对象，其年龄会加 1。</p>
<p>当超过一个特定阈值，默认值是 15，就会被认为老对象了，需要重点关照。这个年龄阈值可以通过 JVM 参数-XX<!-- -->:MaxTenuringThreshold<!-- -->来设置。</p>
<p>可以通过</p>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">jinfo -flag MaxTenuringThreshold $(jps | grep -i nacos | awk &#x27;{print $1}&#x27;)</span><br></span></code></pre></div></div>
<p>来查看当前 JVM 的年龄阈值。</p>
<p>二哥的 Java 进阶之路：年龄阈值
如果应用中的对象存活时间较短，可以适当调大这个值，让对象在新生代多待一会儿
如果对象存活时间较长，可以适当调小这个值，让对象更快进入老年代，减少在新生代的复制次数</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="大对象如何判断">大对象如何判断？<a href="#大对象如何判断" class="hash-link" aria-label="Direct link to 大对象如何判断？" title="Direct link to 大对象如何判断？">​</a></h3>
<p>大对象是指占用内存较大的对象，如大数组、长字符串等。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int[] array = new int[1000000];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String str = new String(new char[1000000]);</span><br></span></code></pre></div></div>
<p>其大小由 JVM 参数 -XX<!-- -->:PretenureSizeThreshold<!-- --> 控制，但在 JDK 8 中，默认值为 0，也就是说默认情况下，对象仅根据 GC 存活的次数来判断是否进入老年代。</p>
<p>G1 垃圾收集器中，大对象会直接分配到 HUMONGOUS 区域。当对象大小超过一个 Region 容量的 50% 时，会被认为是大对象。
<img decoding="async" loading="lazy" alt="1757510541574" src="/assets/images/1757510541574-2d1793eb56e1851e40ec4c74fbaa9fac.png" width="1386" height="570" class="img_ev3q">
Region 的大小可以通过 JVM 参数 -XX<!-- -->:G1HeapRegionSize<!-- --> 来设置，默认情况下从 1MB 到 32MB 不等，会根据堆内存大小动态调整。</p>
<p>可以通过 java -XX:+UseG1GC -XX:+PrintGCDetails -version 查看 G1 垃圾收集器的相关信息
从结果上来看，我本机上 G1 的堆大小为 2GB，Region 的大小为 4MB。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="动态年龄判定了解吗">动态年龄判定了解吗？<a href="#动态年龄判定了解吗" class="hash-link" aria-label="Direct link to 动态年龄判定了解吗？" title="Direct link to 动态年龄判定了解吗？">​</a></h3>
<p>如果 Survivor 区中所有对象的总大小超过了一定比例，通常是 Survivor 区的一半，那么年龄较小的对象也可能会被提前晋升到老年代。</p>
<p>这是因为如果年龄较小的对象在 Survivor 区中占用了较大的空间，会导致 Survivor 区中的对象复制次数增多，影响垃圾回收的效率。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="stw-了解吗">STW 了解吗？<a href="#stw-了解吗" class="hash-link" aria-label="Direct link to STW 了解吗？" title="Direct link to STW 了解吗？">​</a></h3>
<p>了解。</p>
<p>JVM 进行垃圾回收的过程中，会涉及到对象的移动，为了保证对象引用在移动过程中不被修改，必须暂停所有的用户线程，像这样的停顿，我们称之为Stop The World。简称 STW。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何暂停线程呢">如何暂停线程呢？<a href="#如何暂停线程呢" class="hash-link" aria-label="Direct link to 如何暂停线程呢？" title="Direct link to 如何暂停线程呢？">​</a></h3>
<p>JVM 会使用一个名为安全点（Safe Point）的机制来确保线程能够被安全地暂停，其过程包括四个步骤：</p>
<p>JVM 发出暂停信号；
线程执行到安全点后，挂起自身并等待垃圾收集完成；
垃圾回收器完成 GC 操作；
线程恢复执行。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是安全点">什么是安全点？<a href="#什么是安全点" class="hash-link" aria-label="Direct link to 什么是安全点？" title="Direct link to 什么是安全点？">​</a></h3>
<p>安全点是 JVM 的一种机制，常用于垃圾回收的 STW 操作，用于让线程在执行到某些特定位置时，可以被安全地暂停。</p>
<p>通常位于方法调用、循环跳转、异常处理等位置，以保证线程暂停时数据的一致性。</p>
<p>用个通俗的比喻，老王去拉车，车上的东西很重，老王累的汗流浃背，但是老王不能在上坡或者下坡时休息，只能在平地上停下来擦擦汗，喝口水。
推荐大家看看这个HotSpot JVM Deep Dive - Safepoint，对 safe point 有一个比较深入地解释。
<img decoding="async" loading="lazy" alt="1757510613888" src="/assets/images/1757510613888-952389d94c92d6e584c4078911c83dbc.png" width="1754" height="1084" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="对象一定分配在堆中吗">对象一定分配在堆中吗？<a href="#对象一定分配在堆中吗" class="hash-link" aria-label="Direct link to 对象一定分配在堆中吗？" title="Direct link to 对象一定分配在堆中吗？">​</a></h3>
<p>不一定。</p>
<p>默认情况下，Java 对象是在堆中分配的，但 JVM 会进行逃逸分析，来判断对象的生命周期是否只在方法内部，如果是的话，这个对象可以在栈上分配。</p>
<p>举例来说，下面的代码中，对象 new Person() 的生命周期只在 testStackAllocation 方法内部，因此 JVM 会将这个对象分配在栈上。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public void testStackAllocation() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Person p = new Person();  // 对象可能分配在栈上</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    p.name = &quot;沉默王二是只狗&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    p.age = 18;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(p.name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是逃逸分析">什么是逃逸分析？<a href="#什么是逃逸分析" class="hash-link" aria-label="Direct link to 什么是逃逸分析？" title="Direct link to 什么是逃逸分析？">​</a></h3>
<p>逃逸分析是一种 JVM 优化技术，用来分析对象的作用域和生命周期，判断对象是否逃逸出方法或线程。</p>
<p>可以通过分析对象的引用流向，判断对象是否被方法返回、赋值到全局变量、传递到其他线程等，来确定对象是否逃逸。</p>
<p>如果对象没有逃逸，就可以进行栈上分配、同步消除、标量替换等优化，以提高程序的性能。</p>
<p>可以通过 java -XX:+PrintFlagsFinal -version | grep DoEscapeAnalysis 来确认 JVM 是否开启了逃逸分析。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="逃逸具体是指什么">逃逸具体是指什么？<a href="#逃逸具体是指什么" class="hash-link" aria-label="Direct link to 逃逸具体是指什么？" title="Direct link to 逃逸具体是指什么？">​</a></h3>
<p>根据对象逃逸的范围，可以分为方法逃逸和线程逃逸。</p>
<p>当对象被方法外部的代码引用，生命周期超出了方法的范围，那么对象就必须分配在堆中，由垃圾收集器管理。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public Person createPerson() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new Person(); // 对象逃逸出方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>比如说 new Person() 创建的对象被返回，那么这个对象就逃逸出当前方法了。
<img decoding="async" loading="lazy" alt="1757510672206" src="/assets/images/1757510672206-52d09f5f9968d74702f6c009d77bf652.png" width="934" height="784" class="img_ev3q">
再比如说，对象被另外一个线程引用，生命周期超出了当前线程，那么对象就必须分配在堆中，并且线程之间需要同步。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public void threadEscapeExample() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Person p = new Person(); // 对象逃逸到另一个线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    new Thread(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(p);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }).start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>对象 new Person() 被另外一个线程引用了，发生了线程逃逸。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="逃逸分析会带来什么好处">逃逸分析会带来什么好处？<a href="#逃逸分析会带来什么好处" class="hash-link" aria-label="Direct link to 逃逸分析会带来什么好处？" title="Direct link to 逃逸分析会带来什么好处？">​</a></h3>
<p>主要有三个。</p>
<p>第一，如果确定一个对象不会逃逸，那么就可以考虑栈上分配，对象占用的内存随着栈帧出栈后销毁，这样一来，垃圾收集的压力就降低很多。</p>
<p>第二，线程同步需要加锁，加锁就要占用系统资源，如果逃逸分析能够确定一个对象不会逃逸出线程，那么这个对象就不用加锁，从而减少线程同步的开销。</p>
<p>第三，如果对象的字段在方法中独立使用，JVM 可以将对象分解为标量变量，避免对象分配。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public void scalarReplacementExample() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Point p = new Point(1, 2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(p.getX() + p.getY());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>如果 Point 对象未逃逸，JVM 可以优化为：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int x = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int y = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(x + y);</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="内存溢出和内存泄漏了解吗">内存溢出和内存泄漏了解吗？<a href="#内存溢出和内存泄漏了解吗" class="hash-link" aria-label="Direct link to 内存溢出和内存泄漏了解吗？" title="Direct link to 内存溢出和内存泄漏了解吗？">​</a></h3>
<p>内存溢出，俗称 OOM，是指当程序请求分配内存时，由于没有足够的内存空间，从而抛出 OutOfMemoryError。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    list.add(&quot;OutOfMemory&quot;.repeat(1000)); // 无限增加内存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>可能是因为堆、元空间、栈或直接内存不足导致的。可以通过优化内存配置、减少对象分配来解决。</p>
<p>内存泄漏是指程序在使用完内存后，未能及时释放，导致占用的内存无法再被使用。随着时间的推移，内存泄漏会导致可用内存逐渐减少，最终导致内存溢出。</p>
<p>内存泄漏通常是因为长期存活的对象持有短期存活对象的引用，又没有及时释放，从而导致短期存活对象无法被回收而导致的。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class MemoryLeakExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static List&lt;Object&gt; staticList = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void addObject() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        staticList.add(new Object()); // 对象不会被回收</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>用一个比较有味道的比喻来形容就是，内存溢出是排队去蹲坑，发现没坑了；内存泄漏，就是有人占着茅坑不拉屎，导致坑位不够用。
<img decoding="async" loading="lazy" alt="1757510788941" src="/assets/images/1757510788941-713b9d6cc90776cf12f789f97accb167.png" width="1222" height="419" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="能手写内存溢出的例子吗">能手写内存溢出的例子吗？<a href="#能手写内存溢出的例子吗" class="hash-link" aria-label="Direct link to 能手写内存溢出的例子吗？" title="Direct link to 能手写内存溢出的例子吗？">​</a></h3>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="内存泄漏可能由哪些原因导致呢">内存泄漏可能由哪些原因导致呢？<a href="#内存泄漏可能由哪些原因导致呢" class="hash-link" aria-label="Direct link to 内存泄漏可能由哪些原因导致呢？" title="Direct link to 内存泄漏可能由哪些原因导致呢？">​</a></h3>
<p>比如说：</p>
<p>①、静态的集合中添加的对象越来越多，但却没有及时清理；静态变量的生命周期与应用程序相同，如果静态变量持有对象的引用，这些对象将无法被 GC 回收。
②、单例模式下对象持有的外部引用无法及时释放；单例对象在整个应用程序的生命周期中存活，如果单例对象持有其他对象的引用，这些对象将无法被回收。
③、数据库、IO、Socket 等连接资源没有及时关闭；
④、 ThreadLocal 的引用未被清理，线程退出后仍然持有对象引用；在线程执行完后，要调用 ThreadLocal 的 remove 方法进行清理。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="有没有处理过内存泄漏问题">有没有处理过内存泄漏问题？<a href="#有没有处理过内存泄漏问题" class="hash-link" aria-label="Direct link to 有没有处理过内存泄漏问题？" title="Direct link to 有没有处理过内存泄漏问题？">​</a></h3>
<p>推荐阅读：</p>
<p>一次内存溢出的排查优化实战
JVM 性能监控工具之命令行篇
JVM 性能监控工具之可视化篇
有。</p>
<p>当时在做技术派项目的时候，由于 ThreadLocal 没有及时清理导致出现了内存泄漏问题。</p>
<p>我用可视化的监控工具 VisualVM，配合 JDK 自带的 jstack 等命令行工具进行了排查。</p>
<p>大致的过程我回想了一下，主要有 7 个步骤：</p>
<p>第一步，使用 jps -l 查看运行的 Java 进程 ID。
第二步，使用top -p [pid] 查看进程使用 CPU 和内存占用情况。
第三步，使用 top -Hp [pid] 查看进程下的所有线程占用 CPU 和内存情况。
第四步，抓取线程栈：jstack -F 29452 &gt; 29452.txt，可以多抓几次做个对比。
看看有没有线程死锁、死循环或长时间等待这些问题。</p>
<p>第五步，可以使用jstat -gcutil [pid] 5000 10 每隔 5 秒输出 GC 信息，输出 10 次，查看 YGC 和 Full GC 次数。</p>
<p>通常会出现 YGC 不增加或增加缓慢，而 Full GC 增加很快。
或使用 jmap -heap [pid] 查看堆的摘要信息，关注老年代内存使用是否达到阀值，若达到阀值就会执行 Full GC。
如果发现 Full GC 次数太多，就很大概率存在内存泄漏了。</p>
<p>第六步，生成 dump 文件，然后借助可视化工具分析哪个对象非常多，基本就能定位到问题根源了。</p>
<p>执行命令 jmap -dump<!-- -->:format<!-- -->=b,file=heap.hprof 10025 会输出进程 10025 的堆快照信息，保存到文件 heap.hprof 中。
第七步，使用图形化工具分析，如 JDK 自带的 VisualVM，从菜单 &gt; 文件 &gt; 装入 dump 文件。
然后在结果观察内存占用最多的对象，找到内存泄漏的源头。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="有没有处理过内存溢出问题">有没有处理过内存溢出问题？<a href="#有没有处理过内存溢出问题" class="hash-link" aria-label="Direct link to 有没有处理过内存溢出问题？" title="Direct link to 有没有处理过内存溢出问题？">​</a></h3>
<p>有。</p>
<p>当时在做技术派的时候，由于上传的文件过大，没有正确处理，导致一下子撑爆了内存，程序直接崩溃了。</p>
<p>我记得是通过导出堆转储文件进行分析发现的。</p>
<p>第一步，使用 jmap 命令手动生成 Heap Dump 文件：</p>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">jmap -dump:format=b,file=heap.hprof &lt;pid&gt;</span><br></span></code></pre></div></div>
<p>然后使用 MAT、JProfiler 等工具进行分析，查看内存中的对象占用情况。</p>
<p>一般来说：
如果生产环境的内存还有很多空余，可以适当增大堆内存大小来解决，例如 -Xmx4g 参数。</p>
<p>或者检查代码中是否存在内存泄漏，如未关闭的资源、长生命周期的对象等。</p>
<p>之后，在本地进行压力测试，模拟高负载情况下的内存表现，确保修改有效，且没有引入新的问题</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么情况下会发生栈溢出补充">什么情况下会发生栈溢出？（补充）<a href="#什么情况下会发生栈溢出补充" class="hash-link" aria-label="Direct link to 什么情况下会发生栈溢出？（补充）" title="Direct link to 什么情况下会发生栈溢出？（补充）">​</a></h3>
<p>栈溢出发生在程序调用栈的深度超过 JVM 允许的最大深度时。</p>
<p>栈溢出的本质是因为线程的栈空间不足，导致无法再为新的栈帧分配内存。
<img decoding="async" loading="lazy" alt="1757511042605" src="/assets/images/1757511042605-d6a57ce9b9887ce85e0ddef00418e0a1.png" width="1144" height="716" class="img_ev3q">
当一个方法被调用时，JVM 会在栈中分配一个栈帧，用于存储该方法的执行信息。如果方法调用嵌套太深，栈帧不断压入栈中，最终会导致栈空间耗尽，抛出 StackOverflowError。</p>
<p>最常见的栈溢出场景就是递归调用，尤其是没有正确的终止条件下，会导致递归无限进行。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class StackOverflowExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void recursiveMethod() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 没有终止条件的递归调用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        recursiveMethod();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        recursiveMethod();  // 导致栈溢出</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>另外，如果方法中定义了特别大的局部变量，栈帧会变得很大，导致栈空间更容易耗尽。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class LargeLocalVariables {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void method() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[] largeArray = new int[1000000];  // 大量局部变量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        method();  // 递归调用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        method();  // 导致栈溢出</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="垃圾收集">垃圾收集<a href="#垃圾收集" class="hash-link" aria-label="Direct link to 垃圾收集" title="Direct link to 垃圾收集">​</a></h3>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="讲讲-jvm-的垃圾回收机制补充">🌟讲讲 JVM 的垃圾回收机制（补充）<a href="#讲讲-jvm-的垃圾回收机制补充" class="hash-link" aria-label="Direct link to 🌟讲讲 JVM 的垃圾回收机制（补充）" title="Direct link to 🌟讲讲 JVM 的垃圾回收机制（补充）">​</a></h3>
<p>垃圾回收就是对内存堆中已经死亡的或者长时间没有使用的对象进行清除或回收。</p>
<p>JVM 在做 GC 之前，会先搞清楚什么是垃圾，什么不是垃圾，通常会通过可达性分析算法来判断对象是否存活。
<img decoding="async" loading="lazy" alt="1757511107188" src="/assets/images/1757511107188-7dcd5dd82404940a0a04483986d3695e.png" width="1558" height="1018" class="img_ev3q">
在确定了哪些垃圾可以被回收后，垃圾收集器（如 CMS、G1、ZGC）要做的事情就是进行垃圾回收，可以采用标记清除算法、复制算法、标记整理算法、分代收集算法等。</p>
<p>技术派项目使用的 JDK 8，采用的是 CMS 垃圾收集器。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">java -XX:+UseConcMarkSweepGC \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     -XX:+UseParNewGC \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     -XX:CMSInitiatingOccupancyFraction=75 \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     -XX:+UseCMSInitiatingOccupancyOnly \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     -jar your-application.jar</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="垃圾回收的过程是什么">垃圾回收的过程是什么？<a href="#垃圾回收的过程是什么" class="hash-link" aria-label="Direct link to 垃圾回收的过程是什么？" title="Direct link to 垃圾回收的过程是什么？">​</a></h3>
<p>Java 的垃圾回收过程主要分为标记存活对象、清除无用对象、以及内存压缩/整理三个阶段。不同的垃圾回收器在执行这些步骤时会采用不同的策略和算法。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何判断对象仍然存活">🌟如何判断对象仍然存活？<a href="#如何判断对象仍然存活" class="hash-link" aria-label="Direct link to 🌟如何判断对象仍然存活？" title="Direct link to 🌟如何判断对象仍然存活？">​</a></h3>
<p>Java 通过可达性分析算法来判断一个对象是否还存活。</p>
<p>通过一组名为 “GC Roots” 的根对象，进行递归扫描，无法从根对象到达的对象就是“垃圾”，可以被回收。
<img decoding="async" loading="lazy" alt="1757511186046" src="/assets/images/1757511186046-8d179d195a7830de457a087869fc9499.png" width="792" height="533" class="img_ev3q">
这也是 G1、CMS 等主流垃圾收集器使用的主要算法。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是引用计数法">什么是引用计数法？<a href="#什么是引用计数法" class="hash-link" aria-label="Direct link to 什么是引用计数法？" title="Direct link to 什么是引用计数法？">​</a></h3>
<p>每个对象有一个引用计数器，记录引用它的次数。当计数器为零时，对象可以被回收。
<img decoding="async" loading="lazy" alt="1757511204294" src="/assets/images/1757511204294-40615d91d912f2e36129824e4a1ca0d5.png" width="663" height="258" class="img_ev3q">
引用计数法无法解决循环引用的问题。例如，两个对象互相引用，但不再被其他对象引用，它们的引用计数都不为零，因此不会被回收。</p>
<p>做可达性分析的时候，应该有哪些前置性的操作？
在进行垃圾回收之前，JVM 会暂停所有正在执行的应用线程。</p>
<p>这是因为可达性分析过程必须确保在执行分析时，内存中的对象关系不会被应用线程修改。如果不暂停应用线程，可能会出现对象引用的改变，导致垃圾回收过程中判断对象是否可达的结果不一致，从而引发严重的内存错误或数据丢失。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="java-中可作为-gc-roots-的引用有哪几种">Java 中可作为 GC Roots 的引用有哪几种？<a href="#java-中可作为-gc-roots-的引用有哪几种" class="hash-link" aria-label="Direct link to Java 中可作为 GC Roots 的引用有哪几种？" title="Direct link to Java 中可作为 GC Roots 的引用有哪几种？">​</a></h3>
<p>推荐阅读：深入理解垃圾回收机制
推荐阅读：R 大的所谓“GC roots”
所谓的 GC Roots，就是一组必须活跃的引用，它们是程序运行时的起点，是一切引用链的源头。在 Java 中，GC Roots 包括以下几种：</p>
<p>虚拟机栈中的引用（方法的参数、局部变量等）
本地方法栈中 JNI 的引用
类静态变量
运行时常量池中的常量（String 或 Class 类型）
<img decoding="async" loading="lazy" alt="1757511229151" src="/assets/images/1757511229151-50e43caa08712db3c6158e4db681829f.png" width="1232" height="676" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说虚拟机栈中的引用">说说虚拟机栈中的引用？<a href="#说说虚拟机栈中的引用" class="hash-link" aria-label="Direct link to 说说虚拟机栈中的引用？" title="Direct link to 说说虚拟机栈中的引用？">​</a></h3>
<p>来看下面这段代码：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class StackReference {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void greet() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object localVar = new Object(); // 这里的 localVar 是一个局部变量，存在于虚拟机栈中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(localVar.toString());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new StackReference().greet();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>在 greet 方法中，localVar 是一个局部变量，存在于虚拟机栈中，可以被认为是 GC Roots。</p>
<p>在 greet 方法执行期间，localVar 引用的对象是活跃的，因为它是从 GC Roots 可达的。</p>
<p>当 greet 方法执行完毕后，localVar 的作用域结束，localVar 引用的 Object 对象不再由任何 GC Roots 引用（假设没有其他引用指向这个对象），因此它将有资格作为垃圾被回收掉 😁。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说本地方法栈中-jni-的引用">说说本地方法栈中 JNI 的引用？<a href="#说说本地方法栈中-jni-的引用" class="hash-link" aria-label="Direct link to 说说本地方法栈中 JNI 的引用？" title="Direct link to 说说本地方法栈中 JNI 的引用？">​</a></h3>
<p>Java 通过 JNI 提供了一种机制，允许 Java 代码调用本地代码（通常是 C 或 C++ 编写的代码）。</p>
<p>当调用 Java 方法时，虚拟机会创建一个栈帧并压入虚拟机栈，而当它调用本地方法时，虚拟机会通过动态链接直接调用指定的本地方法。
<img decoding="async" loading="lazy" alt="1757513440047" src="/assets/images/1757513440047-fff7caf9978e2167fd22ba643fc98d61.png" width="486" height="442" class="img_ev3q">
JNI 引用是在 Java 本地接口代码中创建的引用，这些引用可以指向 Java 堆中的对象。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 假设的JNI方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public native void nativeMethod();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 假设在C/C++中实现的本地方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Class:     NativeExample</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Method:    nativeMethod</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Signature: ()V</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">JNIEXPORT void JNICALL Java_NativeExample_nativeMethod(JNIEnv *env, jobject thisObj) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    jobject localRef = (*env)-&gt;NewObject(env, ...); // 在本地方法栈中创建JNI引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // localRef 引用的Java对象在本地方法执行期间是活跃的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>在本地代码中，localRef 是对 Java 对象的一个 JNI 引用，它在本地方法执行期间保持 Java 对象活跃，可以被认为是 GC Roots。</p>
<p>一旦 JNI 方法执行完毕，除非这个引用是全局的，否则它指向的对象将会被作为垃圾回收掉（假设没有其他地方再引用这个对象）。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说类静态变量">说说类静态变量？<a href="#说说类静态变量" class="hash-link" aria-label="Direct link to 说说类静态变量？" title="Direct link to 说说类静态变量？">​</a></h3>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class StaticFieldReference {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static Object staticVar = new Object(); // 类静态变量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(staticVar.toString());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>StaticFieldReference 类中的 staticVar 引用了一个 Object 对象，这个引用存储在元空间，可以被认为是 GC Roots。</p>
<p>只要 StaticFieldReference 类未被卸载，staticVar 引用的对象都不会被垃圾回收。如果 StaticFieldReference 类被卸载（这通常发生在其类加载器被垃圾回收时），那么 staticVar 引用的对象也将有资格被垃圾回收（如果没有其他引用指向这个对象）。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说运行时常量池中的常量">说说运行时常量池中的常量？<a href="#说说运行时常量池中的常量" class="hash-link" aria-label="Direct link to 说说运行时常量池中的常量？" title="Direct link to 说说运行时常量池中的常量？">​</a></h3>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class ConstantPoolReference {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static final String CONSTANT_STRING = &quot;Hello, World&quot;; // 常量，存在于运行时常量池中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static final Class&lt;?&gt; CONSTANT_CLASS = Object.class; // 类类型常量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(CONSTANT_STRING);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(CONSTANT_CLASS.getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>在 ConstantPoolReference 中，CONSTANT_STRING 和 CONSTANT_CLASS 作为常量存储在运行时常量池。它们可以用来作为 GC Roots。</p>
<p>这些常量引用的对象（字符串&quot;Hello, World&quot;和 Object.class 类对象）在常量池中，只要包含这些常量的 ConstantPoolReference 类未被卸载，这些对象就不会被垃圾回收。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="finalize方法了解吗">finalize()方法了解吗？<a href="#finalize方法了解吗" class="hash-link" aria-label="Direct link to finalize()方法了解吗？" title="Direct link to finalize()方法了解吗？">​</a></h3>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="垃圾收集算法了解吗">🌟垃圾收集算法了解吗？<a href="#垃圾收集算法了解吗" class="hash-link" aria-label="Direct link to 🌟垃圾收集算法了解吗？" title="Direct link to 🌟垃圾收集算法了解吗？">​</a></h3>
<p>垃圾收集算法主要有三种，分别是标记-清除算法、标记-复制算法和标记-整理算法。</p>
<p>说说标记-清除算法？
标记-清除算法分为两个阶段：</p>
<p>标记：标记所有需要回收的对象
清除：回收所有被标记的对象
<img decoding="async" loading="lazy" alt="1757513616360" src="/assets/images/1757513616360-a363e6795b2a46b7d73ec160b8b4d861.png" width="994" height="551" class="img_ev3q">
优点是实现简单，缺点是回收过程中会产生内存碎片。</p>
<p>说说标记-复制算法？
标记-复制算法可以解决标记-清除算法的内存碎片问题，因为它将内存空间划分为两块，每次只使用其中一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后清理掉这一块。
<img decoding="async" loading="lazy" alt="1757513690860" src="/assets/images/1757513690860-114a631b577576ac13edd60337f0a27d.png" width="992" height="560" class="img_ev3q">
缺点是浪费了一半的内存空间。</p>
<p>说说标记-整理算法？
标记-整理算法是标记-清除复制算法的升级版，它不再划分内存空间，而是将存活的对象向内存的一端移动，然后清理边界以外的内存。
<img decoding="async" loading="lazy" alt="1757513714945" src="/assets/images/1757513714945-114a5a23f45b3c01a29f7f83603720dc.png" width="965" height="578" class="img_ev3q">
缺点是移动对象的成本比较高。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说分代收集算法">说说分代收集算法？<a href="#说说分代收集算法" class="hash-link" aria-label="Direct link to 说说分代收集算法？" title="Direct link to 说说分代收集算法？">​</a></h3>
<p>分代收集算法是目前主流的垃圾收集算法，它根据对象存活周期的不同将内存划分为几块，一般分为新生代和老年代。</p>
<p>新生代用复制算法，因为大部分对象生命周期短。老年代用标记-整理算法，因为对象存活率较高。
<img decoding="async" loading="lazy" alt="1757513767477" src="/assets/images/1757513767477-f25ffac0c79ce639a66dc6c44c68a7cd.png" width="814" height="324" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么要用分代收集呢">为什么要用分代收集呢？<a href="#为什么要用分代收集呢" class="hash-link" aria-label="Direct link to 为什么要用分代收集呢？" title="Direct link to 为什么要用分代收集呢？">​</a></h3>
<p>分代收集算法的核心思想是根据对象的生命周期优化垃圾回收。</p>
<p>新生代的对象生命周期短，使用复制算法可以快速回收。老年代的对象生命周期长，使用标记-整理算法可以减少移动对象的成本。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="标记复制的标记过程和复制过程会不会停顿">标记复制的标记过程和复制过程会不会停顿？<a href="#标记复制的标记过程和复制过程会不会停顿" class="hash-link" aria-label="Direct link to 标记复制的标记过程和复制过程会不会停顿？" title="Direct link to 标记复制的标记过程和复制过程会不会停顿？">​</a></h3>
<p>在标记-复制算法 中，标记阶段和复制阶段都会触发STW。</p>
<p>标记阶段停顿是为了保证对象的引用关系不被修改。
复制阶段停顿是防止对象在复制过程中被修改。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="minor-gcmajor-gcmixed-gcfull-gc-都是什么意思">Minor GC、Major GC、Mixed GC、Full GC 都是什么意思？<a href="#minor-gcmajor-gcmixed-gcfull-gc-都是什么意思" class="hash-link" aria-label="Direct link to Minor GC、Major GC、Mixed GC、Full GC 都是什么意思？" title="Direct link to Minor GC、Major GC、Mixed GC、Full GC 都是什么意思？">​</a></h3>
<p>Minor GC 也称为 Young GC，是指发生在年轻代的垃圾收集。年轻代包含 Eden 区以及两个 Survivor 区。
<img decoding="async" loading="lazy" alt="1757515315544" src="/assets/images/1757515315544-f25ffac0c79ce639a66dc6c44c68a7cd.png" width="814" height="324" class="img_ev3q">
Major GC 也称为 Old GC，主要指的是发生在老年代的垃圾收集。是 CMS 的特有行为。</p>
<p>Mixed GC 是 G1 垃圾收集器特有的一种 GC 类型，它在一次 GC 中同时清理年轻代和部分老年代。</p>
<p>Full GC 是最彻底的垃圾收集，涉及整个 Java 堆和方法区。它是最耗时的 GC，通常在 JVM 压力很大时发生。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="full-gc怎么去清理的">FULL gc怎么去清理的？<a href="#full-gc怎么去清理的" class="hash-link" aria-label="Direct link to FULL gc怎么去清理的？" title="Direct link to FULL gc怎么去清理的？">​</a></h3>
<p>Full GC 会从 GC Root 出发，标记所有可达对象。新生代使用复制算法，清空 Eden 区。老年代使用标记-整理算法，回收对象并消除碎片。</p>
<p>停顿时间较长，会影响系统响应性能。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="young-gc-什么时候触发">Young GC 什么时候触发？<a href="#young-gc-什么时候触发" class="hash-link" aria-label="Direct link to Young GC 什么时候触发？" title="Direct link to Young GC 什么时候触发？">​</a></h3>
<p>如果 Eden 区没有足够的空间时，就会触发 Young GC 来清理新生代。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么时候会触发-full-gc">什么时候会触发 Full GC？<a href="#什么时候会触发-full-gc" class="hash-link" aria-label="Direct link to 什么时候会触发 Full GC？" title="Direct link to 什么时候会触发 Full GC？">​</a></h3>
<p>在进行 Young GC 的时候，如果发现老年代可用的连续内存空间 &lt; 新生代历次 Young GC 后升入老年代的对象总和的平均大小，说明本次 Young GC 后升入老年代的对象大小，可能超过了老年代当前可用的内存空间，就会触发 Full GC。</p>
<p>执行 Young GC 后老年代没有足够的内存空间存放转入的对象，会立即触发一次 Full GC。</p>
<p>System.gc()、jmap -dump 等命令会触发 full gc。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="空间分配担保是什么">空间分配担保是什么？<a href="#空间分配担保是什么" class="hash-link" aria-label="Direct link to 空间分配担保是什么？" title="Direct link to 空间分配担保是什么？">​</a></h3>
<p>空间分配担保是指在进行 Minor GC 前，JVM 会确保老年代有足够的空间存放从新生代晋升的对象。如果老年代空间不足，可能会触发 Full GC。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="知道哪些垃圾收集器">🌟知道哪些垃圾收集器？<a href="#知道哪些垃圾收集器" class="hash-link" aria-label="Direct link to 🌟知道哪些垃圾收集器？" title="Direct link to 🌟知道哪些垃圾收集器？">​</a></h3>
<p>推荐阅读：深入理解 JVM 的垃圾收集器：CMS、G1、ZGC
JVM 的垃圾收集器主要分为两大类：分代收集器和分区收集器，分代收集器的代表是 CMS，分区收集器的代表是 G1 和 ZGC。
<img decoding="async" loading="lazy" alt="1757515385339" src="/assets/images/1757515385339-731540f35e0b34b9d4cd090f6b5dc488.png" width="897" height="509" class="img_ev3q">
CMS 是第一个关注 GC 停顿时间的垃圾收集器，JDK 1.5 时引入，JDK9 被标记弃用，JDK14 被移除。</p>
<p>G1 在 JDK 1.7 时引入，在 JDK 9 时取代 CMS 成为了默认的垃圾收集器。</p>
<p>ZGC 是 JDK11 推出的一款低延迟垃圾收集器，适用于大内存低延迟服务的内存管理和回收，在 128G 的大堆下，最大停顿时间才 1.68 ms，性能远胜于 G1 和 CMS。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说-serial-收集器">说说 Serial 收集器？<a href="#说说-serial-收集器" class="hash-link" aria-label="Direct link to 说说 Serial 收集器？" title="Direct link to 说说 Serial 收集器？">​</a></h3>
<p>Serial 收集器是最基础、历史最悠久的收集器。</p>
<p>如同它的名字（串行），它是一个单线程工作的收集器，使用一个处理器或一条收集线程去完成垃圾收集工作。并且进行垃圾收集时，必须暂停其他所有工作线程，直到垃圾收集结束——这就是所谓的“Stop The World”。</p>
<p>Serial/Serial Old 收集器的运行过程如图：
<img decoding="async" loading="lazy" alt="1757546321347" src="/assets/images/1757546321347-f6d45cfa781c57acb6b35dc80b7f53a4.png" width="911" height="385" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说-parnew-收集器">说说 ParNew 收集器？<a href="#说说-parnew-收集器" class="hash-link" aria-label="Direct link to 说说 ParNew 收集器？" title="Direct link to 说说 ParNew 收集器？">​</a></h3>
<p>ParNew 收集器实质上是 Serial 收集器的多线程并行版本，使用多条线程进行垃圾收集。</p>
<p>ParNew/Serial Old 收集器运行示意图如下：
<img decoding="async" loading="lazy" alt="1757546352343" src="/assets/images/1757546352343-7210ffbb59edf577c27dd1f3580df261.png" width="899" height="394" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说-parallel-scavenge-收集器">说说 Parallel Scavenge 收集器？<a href="#说说-parallel-scavenge-收集器" class="hash-link" aria-label="Direct link to 说说 Parallel Scavenge 收集器？" title="Direct link to 说说 Parallel Scavenge 收集器？">​</a></h3>
<p>Parallel Scavenge 收集器是一款新生代收集器，基于标记-复制算法实现，也能够并行收集。和 ParNew 有些类似，但 Parallel Scavenge 主要关注的是垃圾收集的吞吐量——所谓吞吐量，就是 CPU 用于运行用户代码的时间和总消耗时间的比值，比值越大，说明垃圾收集的占比越小。
<img decoding="async" loading="lazy" alt="1757546384031" src="data:image/png;base64,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" width="674" height="207" class="img_ev3q"></p>
<p>根据对象存活周期的不同会将内存划分为几块，一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说-serial-old-收集器">说说 Serial Old 收集器？<a href="#说说-serial-old-收集器" class="hash-link" aria-label="Direct link to 说说 Serial Old 收集器？" title="Direct link to 说说 Serial Old 收集器？">​</a></h3>
<p>Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="说说-parallel-old-收集器">说说 Parallel Old 收集器？<a href="#说说-parallel-old-收集器" class="hash-link" aria-label="Direct link to 说说 Parallel Old 收集器？" title="Direct link to 说说 Parallel Old 收集器？">​</a></h4>
<p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本，基于标记-整理算法实现，使用多条 GC 线程在 STW 期间同时进行垃圾回收。
<img decoding="async" loading="lazy" alt="1757546424994" src="/assets/images/1757546424994-6293b22ce35e0df340b1939cf2b14648.png" width="904" height="405" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说-cms-收集器">说说 CMS 收集器？<a href="#说说-cms-收集器" class="hash-link" aria-label="Direct link to 说说 CMS 收集器？" title="Direct link to 说说 CMS 收集器？">​</a></h3>
<p>CMS 在 JDK 1.5 时引入，JDK 9 时被标记弃用，JDK 14 时被移除。</p>
<p>CMS 是一种低延迟的垃圾收集器，采用标记-清除算法，分为初始标记、并发标记、重新标记和并发清除四个阶段，优点是垃圾回收线程和应用线程同时运行，停顿时间短，适合延迟敏感的应用，但容易产生内存碎片，可能触发 Full GC。
<img decoding="async" loading="lazy" alt="1757546459157" src="/assets/images/1757546459157-6ea5cab07e90cbdcaf307e4098555334.png" width="1440" height="613" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说-g1-收集器">说说 G1 收集器？<a href="#说说-g1-收集器" class="hash-link" aria-label="Direct link to 说说 G1 收集器？" title="Direct link to 说说 G1 收集器？">​</a></h3>
<p>G1 在 JDK 1.7 时引入，在 JDK 9 时取代 CMS 成为默认的垃圾收集器。</p>
<p>G1 是一种面向大内存、高吞吐场景的垃圾收集器，它将堆划分为多个小的 Region，通过标记-整理算法，避免了内存碎片问题。优点是停顿时间可控，适合大堆场景，但调优较复杂。</p>
<p><img decoding="async" loading="lazy" alt="1757546490790" src="/assets/images/1757546490790-2d1793eb56e1851e40ec4c74fbaa9fac.png" width="1386" height="570" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说-zgc-收集器">说说 ZGC 收集器？<a href="#说说-zgc-收集器" class="hash-link" aria-label="Direct link to 说说 ZGC 收集器？" title="Direct link to 说说 ZGC 收集器？">​</a></h3>
<p>ZGC 是 JDK 11 时引入的一款低延迟的垃圾收集器，最大特点是将垃圾收集的停顿时间控制在 10ms 以内，即使在 TB 级别的堆内存下也能保持较低的停顿时间。</p>
<p>它通过并发标记和重定位来避免大部分 Stop-The-World 停顿，主要依赖指针染色来管理对象状态。
<img decoding="async" loading="lazy" alt="1757546521878" src="/assets/images/1757546521878-3b735575a599ae5295910cb1cd329632.png" width="2070" height="806" class="img_ev3q">
标记对象的可达性：通过在指针上增加标记位，不需要额外的标记位即可判断对象的存活状态。
重定位状态：在对象被移动时，可以通过指针染色来更新对象的引用，而不需要等待全局同步。
适用于需要超低延迟的场景，比如金融交易系统、电商平台。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="垃圾回收器的作用是什么">垃圾回收器的作用是什么？<a href="#垃圾回收器的作用是什么" class="hash-link" aria-label="Direct link to 垃圾回收器的作用是什么？" title="Direct link to 垃圾回收器的作用是什么？">​</a></h3>
<p>垃圾回收器的核心作用是自动管理 Java 应用程序的运行时内存。它负责识别哪些内存是不再被应用程序使用的，并释放这些内存以便重新使用。</p>
<p>这一过程减少了程序员手动管理内存的负担，降低了内存泄漏和溢出错误的风险。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="能详细说一下-cms-的垃圾收集过程吗">🌟能详细说一下 CMS 的垃圾收集过程吗？<a href="#能详细说一下-cms-的垃圾收集过程吗" class="hash-link" aria-label="Direct link to 🌟能详细说一下 CMS 的垃圾收集过程吗？" title="Direct link to 🌟能详细说一下 CMS 的垃圾收集过程吗？">​</a></h3>
<p><img decoding="async" loading="lazy" alt="1757546560210" src="/assets/images/1757546560210-de8c4417305140444bcd424a5dfc6407.png" width="1108" height="392" class="img_ev3q">
CMS 使用标记-清除算法进行垃圾收集，分 4 大步：</p>
<p>初始标记：标记所有从 GC Roots 直接可达的对象，这个阶段需要 STW，但速度很快。
并发标记：从初始标记的对象出发，遍历所有对象，标记所有可达的对象。这个阶段是并发进行的。
重新标记：完成剩余的标记工作，包括处理并发阶段遗留下来的少量变动，这个阶段通常需要短暂的 STW 停顿。
并发清除：清除未被标记的对象，回收它们占用的内存空间。
你提到了remark，那它remark具体是怎么执行的？三色标记法？
是的，remark 阶段通常会结合三色标记法来执行，确保在并发标记期间所有存活对象都被正确标记。目的是修正并发标记阶段中可能遗漏的对象引用变化。</p>
<p>在 remark 阶段，垃圾收集器会停止应用线程，以确保在这个阶段不会有引用关系的进一步变化。这种暂停通常很短暂。remark 阶段主要包括以下操作：</p>
<p>处理写屏障记录的引用变化：在并发标记阶段，应用程序可能会更新对象的引用（比如一个黑色对象新增了对一个白色对象的引用），这些变化通过写屏障记录下来。在 remark 阶段，GC 会处理这些记录，确保所有可达对象都正确地标记为灰色或黑色。
扫描灰色对象：再次遍历灰色对象，处理它们的所有引用，确保引用的对象正确标记为灰色或黑色。
清理：确保所有引用关系正确处理后，灰色对象标记为黑色，白色对象保持不变。这一步完成后，所有存活对象都应当是黑色的。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是三色标记法">什么是三色标记法？<a href="#什么是三色标记法" class="hash-link" aria-label="Direct link to 什么是三色标记法？" title="Direct link to 什么是三色标记法？">​</a></h3>
<p><img decoding="async" loading="lazy" alt="1757546649640" src="/assets/images/1757546649640-ba09ade7e10d4d4af01b4fa01afcf60f.png" width="1080" height="261" class="img_ev3q">
三色标记法用于标记对象的存活状态，它将对象分为三类：</p>
<p>白色（White）：尚未访问的对象。垃圾回收结束后，仍然为白色的对象会被认为是不可达的对象，可以回收。
灰色（Gray）：已经访问到但未标记完其引用的对象。灰色对象是需要进一步处理的。
黑色（Black）：已经访问到并且其所有引用对象都已经标记过。黑色对象是完全处理过的，不需要再处理。
三色标记法的工作流程：</p>
<p>①、初始标记（Initial Marking）：从 GC Roots 开始，标记所有直接可达的对象为灰色。</p>
<p>②、并发标记（Concurrent Marking）：在此阶段，标记所有灰色对象引用的对象为灰色，然后将灰色对象自身标记为黑色。这个过程是并发的，和应用线程同时进行。</p>
<p>此阶段的一个问题是，应用线程可能在并发标记期间修改对象的引用关系，导致一些对象的标记状态不准确。</p>
<p>③、重新标记（Remarking）：重新标记阶段的目标是处理并发标记阶段遗漏的引用变化。为了确保所有存活对象都被正确标记，remark 需要在 STW 暂停期间执行。</p>
<p>④、使用写屏障（Write Barrier）来捕捉并发标记阶段应用线程对对象引用的更新。通过遍历这些更新的引用来修正标记状态，确保遗漏的对象不会被错误地回收。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="g1-垃圾收集器了解吗">🌟G1 垃圾收集器了解吗？<a href="#g1-垃圾收集器了解吗" class="hash-link" aria-label="Direct link to 🌟G1 垃圾收集器了解吗？" title="Direct link to 🌟G1 垃圾收集器了解吗？">​</a></h3>
<p>G1 在 JDK 1.7 时引入，在 JDK 9 时取代 CMS 成为默认的垃圾收集器。</p>
<p><img decoding="async" loading="lazy" alt="1757546674444" src="/assets/images/1757546674444-2d1793eb56e1851e40ec4c74fbaa9fac.png" width="1386" height="570" class="img_ev3q">
G1 把 Java 堆划分为多个大小相等的独立区域Region，每个区域都可以扮演新生代或老年代的角色。</p>
<p>同时，G1 还有一个专门为大对象设计的 Region，叫 Humongous 区。
这种区域化管理使得 G1 可以更灵活地进行垃圾收集，只回收部分区域而不是整个新生代或老年代。</p>
<p>G1 收集器的运行过程大致可划分为这几个步骤：</p>
<p>①、并发标记，G1 通过并发标记的方式找出堆中的垃圾对象。并发标记阶段与应用线程同时执行，不会导致应用线程暂停。</p>
<p>②、混合收集，在并发标记完成后，G1 会计算出哪些区域的回收价值最高（也就是包含最多垃圾的区域），然后优先回收这些区域。这种回收方式包括了部分新生代区域和老年代区域。</p>
<p>选择回收成本低而收益高的区域进行回收，可以提高回收效率和减少停顿时间。</p>
<p>③、可预测的停顿，G1 在垃圾回收期间仍然需要「Stop the World」。不过，G1 在停顿时间上添加了预测机制，用户可以 JVM 启动时指定期望停顿时间，G1 会尽可能地在这个时间内完成垃圾回收。
<img decoding="async" loading="lazy" alt="1757546816320" src="/assets/images/1757546816320-0bae348ae0559f59079477198673fc95.png" width="1107" height="408" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="有了-cms为什么还要引入-g1">有了 CMS，为什么还要引入 G1？<a href="#有了-cms为什么还要引入-g1" class="hash-link" aria-label="Direct link to 有了 CMS，为什么还要引入 G1？" title="Direct link to 有了 CMS，为什么还要引入 G1？">​</a></h3>
<p>特性	CMS	G1
设计目标	低停顿时间	可预测的停顿时间
并发性	是	是
内存碎片	是，容易产生碎片	否，通过区域划分和压缩减少碎片
收集代数	年轻代和老年代	整个堆，但区分年轻代和老年代
并发阶段	并发标记、并发清理	并发标记、并发清理、并发回收
停顿时间预测	较难预测	可配置停顿时间目标
容易出现的问题	内存碎片、Concurrent Mode Failure	较少出现长时间停顿
CMS 适用于对延迟敏感的应用场景，主要目标是减少停顿时间，但容易产生内存碎片。</p>
<p>G1 则提供了更好的停顿时间预测和内存压缩能力，适用于大内存和多核处理器环境。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="你们线上用的什么垃圾收集器">你们线上用的什么垃圾收集器？<a href="#你们线上用的什么垃圾收集器" class="hash-link" aria-label="Direct link to 你们线上用的什么垃圾收集器？" title="Direct link to 你们线上用的什么垃圾收集器？">​</a></h3>
<p>我们生产环境中采用了设计比较优秀的 G1 垃圾收集器，因为它不仅能满足低停顿的要求，而且解决了 CMS 的浮动垃圾问题、内存碎片问题。</p>
<p>G1 非常适合大内存、多核处理器的环境。
以上是比较符合面试官预期的回答，但实际上，大多数情况下我们可能还是使用的 JDK 8 默认垃圾收集器。</p>
<p>可以通过以下命令查看当前 JVM 的垃圾收集器：</p>
<p>java -XX:+PrintCommandLineFlags -version</p>
<p>UseParallelGC = Parallel Scavenge + Parallel Old，表示新生代用Parallel Scavenge收集器，老年代使用Parallel Old 收集器。</p>
<p>因此你也可以这样回答：</p>
<p>我们系统的业务相对复杂，但并发量并不是特别高，所以我们选择了适用于多核处理器、能够并行处理垃圾回收任务，且能提供高吞吐量的Parallel GC。</p>
<p>但这个说法不讨喜，你也可以回答：</p>
<p>我们系统采用的是 CMS 收集器，能够最大限度减少应用暂停时间。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="工作中项目使用的什么垃圾回收算法">工作中项目使用的什么垃圾回收算法？<a href="#工作中项目使用的什么垃圾回收算法" class="hash-link" aria-label="Direct link to 工作中项目使用的什么垃圾回收算法？" title="Direct link to 工作中项目使用的什么垃圾回收算法？">​</a></h3>
<p>我们生产环境中采用了设计比较优秀的 G1 垃圾收集器，G1 采用的是分区式标记-整理算法，将堆划分为多个区域，按需回收，适用于大内存和多核环境，能够同时考虑吞吐量和暂停时间。</p>
<p>或者：</p>
<p>我们系统采用的是 CMS 收集器，CMS 采用的是标记-清除算法，能够并发标记和清除垃圾，减少暂停时间，适用于对延迟敏感的应用。</p>
<p>再或者：</p>
<p>我们系统采用的是 Parallel 收集器，Parallel 采用的是年轻代使用复制算法，老年代使用标记-整理算法，适用于高吞吐量要求的应用。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="垃圾收集器应该如何选择">垃圾收集器应该如何选择？<a href="#垃圾收集器应该如何选择" class="hash-link" aria-label="Direct link to 垃圾收集器应该如何选择？" title="Direct link to 垃圾收集器应该如何选择？">​</a></h3>
<p>如果应用程序只需要一个很小的内存空间（大约 100 MB），或者对停顿时间没有特殊的要求，可以选择 Serial 收集器。</p>
<p>如果优先考虑应用程序的峰值性能，并且没有时间要求，或者可以接受 1 秒或更长的停顿时间，可以选择 Parallel 收集器。</p>
<p>如果响应时间比吞吐量优先级高，或者垃圾收集暂停必须保持在大约 1 秒以内，可以选择 CMS/ G1 收集器。</p>
<p>如果响应时间是高优先级的，或者堆空间比较大，可以选择 ZGC 收集器。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="jvm-调优">JVM 调优<a href="#jvm-调优" class="hash-link" aria-label="Direct link to JVM 调优" title="Direct link to JVM 调优">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="用过哪些性能监控的命令行工具">用过哪些性能监控的命令行工具？<a href="#用过哪些性能监控的命令行工具" class="hash-link" aria-label="Direct link to 用过哪些性能监控的命令行工具？" title="Direct link to 用过哪些性能监控的命令行工具？">​</a></h3>
<p>操作系统层面，我用过 top、vmstat、iostat、netstat 等命令，可以监控系统整体的资源使用情况，比如说内存、CPU、IO 使用情况、网络使用情况。</p>
<p>JDK 自带的命令行工具层面，我用过 jps、jstat、jinfo、jmap、jhat、jstack、jcmd 等，可以查看 JVM 运行时信息、内存使用情况、堆栈信息等。</p>
<p>你一般都怎么用jmap？
①、我一般会使用 jmap -heap [pid] 查看堆内存摘要，包括新生代、老年代、元空间等。
②、或者使用 jmap -histo [pid] 查看对象分布。
<img decoding="async" loading="lazy" alt="1757546921121" src="/assets/images/1757546921121-38da7afb28a45288b09911a5c864c7ec.png" width="2284" height="1118" class="img_ev3q">
③、还有生成堆转储文件：jmap -dump<!-- -->:format<!-- -->=b,file=[path] [pid]。
<img decoding="async" loading="lazy" alt="1757546931122" src="/assets/images/1757546931122-7e3468bc9fced750c034bca42c17902f.png" width="1502" height="568" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="了解哪些可视化的性能监控工具">了解哪些可视化的性能监控工具？<a href="#了解哪些可视化的性能监控工具" class="hash-link" aria-label="Direct link to 了解哪些可视化的性能监控工具？" title="Direct link to 了解哪些可视化的性能监控工具？">​</a></h3>
<p>我自己用过的可视化工具主要有：</p>
<p>①、JConsole：JDK 自带的监控工具，可以用来监视 Java 应用程序的运行状态，包括内存使用、线程状态、类加载、GC 等。
②、VisualVM：一个基于 NetBeans 的可视化工具，在很长一段时间内，VisualVM 都是 Oracle 官方主推的故障处理工具。集成了多个 JDK 命令行工具的功能，非常友好。
③、Java Mission Control：JMC 最初是 JRockit VM 中的诊断工具，但在 Oracle JDK7 Update 40 以后，就绑定到了 HotSpot VM 中。不过后来又被 Oracle 开源出来作为了一个单独的产品。</p>
<p>用过哪些第三方的工具？
①、MAT：一个 Java 堆内存分析工具，主要用于分析和查找 Java 堆中的内存泄漏和内存消耗问题；可以从 Java 堆转储文件中分析内存使用情况，并提供丰富的报告，如内存泄漏疑点、最大对象和 GC 根信息；支持通过图形界面查询对象，以及检查对象间的引用关系。</p>
<p>②、GChisto：GC 日志分析工具，可以帮助我们优化垃圾收集行为和调整 GC 性能。</p>
<p>③、JProfiler：一个全功能的商业化 Java 性能分析工具，提供 CPU、 内存和线程的实时分析。</p>
<p>④、arthas：阿里巴巴开源的 Java 诊断工具，主要用于线上的应用诊断；支持在不停机的情况下进行诊断；可以提供包括 JVM 信息查看、监控、Trace 命令、反编译等功能。</p>
<p>⑤、async-profiler：一个低开销的性能分析工具，支持生成火焰图，适用于复杂性能问题的分析。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="jvm-的常见参数配置知道哪些">JVM 的常见参数配置知道哪些？<a href="#jvm-的常见参数配置知道哪些" class="hash-link" aria-label="Direct link to JVM 的常见参数配置知道哪些？" title="Direct link to JVM 的常见参数配置知道哪些？">​</a></h3>
<p>配置堆内存大小的参数有哪些？
-Xms：初始堆大小
-Xmx：最大堆大小
-XX<!-- -->:NewSize<!-- -->=n：设置年轻代大小
-XX<!-- -->:NewRatio<!-- -->=n：设置年轻代和年老代的比值。如：n 为 3 表示年轻代和年老代比值为 1：3，年轻代占总和的 1/4
-XX<!-- -->:SurvivorRatio<!-- -->=n：年轻代中 Eden 区与两个 Survivor 区的比值。如 n=3 表示 Eden 占 3 Survivor 占 2，一个 Survivor 区占整个年轻代的 1/5
配置 GC 收集器的参数有哪些？
-XX:+UseSerialGC：设置串行收集器
-XX:+UseParallelGC：设置并行收集器
-XX:+UseParalledlOldGC：设置并行老年代收集器
-XX:+UseConcMarkSweepGC：设置并发收集器</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="配置并行收集的参数有哪些">配置并行收集的参数有哪些？<a href="#配置并行收集的参数有哪些" class="hash-link" aria-label="Direct link to 配置并行收集的参数有哪些？" title="Direct link to 配置并行收集的参数有哪些？">​</a></h3>
<p>-XX<!-- -->:MaxGCPauseMillis<!-- -->=n：设置最大垃圾回收停顿时间
-XX<!-- -->:GCTimeRatio<!-- -->=n：设置垃圾回收时间占程序运行时间的比例
-XX:+CMSIncrementalMode：设置增量模式，适合单 CPU 环境
-XX<!-- -->:ParallelGCThreads<!-- -->=n：设置并行收集器的线程数</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="打印-gc-回收的过程日志信息的参数有哪些">打印 GC 回收的过程日志信息的参数有哪些？<a href="#打印-gc-回收的过程日志信息的参数有哪些" class="hash-link" aria-label="Direct link to 打印 GC 回收的过程日志信息的参数有哪些？" title="Direct link to 打印 GC 回收的过程日志信息的参数有哪些？">​</a></h3>
<p>-XX:+PrintGC：输出 GC 日志
-XX:+PrintGCDetails：输出 GC 详细日志
-XX:+PrintGCTimeStamps：输出 GC 的时间戳（以基准时间的形式）
-Xloggc<!-- -->:filename<!-- -->：日志文件的输出路径</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="做过-jvm-调优吗">做过 JVM 调优吗？<a href="#做过-jvm-调优吗" class="hash-link" aria-label="Direct link to 做过 JVM 调优吗？" title="Direct link to 做过 JVM 调优吗？">​</a></h3>
<p>JVM 调优是一个复杂的过程，调优的对象包括堆内存、垃圾收集器和 JVM 运行时参数等。
<img decoding="async" loading="lazy" alt="1757548419679" src="/assets/images/1757548419679-96859b6f32c846acd98cac247a72586e.png" width="1682" height="828" class="img_ev3q">
如果堆内存设置过小，可能会导致频繁的垃圾回收。所以在技术派实战项目中，启动 JVM 的时候配置了 -Xms 和 -Xmx 参数，让堆内存最大可用内存为 2G（我用的丐版服务器）。</p>
<p>在项目运行期间，我会使用 JVisualVM 定期观察和分析 GC 日志，如果发现频繁的 Full GC，我会特意关注一下老年代的使用情况。</p>
<p>接着，通过分析 Heap dump 寻找内存泄漏的源头，看看是否有未关闭的资源，长生命周期的大对象等。</p>
<p>之后进行代码优化，比如说减少大对象的创建、优化数据结构的使用方式、减少不必要的对象持有等。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="cpu-占用过高怎么排查">CPU 占用过高怎么排查？<a href="#cpu-占用过高怎么排查" class="hash-link" aria-label="Direct link to CPU 占用过高怎么排查？" title="Direct link to CPU 占用过高怎么排查？">​</a></h3>
<p><img decoding="async" loading="lazy" alt="1757548448502" src="/assets/images/1757548448502-223b0983b210213c1086648a75fb236f.png" width="708" height="256" class="img_ev3q">
首先，使用 top 命令查看 CPU 占用情况，找到占用 CPU 较高的进程 ID。
top
接着，使用 jstack 命令查看对应进程的线程堆栈信息。
<code>shell jstack -l &lt;pid&gt; &gt; thread-dump.txt</code>
然后再使用 top 命令查看进程中线程的占用情况，找到占用 CPU 较高的线程 ID。
<code>top -H -p &lt;pid&gt;</code>
printf &quot;%x\n&quot; PID
接着在 jstack 的输出中搜索这个十六进制的线程 ID，找到对应的堆栈信息。
最后，根据堆栈信息定位到具体的业务方法，查看是否有死循环、频繁的垃圾回收、资源竞争导致的上下文频繁切换等问题。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="内存飙高问题怎么排查">内存飙高问题怎么排查？<a href="#内存飙高问题怎么排查" class="hash-link" aria-label="Direct link to 内存飙高问题怎么排查？" title="Direct link to 内存飙高问题怎么排查？">​</a></h3>
<p>内存飚高一般是因为创建了大量的 Java 对象导致的，如果持续飙高则说明垃圾回收跟不上对象创建的速度，或者内存泄漏导致对象无法回收。</p>
<p>排查的方法主要分为以下几步：</p>
<p>第一，先观察垃圾回收的情况，可以通过 jstat -gc PID 1000 查看 GC 次数和时间。</p>
<p>或者使用 jmap -histo PID | head -20 查看堆内存占用空间最大的前 20 个对象类型。</p>
<p>第二步，通过 jmap 命令 dump 出堆内存信息。
第三步，使用可视化工具分析 dump 文件，比如说 VisualVM，找到占用内存高的对象，再找到创建该对象的业务代码位置，从代码和业务场景中定位具体问题。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="频繁-minor-gc-怎么办">频繁 minor gc 怎么办？<a href="#频繁-minor-gc-怎么办" class="hash-link" aria-label="Direct link to 频繁 minor gc 怎么办？" title="Direct link to 频繁 minor gc 怎么办？">​</a></h3>
<p>频繁的 Minor GC 通常意味着新生代中的对象频繁地被垃圾回收，可能是因为新生代空间设置的过小，或者是因为程序中存在大量的短生命周期对象（如临时变量）。</p>
<p>可以使用 GC 日志进行分析，查看 GC 的频率和耗时，找到频繁 GC 的原因。</p>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">-XX:+PrintGCDetails -Xloggc:gc.log</span><br></span></code></pre></div></div>
<p>或者使用监控工具查看堆内存的使用情况，特别是新生代（Eden 和 Survivor 区）的使用情况。</p>
<p>如果是因为新生代空间不足，可以通过 -Xmn 增加新生代的大小，减缓新生代的填满速度。</p>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">java -Xmn256m your-app.jar</span><br></span></code></pre></div></div>
<p>如果对象需要长期存活，但频繁从 Survivor 区晋升到老年代，可以通过 -XX<!-- -->:SurvivorRatio<!-- --> 参数调整 Eden 和 Survivor 的比例。默认比例是 8:1，表示 8 个空间用于 Eden，1 个空间用于 Survivor 区。</p>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">-XX:SurvivorRatio=6</span><br></span></code></pre></div></div>
<p>调整为 6 的话，会减少 Eden 区的大小，增加 Survivor 区的大小，以确保对象在 Survivor 区中存活的时间足够长，避免过早晋升到老年代。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="频繁-full-gc-怎么办">频繁 Full GC 怎么办？<a href="#频繁-full-gc-怎么办" class="hash-link" aria-label="Direct link to 频繁 Full GC 怎么办？" title="Direct link to 频繁 Full GC 怎么办？">​</a></h3>
<p>频繁的 Full GC 通常意味着老年代中的对象频繁地被垃圾回收，可能是因为老年代空间设置的过小，或者是因为程序中存在大量的长生命周期对象。</p>
<p>该怎么排查 Full GC 频繁问题？
我厂会通过专门的性能监控系统，查看 GC 的频率和堆内存的使用情况，然后根据监控数据分析 GC 的原因。</p>
<p>如果是小厂，可以这么回复。</p>
<p>我一般会使用 JDK 的自带工具，包括 jmap、jstat 等。</p>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># 查看堆内存各区域的使用率以及GC情况</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">jstat -gcutil -h20 pid 1000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 查看堆内存中的存活对象，并按空间排序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">jmap -histo pid | head -n20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># dump堆内存文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">jmap -dump:format=b,file=heap pid</span><br></span></code></pre></div></div>
<p>或者使用一些可视化的工具，比如 VisualVM、JConsole 等，查看堆内存的使用情况。</p>
<p>假如是因为大对象直接分配到老年代导致的 Full GC 频繁，可以通过 -XX<!-- -->:PretenureSizeThreshold<!-- --> 参数设置大对象直接进入老年代的阈值。</p>
<p>或者将大对象拆分成小对象，减少大对象的创建。比如说分页。</p>
<p>假如是因为内存泄漏导致的频繁 Full GC，可以通过分析堆内存 dump 文件找到内存泄漏的对象，再找到内存泄漏的代码位置。</p>
<p>假如是因为长生命周期的对象进入到了老年代，要及时释放资源，比如说 ThreadLocal、数据库连接、IO 资源等。</p>
<p>假如是因为 GC 参数配置不合理导致的频繁 Full GC，可以通过调整 GC 参数来优化 GC 行为。或者直接更换更适合的 GC 收集器，如 G1、ZGC 等。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="类加载机制">类加载机制<a href="#类加载机制" class="hash-link" aria-label="Direct link to 类加载机制" title="Direct link to 类加载机制">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="了解类的加载机制吗补充">🌟了解类的加载机制吗？（补充）<a href="#了解类的加载机制吗补充" class="hash-link" aria-label="Direct link to 🌟了解类的加载机制吗？（补充）" title="Direct link to 🌟了解类的加载机制吗？（补充）">​</a></h3>
<p>了解。</p>
<p>JVM 的操作对象是 Class 文件，JVM 把 Class 文件中描述类的数据结构加载到内存中，并对数据进行校验、解析和初始化，最终转化成可以被 JVM 直接使用的类型，这个过程被称为类加载机制。</p>
<p>其中最重要的三个概念就是：类加载器、类加载过程和双亲委派模型。</p>
<p>类加载器：负责加载类文件，将类文件加载到内存中，生成 Class 对象。
类加载过程：包括加载、验证、准备、解析和初始化等步骤。
双亲委派模型：当一个类加载器接收到类加载请求时，它会把请求委派给父——类加载器去完成，依次递归，直到最顶层的类加载器，如果父——类加载器无法完成加载请求，子类加载器才会尝试自己去加载。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="类加载器有哪些">类加载器有哪些？<a href="#类加载器有哪些" class="hash-link" aria-label="Direct link to 类加载器有哪些？" title="Direct link to 类加载器有哪些？">​</a></h3>
<p>主要有四种：</p>
<p>①、启动类加载器，负责加载 JVM 的核心类库，如 rt.jar 和其他核心库位于JAVA_HOME/jre/lib目录下的类。</p>
<p>②、扩展类加载器，负责加载JAVA_HOME/jre/lib/ext目录下，或者由系统属性java.ext.dirs指定位置的类库，由sun.misc.Launcher$ExtClassLoader 实现。</p>
<p>③、应用程序类加载器，负责加载 classpath 的类库，由sun.misc.Launcher$AppClassLoader实现。</p>
<p>我们编写的任何类都是由应用程序类加载器加载的，除非显式使用自定义类加载器。</p>
<p>④、用户自定义类加载器，通常用于加载网络上的类、执行热部署（动态加载和替换应用程序的组件），或者为了安全考虑，从不同的源加载类。</p>
<p>通过继承java.lang.ClassLoader类来实现。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="能说一下类的生命周期吗">能说一下类的生命周期吗？<a href="#能说一下类的生命周期吗" class="hash-link" aria-label="Direct link to 能说一下类的生命周期吗？" title="Direct link to 能说一下类的生命周期吗？">​</a></h3>
<p>一个类从被加载到虚拟机内存中开始，到从内存中卸载，整个生命周期需要经过七个阶段：加载 、验证、准备、解析、初始化、使用和卸载。
<img decoding="async" loading="lazy" alt="1757548684486" src="/assets/images/1757548684486-cb7eec68d728904d560b378f990befaf.png" width="835" height="367" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="类装载的过程知道吗">🌟类装载的过程知道吗？<a href="#类装载的过程知道吗" class="hash-link" aria-label="Direct link to 🌟类装载的过程知道吗？" title="Direct link to 🌟类装载的过程知道吗？">​</a></h3>
<p>推荐阅读：一文彻底搞懂 Java 类加载机制</p>
<p>知道。</p>
<p>类装载过程包括三个阶段：载入、链接和初始化。</p>
<p>①、载入：将类的二进制字节码加载到内存中。</p>
<p>②、链接可以细分为三个小的阶段：</p>
<p>验证：检查类文件格式是否符合 JVM 规范
准备：为类的静态变量分配内存并设置默认值。
解析：将符号引用替换为直接引用。
③、初始化：执行静态代码块和静态变量初始化。</p>
<p>在准备阶段，静态变量已经被赋过默认初始值了，在初始化阶段，静态变量将被赋值为代码期望赋的值。比如说 static int a = 1;，在准备阶段，a 的值为 0，在初始化阶段，a 的值为 1。</p>
<p>换句话说，初始化阶段是在执行类的构造方法，也就是 javap 中看到的 clinit()。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="载入过程-jvm-会做什么">载入过程 JVM 会做什么？<a href="#载入过程-jvm-会做什么" class="hash-link" aria-label="Direct link to 载入过程 JVM 会做什么？" title="Direct link to 载入过程 JVM 会做什么？">​</a></h3>
<p><img decoding="async" loading="lazy" alt="1757548720432" src="/assets/images/1757548720432-fa67a432b38c54c2bf04157b50364393.png" width="392" height="404" class="img_ev3q">
1）通过一个类的全限定名来获取定义此类的二进制字节流。
2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3）在内存中生成一个代表这个类的 java.lang.Class 对象，作为这个类的访问入口。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是双亲委派模型">🌟什么是双亲委派模型？<a href="#什么是双亲委派模型" class="hash-link" aria-label="Direct link to 🌟什么是双亲委派模型？" title="Direct link to 🌟什么是双亲委派模型？">​</a></h3>
<p>双亲委派模型要求类加载器在加载类时，先委托父加载器尝试加载，只有父加载器无法加载时，子加载器才会加载。
<img decoding="async" loading="lazy" alt="1757548757602" src="/assets/images/1757548757602-27a31c00b821bad3f11fb037176b4b3c.png" width="1033" height="677" class="img_ev3q"></p>
<p>这个过程会一直向上递归，也就是说，从子加载器到父加载器，再到更上层的加载器，一直到最顶层的启动类加载器。</p>
<p>启动类加载器会尝试加载这个类。如果它能够加载这个类，就直接返回；如果它不能加载这个类，就会将加载任务返回给委托它的子加载器。</p>
<p>子加载器尝试加载这个类。如果子加载器也无法加载这个类，它就会继续向下传递这个加载任务，依此类推。</p>
<p>直到某个加载器能够加载这个类，或者所有加载器都无法加载这个类，最终抛出 ClassNotFoundException。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么要用双亲委派模型">为什么要用双亲委派模型？<a href="#为什么要用双亲委派模型" class="hash-link" aria-label="Direct link to 为什么要用双亲委派模型？" title="Direct link to 为什么要用双亲委派模型？">​</a></h3>
<p>①、避免类的重复加载：父加载器加载的类，子加载器无需重复加载。</p>
<p>②、保证核心类库的安全性：如 java.lang.* 只能由 Bootstrap ClassLoader 加载，防止被篡改。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何破坏双亲委派机制">如何破坏双亲委派机制？<a href="#如何破坏双亲委派机制" class="hash-link" aria-label="Direct link to 如何破坏双亲委派机制？" title="Direct link to 如何破坏双亲委派机制？">​</a></h3>
<p>重写 ClassLoader 的 loadClass() 方法。</p>
<p>如果不想打破双亲委派模型，就重写 ClassLoader 类中的 findClass() 方法，那些无法被父类加载器加载的类最终会通过这个方法被加载。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="有哪些破坏双亲委派模型的典型例子">有哪些破坏双亲委派模型的典型例子？<a href="#有哪些破坏双亲委派模型的典型例子" class="hash-link" aria-label="Direct link to 有哪些破坏双亲委派模型的典型例子？" title="Direct link to 有哪些破坏双亲委派模型的典型例子？">​</a></h3>
<p>我了解的有两种：</p>
<p>第一种：SPI 机制加载 JDBC 驱动。
第二种：热部署框架。
<img decoding="async" loading="lazy" alt="1757548825288" src="/assets/images/1757548825288-6c83be8ee2166ddc5c2d23f3e67e7268.png" width="1223" height="690" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说spi-机制">说说SPI 机制？<a href="#说说spi-机制" class="hash-link" aria-label="Direct link to 说说SPI 机制？" title="Direct link to 说说SPI 机制？">​</a></h3>
<p>SPI 是 Java 的一种扩展机制，用于加载和注册第三方类库，常见于 JDBC、JNDI 等框架。</p>
<p>双亲委派模型会优先让父类加载器加载类，而 SPI 需要动态加载子类加载器中的实现。</p>
<p>根据双亲委派模型，java.sql.Driver 类应该由父加载器加载，但父类加载器无法加载由子类加载器定义的驱动类，如 MySQL 的 com.mysql.cj.jdbc.Driver。</p>
<p>那么只能使用 SPI 机制通过 META-INF/services 文件指定服务提供者的实现类。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Enumeration&lt;Driver&gt; drivers = ServiceLoader.load(Driver.class, cl).iterator();</span><br></span></code></pre></div></div>
<p>DriverManager 使用了线程上下文类加载器来加载 SPI 的实现类，从而允许子类加载器加载具体的 JDBC 驱动。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说热部署">说说热部署？<a href="#说说热部署" class="hash-link" aria-label="Direct link to 说说热部署？" title="Direct link to 说说热部署？">​</a></h3>
<p>热部署是指在不重启服务器的情况下更新应用程序代码，需要替换旧版本的类，但旧版本的类可能由父加载器加载。</p>
<p>如 Spring Boot 的 DevTools 通常会自定义类加载器，优先加载新的类版本。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="tomcat-的类加载机制了解吗">Tomcat 的类加载机制了解吗？<a href="#tomcat-的类加载机制了解吗" class="hash-link" aria-label="Direct link to Tomcat 的类加载机制了解吗？" title="Direct link to Tomcat 的类加载机制了解吗？">​</a></h3>
<p>Tomcat 基于双亲委派模型进行了一些扩展，主要的类加载器有：</p>
<p>Bootstrap ClassLoader：加载 Java 的核心类库；
Catalina ClassLoader：加载 Tomcat 的核心类库；
Shared ClassLoader：加载共享类库，允许多个 Web 应用共享某些类库；
WebApp ClassLoader：加载 Web 应用程序的类库，支持多应用隔离和优先加载应用自定义的类库（破坏了双亲委派模型）。
<img decoding="async" loading="lazy" alt="1757548914909" src="/assets/images/1757548914909-0dc35af4a6d975097abd841ad5bffc05.png" width="940" height="737" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="你觉得应该怎么实现一个热部署功能">你觉得应该怎么实现一个热部署功能？<a href="#你觉得应该怎么实现一个热部署功能" class="hash-link" aria-label="Direct link to 你觉得应该怎么实现一个热部署功能？" title="Direct link to 你觉得应该怎么实现一个热部署功能？">​</a></h3>
<p>热部署是指在不重启服务器的情况下，动态加载、更新或卸载应用程序的组件，比如类、配置文件等。</p>
<p>需要在类加载器的基础上，实现类的重新加载。</p>
<p>我的思路是：</p>
<p>第一步，使用文件监控机制，如 Java NIO 的 WatchService 来监控类文件或配置文件的变化。当监控到文件变更时，触发热部署流程。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class FileWatcher {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void watchDirectoryPath(Path path) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 检查路径是否是有效目录</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!isDirectory(path)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.err.println(&quot;Provided path is not a directory: &quot; + path);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Starting to watch path: &quot; + path);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 获取文件系统的 WatchService</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try (WatchService watchService = path.getFileSystem().newWatchService()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 注册目录监听服务，监听创建、修改和删除事件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            path.register(watchService, ENTRY_CREATE, ENTRY_MODIFY, ENTRY_DELETE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                WatchKey key;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 阻塞直到有事件发生</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    key = watchService.take();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    System.out.println(&quot;WatchService interrupted, stopping directory watch.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Thread.currentThread().interrupt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 处理事件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (WatchEvent&lt;?&gt; event : key.pollEvents()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    processEvent(event);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 重置 key，如果失败则退出</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (!key.reset()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    System.out.println(&quot;WatchKey no longer valid. Exiting watch loop.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (IOException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.err.println(&quot;An error occurred while setting up the WatchService: &quot; + e.getMessage());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static boolean isDirectory(Path path) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Files.isDirectory(path, LinkOption.NOFOLLOW_LINKS);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static void processEvent(WatchEvent&lt;?&gt; event) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        WatchEvent.Kind&lt;?&gt; kind = event.kind();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 处理事件类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (kind == OVERFLOW) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;Event overflow occurred. Some events might have been lost.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @SuppressWarnings(&quot;unchecked&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Path fileName = ((WatchEvent&lt;Path&gt;) event).context();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Event: &quot; + kind.name() + &quot;, File affected: &quot; + fileName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 设置监控路径为当前目录</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Path pathToWatch = Paths.get(&quot;.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        watchDirectoryPath(pathToWatch);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>第二步，创建一个自定义类加载器，继承java.lang.ClassLoader，并重写findClass()方法，用来加载新的类文件。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class HotSwapClassLoader extends ClassLoader {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public HotSwapClassLoader() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super(ClassLoader.getSystemClassLoader());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 加载指定路径下的类文件字节码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        byte[] classBytes = loadClassData(name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (classBytes == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new ClassNotFoundException(name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 调用defineClass将字节码转换为Class对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return defineClass(name, classBytes, 0, classBytes.length);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private byte[] loadClassData(String name) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 实现从文件系统或其他来源加载类文件的字节码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>友情提示：Intellij IDEA 提供了热部署功能，当我们修改了代码后，IDEA 会自动保存并编译，如果是 Web 项目，还可以在 Chrome 浏览器中装一个 LiveReload 插件，一旦编译完成，页面就会自动刷新看到最新的效果。对于测试或者调试来说，非常方便。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说解释执行和编译执行的区别补充">说说解释执行和编译执行的区别（补充）<a href="#说说解释执行和编译执行的区别补充" class="hash-link" aria-label="Direct link to 说说解释执行和编译执行的区别（补充）" title="Direct link to 说说解释执行和编译执行的区别（补充）">​</a></h3>
<p>先说解释和编译的区别：</p>
<p>解释：将源代码逐行转换为机器码。
编译：将源代码一次性转换为机器码。
一个是逐行，一个是一次性，再来说说解释执行和编译执行的区别：</p>
<p>解释执行：程序运行时，将源代码逐行转换为机器码，然后执行。
编译执行：程序运行前，将源代码一次性转换为机器码，然后执行。
Java 一般被称为“解释型语言”，因为 Java 代码在执行前，需要先将源代码编译成字节码，然后在运行时，再由 JVM 的解释器“逐行”将字节码转换为机器码，然后执行。</p>
<p>这也是 Java 被诟病“慢”的主要原因。</p>
<p>但 JIT 的出现打破了这种刻板印象，JVM 会将热点代码（即运行频率高的代码）编译后放入 CodeCache，当下次执行再遇到这段代码时，会从 CodeCache 中直接读取机器码，然后执行。</p>
<p>因此，Java 的执行效率得到了大幅提升。
<img decoding="async" loading="lazy" alt="img_59.png" src="/assets/images/img_59-8092643905aa2270ff3a58004f83dc4c.png" width="648" height="454" class="img_ev3q"></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-tags-row"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a rel="tag" class="tag_zVej tagRegular_sFm0" href="/docs/tags/interview">INTERVIEW</a></li><li class="tag_QGVx"><a rel="tag" class="tag_zVej tagRegular_sFm0" href="/docs/tags/java">JAVA</a></li><li class="tag_QGVx"><a rel="tag" class="tag_zVej tagRegular_sFm0" href="/docs/tags/jvm">JVM</a></li></ul></div></div><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/java/java-jvm.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/java/java-aqs"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">java-aqs</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/java/java_collection_review"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">java_collection_review</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#说说-jvm-的其他特性" class="table-of-contents__link toc-highlight">说说 JVM 的其他特性？</a></li><li><a href="#说说-jvm-的组织架构补充" class="table-of-contents__link toc-highlight">说说 JVM 的组织架构（补充）</a></li><li><a href="#内存管理" class="table-of-contents__link toc-highlight">内存管理</a><ul><li><a href="#能说一下-jvm-的内存区域吗" class="table-of-contents__link toc-highlight">🌟能说一下 JVM 的内存区域吗？</a></li><li><a href="#介绍一下程序计数器" class="table-of-contents__link toc-highlight">介绍一下程序计数器？</a></li><li><a href="#介绍一下-java-虚拟机栈" class="table-of-contents__link toc-highlight">介绍一下 Java 虚拟机栈？</a></li><li><a href="#一个什么都没有的空方法空的参数都没有那局部变量表里有没有变量" class="table-of-contents__link toc-highlight">一个什么都没有的空方法，空的参数都没有，那局部变量表里有没有变量？</a></li><li><a href="#介绍一下本地方法栈" class="table-of-contents__link toc-highlight">介绍一下本地方法栈？</a></li><li><a href="#介绍一下本地方法栈的运行场景" class="table-of-contents__link toc-highlight">介绍一下本地方法栈的运行场景？</a></li><li><a href="#native-方法解释一下" class="table-of-contents__link toc-highlight">native 方法解释一下？</a></li><li><a href="#介绍一下-java-堆" class="table-of-contents__link toc-highlight">介绍一下 Java 堆？</a></li><li><a href="#堆和栈的区别是什么" class="table-of-contents__link toc-highlight">堆和栈的区别是什么？</a></li><li><a href="#介绍一下方法区" class="table-of-contents__link toc-highlight">介绍一下方法区？</a></li><li><a href="#变量存在堆栈的什么位置" class="table-of-contents__link toc-highlight">变量存在堆栈的什么位置？</a></li><li><a href="#说一下-jdk-161718-内存区域的变化" class="table-of-contents__link toc-highlight">说一下 JDK 1.6、1.7、1.8 内存区域的变化？</a></li><li><a href="#为什么使用元空间替代永久代" class="table-of-contents__link toc-highlight">为什么使用元空间替代永久代？</a></li><li><a href="#对象创建的过程了解吗" class="table-of-contents__link toc-highlight">🌟对象创建的过程了解吗？</a></li><li><a href="#对象的销毁过程了解吗" class="table-of-contents__link toc-highlight">对象的销毁过程了解吗？</a></li><li><a href="#堆内存是如何分配的" class="table-of-contents__link toc-highlight">堆内存是如何分配的？</a></li><li><a href="#什么是指针碰撞" class="table-of-contents__link toc-highlight">什么是指针碰撞？</a></li><li><a href="#什么是空闲列表" class="table-of-contents__link toc-highlight">什么是空闲列表？</a></li><li><a href="#new-对象时堆会发生抢占吗" class="table-of-contents__link toc-highlight">new 对象时，堆会发生抢占吗？</a></li><li><a href="#jvm-怎么解决堆内存分配的竞争问题" class="table-of-contents__link toc-highlight">JVM 怎么解决堆内存分配的竞争问题？</a></li><li><a href="#能说一下对象的内存布局吗" class="table-of-contents__link toc-highlight">能说一下对象的内存布局吗？</a></li><li><a href="#jvm-怎么访问对象的" class="table-of-contents__link toc-highlight">JVM 怎么访问对象的？</a></li><li><a href="#说一下对象有哪几种引用" class="table-of-contents__link toc-highlight">说一下对象有哪几种引用？</a></li><li><a href="#java-堆的内存分区了解吗" class="table-of-contents__link toc-highlight">Java 堆的内存分区了解吗？</a></li><li><a href="#说一下新生代的区域划分" class="table-of-contents__link toc-highlight">说一下新生代的区域划分？</a></li><li><a href="#对象什么时候会进入老年代" class="table-of-contents__link toc-highlight">🌟对象什么时候会进入老年代</a></li><li><a href="#长期存活的对象如何判断" class="table-of-contents__link toc-highlight">长期存活的对象如何判断？</a></li><li><a href="#大对象如何判断" class="table-of-contents__link toc-highlight">大对象如何判断？</a></li><li><a href="#动态年龄判定了解吗" class="table-of-contents__link toc-highlight">动态年龄判定了解吗？</a></li><li><a href="#stw-了解吗" class="table-of-contents__link toc-highlight">STW 了解吗？</a></li><li><a href="#如何暂停线程呢" class="table-of-contents__link toc-highlight">如何暂停线程呢？</a></li><li><a href="#什么是安全点" class="table-of-contents__link toc-highlight">什么是安全点？</a></li><li><a href="#对象一定分配在堆中吗" class="table-of-contents__link toc-highlight">对象一定分配在堆中吗？</a></li><li><a href="#什么是逃逸分析" class="table-of-contents__link toc-highlight">什么是逃逸分析？</a></li><li><a href="#逃逸具体是指什么" class="table-of-contents__link toc-highlight">逃逸具体是指什么？</a></li><li><a href="#逃逸分析会带来什么好处" class="table-of-contents__link toc-highlight">逃逸分析会带来什么好处？</a></li><li><a href="#内存溢出和内存泄漏了解吗" class="table-of-contents__link toc-highlight">内存溢出和内存泄漏了解吗？</a></li><li><a href="#能手写内存溢出的例子吗" class="table-of-contents__link toc-highlight">能手写内存溢出的例子吗？</a></li><li><a href="#内存泄漏可能由哪些原因导致呢" class="table-of-contents__link toc-highlight">内存泄漏可能由哪些原因导致呢？</a></li><li><a href="#有没有处理过内存泄漏问题" class="table-of-contents__link toc-highlight">有没有处理过内存泄漏问题？</a></li><li><a href="#有没有处理过内存溢出问题" class="table-of-contents__link toc-highlight">有没有处理过内存溢出问题？</a></li><li><a href="#什么情况下会发生栈溢出补充" class="table-of-contents__link toc-highlight">什么情况下会发生栈溢出？（补充）</a></li><li><a href="#垃圾收集" class="table-of-contents__link toc-highlight">垃圾收集</a></li><li><a href="#讲讲-jvm-的垃圾回收机制补充" class="table-of-contents__link toc-highlight">🌟讲讲 JVM 的垃圾回收机制（补充）</a></li><li><a href="#垃圾回收的过程是什么" class="table-of-contents__link toc-highlight">垃圾回收的过程是什么？</a></li><li><a href="#如何判断对象仍然存活" class="table-of-contents__link toc-highlight">🌟如何判断对象仍然存活？</a></li><li><a href="#什么是引用计数法" class="table-of-contents__link toc-highlight">什么是引用计数法？</a></li><li><a href="#java-中可作为-gc-roots-的引用有哪几种" class="table-of-contents__link toc-highlight">Java 中可作为 GC Roots 的引用有哪几种？</a></li><li><a href="#说说虚拟机栈中的引用" class="table-of-contents__link toc-highlight">说说虚拟机栈中的引用？</a></li><li><a href="#说说本地方法栈中-jni-的引用" class="table-of-contents__link toc-highlight">说说本地方法栈中 JNI 的引用？</a></li><li><a href="#说说类静态变量" class="table-of-contents__link toc-highlight">说说类静态变量？</a></li><li><a href="#说说运行时常量池中的常量" class="table-of-contents__link toc-highlight">说说运行时常量池中的常量？</a></li><li><a href="#finalize方法了解吗" class="table-of-contents__link toc-highlight">finalize()方法了解吗？</a></li><li><a href="#垃圾收集算法了解吗" class="table-of-contents__link toc-highlight">🌟垃圾收集算法了解吗？</a></li><li><a href="#说说分代收集算法" class="table-of-contents__link toc-highlight">说说分代收集算法？</a></li><li><a href="#为什么要用分代收集呢" class="table-of-contents__link toc-highlight">为什么要用分代收集呢？</a></li><li><a href="#标记复制的标记过程和复制过程会不会停顿" class="table-of-contents__link toc-highlight">标记复制的标记过程和复制过程会不会停顿？</a></li><li><a href="#minor-gcmajor-gcmixed-gcfull-gc-都是什么意思" class="table-of-contents__link toc-highlight">Minor GC、Major GC、Mixed GC、Full GC 都是什么意思？</a></li><li><a href="#full-gc怎么去清理的" class="table-of-contents__link toc-highlight">FULL gc怎么去清理的？</a></li><li><a href="#young-gc-什么时候触发" class="table-of-contents__link toc-highlight">Young GC 什么时候触发？</a></li><li><a href="#什么时候会触发-full-gc" class="table-of-contents__link toc-highlight">什么时候会触发 Full GC？</a></li><li><a href="#空间分配担保是什么" class="table-of-contents__link toc-highlight">空间分配担保是什么？</a></li><li><a href="#知道哪些垃圾收集器" class="table-of-contents__link toc-highlight">🌟知道哪些垃圾收集器？</a></li><li><a href="#说说-serial-收集器" class="table-of-contents__link toc-highlight">说说 Serial 收集器？</a></li><li><a href="#说说-parnew-收集器" class="table-of-contents__link toc-highlight">说说 ParNew 收集器？</a></li><li><a href="#说说-parallel-scavenge-收集器" class="table-of-contents__link toc-highlight">说说 Parallel Scavenge 收集器？</a></li><li><a href="#说说-serial-old-收集器" class="table-of-contents__link toc-highlight">说说 Serial Old 收集器？</a></li><li><a href="#说说-cms-收集器" class="table-of-contents__link toc-highlight">说说 CMS 收集器？</a></li><li><a href="#说说-g1-收集器" class="table-of-contents__link toc-highlight">说说 G1 收集器？</a></li><li><a href="#说说-zgc-收集器" class="table-of-contents__link toc-highlight">说说 ZGC 收集器？</a></li><li><a href="#垃圾回收器的作用是什么" class="table-of-contents__link toc-highlight">垃圾回收器的作用是什么？</a></li><li><a href="#能详细说一下-cms-的垃圾收集过程吗" class="table-of-contents__link toc-highlight">🌟能详细说一下 CMS 的垃圾收集过程吗？</a></li><li><a href="#什么是三色标记法" class="table-of-contents__link toc-highlight">什么是三色标记法？</a></li><li><a href="#g1-垃圾收集器了解吗" class="table-of-contents__link toc-highlight">🌟G1 垃圾收集器了解吗？</a></li><li><a href="#有了-cms为什么还要引入-g1" class="table-of-contents__link toc-highlight">有了 CMS，为什么还要引入 G1？</a></li><li><a href="#你们线上用的什么垃圾收集器" class="table-of-contents__link toc-highlight">你们线上用的什么垃圾收集器？</a></li><li><a href="#工作中项目使用的什么垃圾回收算法" class="table-of-contents__link toc-highlight">工作中项目使用的什么垃圾回收算法？</a></li><li><a href="#垃圾收集器应该如何选择" class="table-of-contents__link toc-highlight">垃圾收集器应该如何选择？</a></li></ul></li><li><a href="#jvm-调优" class="table-of-contents__link toc-highlight">JVM 调优</a><ul><li><a href="#用过哪些性能监控的命令行工具" class="table-of-contents__link toc-highlight">用过哪些性能监控的命令行工具？</a></li><li><a href="#了解哪些可视化的性能监控工具" class="table-of-contents__link toc-highlight">了解哪些可视化的性能监控工具？</a></li><li><a href="#jvm-的常见参数配置知道哪些" class="table-of-contents__link toc-highlight">JVM 的常见参数配置知道哪些？</a></li><li><a href="#配置并行收集的参数有哪些" class="table-of-contents__link toc-highlight">配置并行收集的参数有哪些？</a></li><li><a href="#打印-gc-回收的过程日志信息的参数有哪些" class="table-of-contents__link toc-highlight">打印 GC 回收的过程日志信息的参数有哪些？</a></li><li><a href="#做过-jvm-调优吗" class="table-of-contents__link toc-highlight">做过 JVM 调优吗？</a></li><li><a href="#cpu-占用过高怎么排查" class="table-of-contents__link toc-highlight">CPU 占用过高怎么排查？</a></li><li><a href="#内存飙高问题怎么排查" class="table-of-contents__link toc-highlight">内存飙高问题怎么排查？</a></li><li><a href="#频繁-minor-gc-怎么办" class="table-of-contents__link toc-highlight">频繁 minor gc 怎么办？</a></li><li><a href="#频繁-full-gc-怎么办" class="table-of-contents__link toc-highlight">频繁 Full GC 怎么办？</a></li></ul></li><li><a href="#类加载机制" class="table-of-contents__link toc-highlight">类加载机制</a><ul><li><a href="#了解类的加载机制吗补充" class="table-of-contents__link toc-highlight">🌟了解类的加载机制吗？（补充）</a></li><li><a href="#类加载器有哪些" class="table-of-contents__link toc-highlight">类加载器有哪些？</a></li><li><a href="#能说一下类的生命周期吗" class="table-of-contents__link toc-highlight">能说一下类的生命周期吗？</a></li><li><a href="#类装载的过程知道吗" class="table-of-contents__link toc-highlight">🌟类装载的过程知道吗？</a></li><li><a href="#载入过程-jvm-会做什么" class="table-of-contents__link toc-highlight">载入过程 JVM 会做什么？</a></li><li><a href="#什么是双亲委派模型" class="table-of-contents__link toc-highlight">🌟什么是双亲委派模型？</a></li><li><a href="#为什么要用双亲委派模型" class="table-of-contents__link toc-highlight">为什么要用双亲委派模型？</a></li><li><a href="#如何破坏双亲委派机制" class="table-of-contents__link toc-highlight">如何破坏双亲委派机制？</a></li><li><a href="#有哪些破坏双亲委派模型的典型例子" class="table-of-contents__link toc-highlight">有哪些破坏双亲委派模型的典型例子？</a></li><li><a href="#说说spi-机制" class="table-of-contents__link toc-highlight">说说SPI 机制？</a></li><li><a href="#说说热部署" class="table-of-contents__link toc-highlight">说说热部署？</a></li><li><a href="#tomcat-的类加载机制了解吗" class="table-of-contents__link toc-highlight">Tomcat 的类加载机制了解吗？</a></li><li><a href="#你觉得应该怎么实现一个热部署功能" class="table-of-contents__link toc-highlight">你觉得应该怎么实现一个热部署功能？</a></li><li><a href="#说说解释执行和编译执行的区别补充" class="table-of-contents__link toc-highlight">说说解释执行和编译执行的区别（补充）</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Tutorial</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://x.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">X<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>