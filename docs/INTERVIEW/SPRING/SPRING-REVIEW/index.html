<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-SPRING/SPRING-REVIEW" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.8.1">
<title data-rh="true">SPRING-REVIEW | My Site</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://your-docusaurus-site.example.com/doc/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://your-docusaurus-site.example.com/doc/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://your-docusaurus-site.example.com/doc/docs/INTERVIEW/SPRING/SPRING-REVIEW"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="SPRING-REVIEW | My Site"><meta data-rh="true" name="description" content="SPRING-REVIEW"><meta data-rh="true" property="og:description" content="SPRING-REVIEW"><link data-rh="true" rel="icon" href="/doc/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://your-docusaurus-site.example.com/doc/docs/INTERVIEW/SPRING/SPRING-REVIEW"><link data-rh="true" rel="alternate" href="https://your-docusaurus-site.example.com/doc/docs/INTERVIEW/SPRING/SPRING-REVIEW" hreflang="en"><link data-rh="true" rel="alternate" href="https://your-docusaurus-site.example.com/doc/docs/INTERVIEW/SPRING/SPRING-REVIEW" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"SPRING-REVIEW","item":"https://your-docusaurus-site.example.com/doc/docs/INTERVIEW/SPRING/SPRING-REVIEW"}]}</script><link rel="alternate" type="application/rss+xml" href="/doc/blog/rss.xml" title="My Site RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/doc/blog/atom.xml" title="My Site Atom Feed"><link rel="stylesheet" href="/doc/assets/css/styles.8d5b4fe0.css">
<script src="/doc/assets/js/runtime~main.1f9c75d1.js" defer="defer"></script>
<script src="/doc/assets/js/main.01ab3953.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t="light";var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",e||t),document.documentElement.setAttribute("data-theme-choice",e||t)}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/doc/img/logo.svg"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/doc/"><div class="navbar__logo"><img src="/doc/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/doc/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">My Site</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/doc/docs/intro">Tutorial</a><a class="navbar__item navbar__link" href="/doc/blog">Blog</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="Switch between dark and light mode (currently system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/doc/docs/intro">Tutorial Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/doc/docs/category/tutorial---basics">Tutorial - Basics</a><button aria-label="Expand sidebar category &#x27;Tutorial - Basics&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/doc/docs/category/tutorial---extras">Tutorial - Extras</a><button aria-label="Expand sidebar category &#x27;Tutorial - Extras&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/doc/docs/JAVA/">java</a><button aria-label="Expand sidebar category &#x27;java&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/MQ">MQ</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/MYSQL/MYSQL-REVIEW">MYSQL</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/NGINX/NGINX-REVIEW">NGINX</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/intereview/redis">REDIS</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" href="/doc/docs/INTERVIEW/SPRING/SPRING-REVIEW">SPRING</a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/doc/docs/INTERVIEW/SPRING/SPRING-REVIEW">SPRING-REVIEW</a></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/doc/docs/tmp">tmp</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/分布式/分布式-REVIEW">分布式</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/微服务/微服务-REVIEW">微服务</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/doc/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">SPRING</span></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">SPRING-REVIEW</span></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>SPRING-REVIEW</h1></header><h2 class="anchor anchorWithStickyNavbar_LWe7" id="基础">基础<a href="#基础" class="hash-link" aria-label="Direct link to 基础" title="Direct link to 基础">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="spring是什么">Spring是什么？<a href="#spring是什么" class="hash-link" aria-label="Direct link to Spring是什么？" title="Direct link to Spring是什么？">​</a></h3>
<p>Spring 是一个 Java 后端开发框架，其最核心的作用是帮我们管理 Java 对象。
其最重要的特性就是** IoC**，也就是控制反转。以前我们要使用一个对象时，都要自己先 new 出来。但有了 Spring 之后，我们只需要告诉 Spring 我们需要什么对象，它就会自动帮我们创建好并注入到 Spring 容器当中。
比如我在一个 Service 类里需要用到 Dao 对象，只需要加个 @Autowired 注解，Spring 就会自动把 Dao 对象注入到 Spring 容器当中，这样就不需要我们手动去管理这些对象之间的依赖关系了。</p>
<p>另外，Spring 还提供了 AOP，也就是面向切面编程，在我们需要做一些通用功能的时候特别有用，比如说日志记录、权限校验、事务管理这些，我们不用在每个方法里都写重复的代码，直接用 AOP 就能统一处理。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="spring有哪些特性">Spring有哪些特性？<a href="#spring有哪些特性" class="hash-link" aria-label="Direct link to Spring有哪些特性？" title="Direct link to Spring有哪些特性？">​</a></h3>
<p>Spring 的特性还是挺多的，我按照在实际工作/学习中用得最多的几个来说吧。</p>
<p>首先最核心的就是 IoC 控制反转和 DI 依赖注入。这个我前面也提到了，就是 Spring 能帮我们管理对象的创建和依赖关系。</p>
<p>比如我写一个 UserService，需要用到 UserDao，以前得自己 new 一个 UserDao 出来，现在只要在 UserService 上加个 @Service 注解，在 UserDao 字段上加个 @Autowired，Spring 就会自动帮我们处理好这些依赖关系。</p>
<p>这样代码的耦合度就大大降低了，测试的时候也更容易 mock。</p>
<p>第二个就是 AOP 面向切面编程。这个在我们处理一些横切关注点的时候特别有用，比如说我们要给某些 Controller 方法都加上权限控制，如果没有 AOP 的话，每个方法都要写一遍加权代码，维护起来很麻烦。</p>
<p>用了 AOP 之后，我们只需要写一个切面类，定义好切点和通知，就能统一处理了。事务管理也是同样的道理，加个 @Transactional 注解就搞定了。</p>
<p>还有就是 Spring 对各种企业级功能的集成支持也特别好。比如数据库访问，不管我们用 JDBC、MyBatis-Plus 还是 Hibernate，Spring 都能很好地集成。消息队列、缓存、安全认证这些， Spring 都有对应的模块来支持。</p>
<p>另外 Spring 的配置也很灵活，既支持 XML 配置，也支持注解配置，现在我们基本都用注解了，写起来更简洁。Spring Boot 出来之后就更方便了，约定大于配置，很多东西都是开箱即用的</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="简单说一下什么是aop和ioc">简单说一下什么是AOP和IoC？<a href="#简单说一下什么是aop和ioc" class="hash-link" aria-label="Direct link to 简单说一下什么是AOP和IoC？" title="Direct link to 简单说一下什么是AOP和IoC？">​</a></h3>
<p>AOP 面向切面编程，简单点说就是把一些通用的功能从业务代码里抽取出来，统一处理。比如说技术派中的 @MdcDot 注解的作用是配合 AOP 在日志中加入 MDC 信息，方便进行日志追踪。
IoC 控制反转是一种设计思想，它的主要作用是将对象的创建和对象之间的调用过程交给 Spring 容器来管理。比如说在技术派项目当中，@PostConstruct 注解表明这个方法由 Spring 容器在 Bean 初始化完成后自动调用，我们不需要手动调用 init 方法。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="spring源码看过吗">Spring源码看过吗？<a href="#spring源码看过吗" class="hash-link" aria-label="Direct link to Spring源码看过吗？" title="Direct link to Spring源码看过吗？">​</a></h3>
<p>看过一些，主要是带着问题去看的，比如遇到一些技术难点或者想深入理解某个功能的时候。</p>
<p>我重点看过的是 IoC 容器的初始化过程，特别是 ApplicationContext 的启动流程。从 refresh() 方法开始，包括 Bean 的定义和加载、Bean 工厂的准备、Bean 的实例化和初始化这些关键步骤。
<img decoding="async" loading="lazy" alt="1756990366396" src="/doc/assets/images/1756990366396-186546fe7bc7e4c7d4ae825fdd6cdf87.png" width="1446" height="1414" class="img_ev3q">
看源码的时候发现 Spring 用了很多设计模式，比如工厂模式、单例模式、模板方法模式等等，这对我平时写代码也很有启发。</p>
<p>还有就是 Spring 的 Bean 生命周期，从 BeanDefinition 的创建到 Bean 的实例化、属性注入、初始化回调，再到最后的销毁，整个过程还是挺复杂的。看了源码之后对 @PostConstruct、@PreDestroy 这些注解的执行时机就更清楚了。</p>
<p>不过说实话，Spring 的源码确实比较难啃，涉及的概念和技术点太多了。我一般是结合一些技术博客和 Claude 一起看，这样理解起来会相对容易一些。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="spring有哪些模块呢">Spring有哪些模块呢？<a href="#spring有哪些模块呢" class="hash-link" aria-label="Direct link to Spring有哪些模块呢？" title="Direct link to Spring有哪些模块呢？">​</a></h3>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="spring有哪些常用注解呢">Spring有哪些常用注解呢？<a href="#spring有哪些常用注解呢" class="hash-link" aria-label="Direct link to Spring有哪些常用注解呢？" title="Direct link to Spring有哪些常用注解呢？">​</a></h3>
<p>首先是 Bean 管理相关的注解。@Component 是最基础的，用来标识一个类是 Spring 组件。像 @Service、@Repository、@Controller 这些都是 @Component 的特化版本，分别用在服务层、数据访问层和控制器层。</p>
<p>依赖注入方面，@Autowired 是用得最多的，可以标注在字段、setter 方法或者构造方法上。@Qualifier 在有多个同类型 Bean 的时候用来指定具体注入哪一个。@Resource 和 @Autowired 功能差不多，不过它是按名称注入的。</p>
<p>配置相关的注解也很常用。@Configuration 标识配置类，@Bean 用来定义 Bean，@Value 用来注入配置文件中的属性值。我们项目里的数据库连接信息、Redis 配置这些都是用 @Value 来注入的。@PropertySource 用来指定配置文件的位置。</p>
<p>@RequestMapping 及其变体@GetMapping、@PostMapping、@PutMapping、@DeleteMapping 用来映射 HTTP 请求。@PathVariable 获取路径参数，@RequestParam 获取请求参数，@RequestBody 接收 JSON 数据。</p>
<p>AOP 相关的注解，@Aspect 定义切面，@Pointcut 定义切点，@Before、@After、@Around 这些定义通知类型。</p>
<p>不过我们用得最多的还是@Transactional，基本上 Service 层需要保证事务原子性的方法都会加上这个注解。</p>
<p>还有一些 Spring Boot 特有的注解，比如 @SpringBootApplication 这个启动类注解，@ConditionalOnProperty 做条件装配，@EnableAutoConfiguration 开启自动配置等等。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="spring用了哪些设计模式">🌟Spring用了哪些设计模式？<a href="#spring用了哪些设计模式" class="hash-link" aria-label="Direct link to 🌟Spring用了哪些设计模式？" title="Direct link to 🌟Spring用了哪些设计模式？">​</a></h3>
<p>首先是工厂模式，这个在 Spring 里用得非常多。BeanFactory 就是一个典型的工厂，它负责创建和管理所有的 Bean 对象。我们平时用的 ApplicationContext 其实也是 BeanFactory 的一个实现。当我们通过 @Autowired 获取一个 Bean 的时候，底层就是通过工厂模式来创建和获取对象的。</p>
<p>单例模式也是 Spring 的默认行为。默认情况下，Spring 容器中的 Bean 都是单例的，整个应用中只会有一个实例。这样可以节省内存，提高性能。当然我们也可以通过 @Scope 注解来改变 Bean 的作用域，比如设置为 prototype 就是每次获取都创建新实例。</p>
<p>代理模式在 AOP 中用得特别多。Spring AOP 的底层实现就是基于动态代理的，对于实现了接口的类用 JDK 动态代理，没有实现接口的类用 CGLIB 代理。比如我们用 @Transactional 注解的时候，Spring 会为我们的类创建一个代理对象，在方法执行前后添加事务处理逻辑。</p>
<p>模板方法模式在 Spring 里也很常见，比如 JdbcTemplate。它定义了数据库操作的基本流程：获取连接、执行 SQL、处理结果、关闭连接，但是具体的 SQL 语句和结果处理逻辑由我们来实现。</p>
<p>观察者模式在 Spring 的事件机制中有所体现。我们可以通过 ApplicationEvent 和 ApplicationListener 来实现事件的发布和监听。比如用户注册成功后，我们可以发布一个用户注册事件，然后有多个监听器来处理后续的业务逻辑，比如发送邮件、记录日志等。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="spring如何实现单例模式">Spring如何实现单例模式？<a href="#spring如何实现单例模式" class="hash-link" aria-label="Direct link to Spring如何实现单例模式？" title="Direct link to Spring如何实现单例模式？">​</a></h3>
<p>传统的单例模式是在类的内部控制只能创建一个实例，比如用 private 构造方法加 static getInstance() 这种方式。但是 Spring 的单例是容器级别的，同一个 Bean 在整个 Spring 容器中只会有一个实例。</p>
<p>具体的实现机制是这样的：Spring 在启动的时候会把所有的 Bean 定义信息加载进来，然后在 DefaultSingletonBeanRegistry 这个类里面维护了一个叫 singletonObjects 的 ConcurrentHashMap，这个 Map 就是用来存储单例 Bean 的。key 是 Bean 的名称，value 就是 Bean 的实例对象。
<img decoding="async" loading="lazy" alt="1756991208878" src="/doc/assets/images/1756991208878-51c1dc737be30e21521f859a073780d4.png" width="2772" height="1606" class="img_ev3q">
当我们第一次获取某个 Bean 的时候，Spring 会先检查 singletonObjects 这个 Map 里面有没有这个 Bean，如果没有就会创建一个新的实例，然后放到 Map 里面。后面再获取同一个 Bean 的时候，直接从 Map 里面取就行了，这样就保证了单例。
<img decoding="async" loading="lazy" alt="1756991219390" src="/doc/assets/images/1756991219390-d9e89b74081720fd52fc705c6df809e0.png" width="1756" height="1520" class="img_ev3q">
还有一个细节就是 Spring 为了解决循环依赖的问题，还用了三级缓存。除了 singletonObjects 这个一级缓存，还有 earlySingletonObjects 二级缓存和 singletonFactories 三级缓存。这样即使有循环依赖，Spring 也能正确处理。
而且 Spring 的单例是线程安全的，因为用的是 ConcurrentHashMap，多线程访问不会有问题。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="spring容器和web容器之间的区别知道吗补充">Spring容器和Web容器之间的区别知道吗？（补充）<a href="#spring容器和web容器之间的区别知道吗补充" class="hash-link" aria-label="Direct link to Spring容器和Web容器之间的区别知道吗？（补充）" title="Direct link to Spring容器和Web容器之间的区别知道吗？（补充）">​</a></h3>
<p>首先从概念上来说，Spring 容器是一个 IoC 容器，主要负责管理 Java 对象的生命周期和依赖关系。而 Web 容器，比如 Tomcat、Jetty 这些，是用来运行 Web 应用的容器，负责处理 HTTP 请求和响应，管理 Servlet 的生命周期。</p>
<p>从功能上看，Spring 容器专注于业务逻辑层面的对象管理，比如我们的 Service、Dao、Controller 这些 Bean 都是由 Spring 容器来创建和管理的。而 Web 容器主要处理网络通信，比如接收 HTTP 请求、解析请求参数、调用相应的 Servlet，然后把响应返回给客户端。</p>
<p>在实际项目中，这两个容器是相辅相成的。我们的 Web 项目部署在 Tomcat 上的时候，Tomcat 会负责接收 HTTP 请求，然后把请求交给 DispatcherServlet 处理，而 DispatcherServlet 又会去 Spring 容器中查找相应的 Controller 来处理业务逻辑。
还有一个重要的区别是生命周期。Web 容器的生命周期跟 Web 应用程序的部署和卸载相关，而 Spring 容器的生命周期是在 Web 应用启动的时候初始化，应用关闭的时候销毁。</p>
<p>现在我们都用 Spring Boot 了，Spring Boot 内置了 Tomcat，把 Web 容器和 Spring 容器都整合在一起了，我们只需要运行一个 jar 包就可以了。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="ioc">IoC<a href="#ioc" class="hash-link" aria-label="Direct link to IoC" title="Direct link to IoC">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说一说什么是ioc">🌟说一说什么是IoC？<a href="#说一说什么是ioc" class="hash-link" aria-label="Direct link to 🌟说一说什么是IoC？" title="Direct link to 🌟说一说什么是IoC？">​</a></h3>
<p>IoC 的全称是 Inversion of Control，也就是控制反转。这里的“控制”指的是对象创建和依赖关系管理的控制权。
<img decoding="async" loading="lazy" alt="1756991356000" src="/doc/assets/images/1756991356000-6c9533e7a0674b8c167aa83d9246e019.png" width="1080" height="608" class="img_ev3q">
以前我们写代码的时候，如果 A 类需要用到 B 类，我们就在 A 类里面直接 new 一个 B 对象出来，这样 A 类就控制了 B 类对象的创建。
有了 IoC 之后，这个控制权就“反转”了，不再由 A 类来控制 B 对象的创建，而是交给外部的容器来管理。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="di和ioc的区别了解吗">DI和IoC的区别了解吗？<a href="#di和ioc的区别了解吗" class="hash-link" aria-label="Direct link to DI和IoC的区别了解吗？" title="Direct link to DI和IoC的区别了解吗？">​</a></h3>
<p>IoC 的思想是把对象创建和依赖关系的控制权由业务代码转移给 Spring 容器。这是一个比较抽象的概念，告诉我们应该怎么去设计系统架构。
而 DI，也就是依赖注入，它是实现 IoC 这种思想的具体技术手段。在 Spring 里，我们用 @Autowired 注解就是在使用 DI 的字段注入方式。
从实现角度来看，DI 除了字段注入，还有构造方法注入和 Setter 方法注入等方式。在做技术派项目的时候，我就尝试过构造方法注入的方式。
当然了，DI 并不是实现 IoC 的唯一方式，还有 Service Locator 模式，可以通过实现 ApplicationContextAware 接口来获取 Spring 容器中的 Bean。
之所以 ID 后成为 IoC 的首选实现方式，是因为代码更清晰、可读性更高。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么要使用-ioc-呢">为什么要使用 IoC 呢？<a href="#为什么要使用-ioc-呢" class="hash-link" aria-label="Direct link to 为什么要使用 IoC 呢？" title="Direct link to 为什么要使用 IoC 呢？">​</a></h3>
<p>在日常开发中，如果我们需要实现某一个功能，可能至少需要两个以上的对象来协助完成，在没有 Spring 之前，每个对象在需要它的合作对象时，需要自己 new 一个，比如说 A 要使用 B，A 就对 B 产生了依赖，也就是 A 和 B 之间存在了一种耦合关系。</p>
<p>有了 Spring 之后，创建 B 的工作交给了 Spring 来完成，Spring 创建好了 B 对象后就放到容器中，A 告诉 Spring 我需要 B，Spring 就从容器中取出 B 交给 A 来使用。</p>
<p>至于 B 是怎么来的，A 就不再关心了，Spring 容器想通过 newnew 创建 B 还是 new 创建 B，无所谓。</p>
<p>这就是 IoC 的好处，它降低了对象之间的耦合度，让每个对象只关注自己的业务实现，不关心其他对象是怎么创建的。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="能说一下ioc的实现机制吗">能说一下IoC的实现机制吗？<a href="#能说一下ioc的实现机制吗" class="hash-link" aria-label="Direct link to 能说一下IoC的实现机制吗？" title="Direct link to 能说一下IoC的实现机制吗？">​</a></h3>
<p>好的，Spring IoC 的实现机制还是比较复杂的，我尽量用比较通俗的方式来解释一下整个流程。
<img decoding="async" loading="lazy" alt="1756991499626" src="/doc/assets/images/1756991499626-b7b0d5136ae2c072cea9cb71bef4bfb5.png" width="1061" height="299" class="img_ev3q">
第一步是加载 Bean 的定义信息。Spring 会扫描我们配置的包路径，找到所有标注了 @Component、@Service、@Repository 这些注解的类，然后把这些类的元信息封装成 BeanDefinition 对象。</p>
<p>第二步是 Bean 工厂的准备。Spring 会创建一个 DefaultListableBeanFactory 作为 Bean 工厂来负责 Bean 的创建和管理。</p>
<p>第三步是 Bean 的实例化和初始化。这个过程比较复杂，Spring 会根据 BeanDefinition 来创建 Bean 实例。
<img decoding="async" loading="lazy" alt="1756991532733" src="/doc/assets/images/1756991532733-b3c305a3cd41575b82aa127556dbab53.png" width="3401" height="2308" class="img_ev3q">
对于单例 Bean，Spring 会先检查缓存中是否已经存在，如果不存在就创建新实例。创建实例的时候会通过反射调用构造方法，然后进行属性注入，最后执行初始化回调方法。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 简化的Bean创建流程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class AbstractBeanFactory {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected Object createBean(String beanName, BeanDefinition bd) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 1. 实例化前处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object bean = resolveBeforeInstantiation(beanName, bd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (bean != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return bean;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 2. 实际创建Bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return doCreateBean(beanName, bd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected Object doCreateBean(String beanName, BeanDefinition bd) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 2.1 实例化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object bean = createBeanInstance(beanName, bd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 2.2 属性填充（依赖注入）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        populateBean(beanName, bd, bean);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 2.3 初始化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object exposedObject = initializeBean(beanName, bean, bd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return exposedObject;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>依赖注入的实现主要是通过反射来完成的。比如我们用 @Autowired 标注了一个字段，Spring 在创建 Bean 的时候会扫描这个字段，然后从容器中找到对应类型的 Bean，通过反射的方式设置到这个字段上。
<img decoding="async" loading="lazy" alt="1756991577927" src="/doc/assets/images/1756991577927-81d6dc119cd5aeaa5a5c2c7fa2b56b43.png" width="2234" height="1684" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="你是怎么理解-spring-ioc-的">你是怎么理解 Spring IoC 的？<a href="#你是怎么理解-spring-ioc-的" class="hash-link" aria-label="Direct link to 你是怎么理解 Spring IoC 的？" title="Direct link to 你是怎么理解 Spring IoC 的？">​</a></h3>
<p>IoC 本质上一个超级工厂，这个工厂的产品就是各种 Bean 对象。</p>
<p>我们通过 @Component、@Service 这些注解告诉工厂：“我要生产什么样的产品，这个产品有什么特性，需要什么原材料”。</p>
<p>然后工厂里各种生产线，在 Spring 中就是各种 BeanPostProcessor。比如 AutowiredAnnotationBeanPostProcessor 专门负责处理 @Autowired 注解。</p>
<p>工厂里还有各种缓存机制用来存放产品，比如说 singletonObjects 是成品仓库，存放完工的单例 Bean；earlySingletonObjects 是半成品仓库，用来解决循环依赖问题。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Spring单例Bean注册表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DefaultSingletonBeanRegistry {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 一级缓存：完成初始化的单例Bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 二级缓存：早期暴露的单例Bean（解决循环依赖）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;&gt;(16);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 三级缓存：单例Bean工厂</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;&gt;(16);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object getSingleton(String beanName) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object singletonObject = this.singletonObjects.get(beanName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (singletonObject == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            singletonObject = this.earlySingletonObjects.get(beanName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (singletonObject == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (singletonFactory != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    singletonObject = singletonFactory.getObject();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    this.earlySingletonObjects.put(beanName, singletonObject);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    this.singletonFactories.remove(beanName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return singletonObject;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="能手写一个简单的-ioc-容器吗">能手写一个简单的 IoC 容器吗？<a href="#能手写一个简单的-ioc-容器吗" class="hash-link" aria-label="Direct link to 能手写一个简单的 IoC 容器吗？" title="Direct link to 能手写一个简单的 IoC 容器吗？">​</a></h3>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说beanfactory和applicantcontext的区别">说说BeanFactory和ApplicantContext的区别?<a href="#说说beanfactory和applicantcontext的区别" class="hash-link" aria-label="Direct link to 说说BeanFactory和ApplicantContext的区别?" title="Direct link to 说说BeanFactory和ApplicantContext的区别?">​</a></h3>
<p>BeanFactory 算是 Spring 的“心脏”，而 ApplicantContext 可以说是 Spring 的完整“身躯”。</p>
<p>BeanFactory 提供了最基本的 IoC 能力。它就像是一个 Bean 工厂，负责 Bean 的创建和管理。他采用的是懒加载的方式，也就是说只有当我们真正去获取某个 Bean 的时候，它才会去创建这个 Bean。
<img decoding="async" loading="lazy" alt="1756992053985" src="/doc/assets/images/1756992053985-0d920c55562d8f245e4321fa1df4a578.png" width="1227" height="816" class="img_ev3q">
它最主要的方法就是 getBean()，负责从容器中返回特定名称或者类型的 Bean 实例。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class BeanFactoryExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建 BeanFactory</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 手动注册 Bean 定义</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BeanDefinition beanDefinition = new RootBeanDefinition(UserService.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        beanFactory.registerBeanDefinition(&quot;userService&quot;, beanDefinition);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 懒加载：此时才创建 Bean 实例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        UserService userService = beanFactory.getBean(&quot;userService&quot;, UserService.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>ApplicationContext 是 BeanFactory 的子接口，在 BeanFactory 的基础上扩展了很多企业级的功能。它不仅包含了 BeanFactory 的所有功能，还提供了国际化支持、事件发布机制、AOP、JDBC、ORM 框架集成等等。
<img decoding="async" loading="lazy" alt="1756992118423" src="/doc/assets/images/1756992118423-fa85bf55fc1b9d13c9a0dbfcc24fe531.png" width="1140" height="792" class="img_ev3q"></p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Configuration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class AppConfig {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public UserService userService() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new UserService();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ApplicationContextExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建 ApplicationContext，启动时就创建所有 Bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 获取 Bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        UserService userService = context.getBean(UserService.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 发布事件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        context.publishEvent(new CustomEvent(&quot;Hello World&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>从使用场景来说，实际开发中用得最多的是 ApplicationContext。像 AnnotationConfigApplicationContext、WebApplicationContext 这些都是 ApplicationContext 的实现类。</p>
<p>另外一个重要的区别是生命周期管理。ApplicationContext 会自动调用 Bean 的初始化和销毁方法，而 BeanFactory 需要我们手动管理。</p>
<p>在 Spring Boot 项目中，我们可以通过 @Autowired 注入 ApplicationContext，或者通过实现 ApplicationContextAware 接口来获取 ApplicationContext。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="项目启动时spring的ioc会做什么">🌟项目启动时Spring的IoC会做什么？<a href="#项目启动时spring的ioc会做什么" class="hash-link" aria-label="Direct link to 🌟项目启动时Spring的IoC会做什么？" title="Direct link to 🌟项目启动时Spring的IoC会做什么？">​</a></h3>
<p>第一件事是扫描和注册 Bean。IoC 容器会根据我们的配置，比如 @ComponentScan 指定的包路径，去扫描所有标注了 @Component、@Service、@Controller 这些注解的类。然后把这些类的元信息包装成 BeanDefinition 对象，注册到容器的 BeanDefinitionRegistry 中。这个阶段只是收集信息，还没有真正创建对象。
<img decoding="async" loading="lazy" alt="1756992157486" src="/doc/assets/images/1756992157486-a515f022b3c2c90926c91eb010dd2607.png" width="1140" height="523" class="img_ev3q">
第二件事是 Bean 的实例化和注入。这是最核心的过程，IoC 容器会按照依赖关系的顺序开始创建 Bean 实例。对于单例 Bean，容器会通过反射调用构造方法创建实例，然后进行属性注入，最后执行初始化回调方法。
<img decoding="async" loading="lazy" alt="1756992176287" src="/doc/assets/images/1756992176287-bedc0fabff47db926763477b06509b7f.png" width="1870" height="914" class="img_ev3q">
在依赖注入时，容器会根据 @Autowired、@Resource 这些注解，把相应的依赖对象注入到目标 Bean 中。比如 UserService 需要 UserDao，容器就会把 UserDao 的实例注入到 UserService 中。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说spring的bean实例化方式">说说Spring的Bean实例化方式？<a href="#说说spring的bean实例化方式" class="hash-link" aria-label="Direct link to 说说Spring的Bean实例化方式？" title="Direct link to 说说Spring的Bean实例化方式？">​</a></h3>
<p>Spring 提供了 4 种方式来实例化 Bean，以满足不同场景下的需求。</p>
<p>第一种是通过构造方法实例化，这是最常用的方式。当我们用 @Component、@Service 这些注解标注类的时候，Spring 默认通过无参构造器来创建实例的。如果类只有一个有参构造方法，Spring 会自动进行构造方法注入。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Service</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class UserService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private UserDao userDao;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public UserService(UserDao userDao) {  // 构造方法注入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.userDao = userDao;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>第二种是通过静态工厂方法实例化。有时候对象的创建比较复杂，我们会写一个静态工厂方法来创建，然后用 @Bean 注解来标注这个方法。Spring 会调用这个静态方法来获取 Bean 实例。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Configuration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class AppConfig {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static DataSource createDataSource() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 复杂的DataSource创建逻辑</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new HikariDataSource();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>第三种是通过实例工厂方法实例化。这种方式是先创建工厂对象，然后通过工厂对象的方法来创建Bean：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Configuration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class AppConfig {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ConnectionFactory connectionFactory() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new ConnectionFactory();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Connection createConnection(ConnectionFactory factory) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return factory.createConnection();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>第四种是通过 FactoryBean 接口实例化。这是 Spring 提供的一个特殊接口，当我们需要创建复杂对象的时候特别有用：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Component</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class MyFactoryBean implements FactoryBean&lt;MyObject&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public MyObject getObject() throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 复杂的对象创建逻辑</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new MyObject();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Class&lt;?&gt; getObjectType() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return MyObject.class;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>在实际工作中，用得最多的还是构造方法实例化，因为简单直接。工厂方法一般用在需要复杂初始化逻辑的场景，比如数据库连接池、消息队列连接这些。FactoryBean 主要是在框架开发或者需要动态创建对象的时候使用。</p>
<p>Spring 在实例化的时候会根据 Bean 的定义自动选择合适的方式，我们作为开发者主要是通过注解和配置来告诉 Spring 应该怎么创建对象。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="你是怎么理解bean的">你是怎么理解Bean的？<a href="#你是怎么理解bean的" class="hash-link" aria-label="Direct link to 你是怎么理解Bean的？" title="Direct link to 你是怎么理解Bean的？">​</a></h3>
<p>在我看来，Bean 本质上就是由 Spring 容器管理的 Java 对象，但它和普通的 Java 对象有很大区别。普通的 Java 对象我们是通过 new 关键字创建的。而 Bean 是交给 Spring 容器来管理的，从创建到销毁都由容器负责。</p>
<p>从实际使用的角度来说，我们项目里的 Service、Dao、Controller 这些都是 Bean。比如 UserService 被标注了 @Service 注解，它就成了一个 Bean，Spring 会自动创建它的实例，管理它的依赖关系，当其他地方需要用到 UserService 的时候，Spring 就会把这个实例注入进去。</p>
<p>这种依赖注入的方式让对象之间的关系变得松耦合。</p>
<p>Spring 提供了多种 Bean 的配置方式，基于注解的方式是最常用的。
<img decoding="async" loading="lazy" alt="1756992303319" src="/doc/assets/images/1756992303319-18dfd15e31fb843a791aa34645758b54.png" width="656" height="338" class="img_ev3q">
基于 XML 配置的方式在 Spring Boot 项目中已经不怎么用了。Java 配置类的方式则可以用来解决一些比较复杂的场景，比如说主从数据源，我们可以用 @Primary 注解标注主数据源，用 @Qualifier 来指定备用数据源。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Configuration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class AppConfig {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Primary  // 主要候选者</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public DataSource primaryDataSource() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new HikariDataSource();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Qualifier(&quot;secondary&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public DataSource secondaryDataSource() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new BasicDataSource();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>那在使用的时候，当我们直接用 @Autowired 注解注入 DataSource 时，Spring 默认会使用 HikariDataSource；当加上 @Qualifier(&quot;secondary&quot;) 注解时，Spring 则会注入 BasicDataSource。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Autowired</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private DataSource dataSource; // 会注入 primaryDataSource（因为有 @Primary）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Autowired</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Qualifier(&quot;secondary&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private DataSource secondaryDataSource;</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="component-和-bean-有什么区别">@Component 和 @Bean 有什么区别？<a href="#component-和-bean-有什么区别" class="hash-link" aria-label="Direct link to @Component 和 @Bean 有什么区别？" title="Direct link to @Component 和 @Bean 有什么区别？">​</a></h3>
<p>首先从使用上来说，@Component 是标注在类上的，而 @Bean 是标注在方法上的。@Component 告诉 Spring 这个类是一个组件，请把它注册为 Bean，而 @Bean 则告诉 Spring 请将这个方法返回的对象注册为 Bean。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Component  // Spring自动创建UserService实例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class UserService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Autowired</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private UserDao userDao;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Configuration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class AppConfig {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean  // 我们手动创建DataSource实例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public DataSource dataSource() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        HikariDataSource ds = new HikariDataSource();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ds.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ds.setUsername(&quot;root&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ds.setPassword(&quot;123456&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ds;  // 返回给Spring管理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>从控制权的角度来说，@Component 是由 Spring 自动创建和管理的。</p>
<p>而 @Bean 则是由我们手动创建的，然后再交给 Spring 管理，我们对对象的创建过程有完全的控制权。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="能说一下bean的生命周期吗">🌟能说一下Bean的生命周期吗？<a href="#能说一下bean的生命周期吗" class="hash-link" aria-label="Direct link to 🌟能说一下Bean的生命周期吗？" title="Direct link to 🌟能说一下Bean的生命周期吗？">​</a></h3>
<p>推荐阅读：三分恶：Spring Bean 生命周期，好像人的一生
Bean 的生命周期可以分为 5 个主要阶段，我按照实际的执行顺序来说一下。
实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 使用中 -&gt; 销毁</p>
<p>第一个阶段是实例化。Spring 容器会根据 BeanDefinition，通过反射调用 Bean 的构造方法创建对象实例。如果有多个构造方法，Spring 会根据依赖注入的规则选择合适的构造方法。
<img decoding="async" loading="lazy" alt="1756992508308" src="/doc/assets/images/1756992508308-a747c1e4ec71bc8f3d99de2a1d32995e.png" width="1364" height="1062" class="img_ev3q">
第二阶段是属性赋值。这个阶段 Spring 会给 Bean 的属性赋值，包括通过 @Autowired、@Resource 这些注解注入的依赖对象，以及通过 @Value 注入的配置值。
第三阶段是初始化。这个阶段会依次执行：
@PostConstruct 标注的方法
InitializingBean 接口的 afterPropertiesSet 方法
通过 @Bean 的 initMethod 指定的初始化方法
<img decoding="async" loading="lazy" alt="1756992539719" src="/doc/assets/images/1756992539719-1e4be2cff40e6975cab209ff68d0afc9.png" width="1338" height="814" class="img_ev3q">
我在项目中经常用 @PostConstruct 来做一些初始化工作，比如缓存预加载、DB 配置等等。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// CategoryServiceImpl中的缓存初始化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@PostConstruct</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void init() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    categoryCaches = CacheBuilder.newBuilder().maximumSize(300).build(new CacheLoader&lt;Long, CategoryDTO&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public CategoryDTO load(@NotNull Long categoryId) throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            CategoryDO category = categoryDao.getById(categoryId);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// DynamicConfigContainer中的配置初始化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@PostConstruct</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void init() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    cache = Maps.newHashMap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bindBeansFromLocalCache(&quot;dbConfig&quot;, cache);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>初始化后，Spring 还会调用所有注册的 BeanPostProcessor 后置处理方法。这个阶段经常用来创建代理对象，比如 AOP 代理。</p>
<p>第五阶段是使用 Bean。比如我们的 Controller 调用 Service，Service 调用 DAO。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// UserController中的使用示例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Autowired</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private UserService userService;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@GetMapping(&quot;/users/{id}&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public UserDTO getUser(@PathVariable Long id) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return userService.getUserById(id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// UserService中的使用示例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Autowired</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private UserDao userDao;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public UserDTO getUserById(Long id) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return userDao.getById(id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// UserDao中的使用示例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Autowired</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private JdbcTemplate jdbcTemplate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public UserDTO getById(Long id) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String sql = &quot;SELECT * FROM users WHERE id = ?&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return jdbcTemplate.queryForObject(sql, new Object[]{id}, new UserRowMapper());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>最后是销毁阶段。当容器关闭或者 Bean 被移除的时候，会依次执行：
@PreDestroy 标注的方法
DisposableBean 接口的 destroy 方法
通过 @Bean 的 destroyMethod 指定的销毁方法</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="aware-类型的接口有什么作用">Aware 类型的接口有什么作用？<a href="#aware-类型的接口有什么作用" class="hash-link" aria-label="Direct link to Aware 类型的接口有什么作用？" title="Direct link to Aware 类型的接口有什么作用？">​</a></h3>
<p>Aware 接口在 Spring 中是一个很有意思的设计，它们的作用是让 Bean 能够感知到 Spring 容器的一些内部组件。</p>
<p>从设计理念来说，Aware 接口实现了一种“回调”机制。正常情况下，Bean 不应该直接依赖 Spring 容器，这样可以保持代码的独立性。但有些时候，Bean 确实需要获取容器的一些信息或者组件，Aware 接口就提供了这样一个能力。</p>
<p>我最常用的 Aware 接口是 ApplicationContextAware，它可以让 Bean 获取到 ApplicationContext 容器本身。
在技术派项目中，我就通过实现 ApplicationContextAware 和 EnvironmentAware 接口封装了一个 SpringUtil 工具类，通过 getBean 和 getProperty 方法来获取 Bean 和配置属性。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 静态方法获取Bean，方便在非Spring管理的类中使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return context.getBean(clazz);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 获取配置属性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static String getProperty(String key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return environment.getProperty(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如果配置了-init-method-和-destroy-methodspring-会在什么时候调用其配置的方法">如果配置了 init-method 和 destroy-method，Spring 会在什么时候调用其配置的方法？<a href="#如果配置了-init-method-和-destroy-methodspring-会在什么时候调用其配置的方法" class="hash-link" aria-label="Direct link to 如果配置了 init-method 和 destroy-method，Spring 会在什么时候调用其配置的方法？" title="Direct link to 如果配置了 init-method 和 destroy-method，Spring 会在什么时候调用其配置的方法？">​</a></h3>
<p>init-method 指定的初始化方法会在 Bean 的初始化阶段被调用，具体的执行顺序是：
先执行 @PostConstruct 标注的方法
然后执行 InitializingBean 接口的 afterPropertiesSet() 方法
最后再执行 init-method 指定的方法
也就是说，init-method 是在所有其他初始化方法之后执行的。
destroy-method 会在 Bean 销毁阶段被调用。
不过在实际开发中，通常用 @PostConstruct 和 @PreDestroy 就够了，它们更简洁。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么idea不推荐使用autowired注解注入bean">为什么IDEA不推荐使用@Autowired注解注入Bean？<a href="#为什么idea不推荐使用autowired注解注入bean" class="hash-link" aria-label="Direct link to 为什么IDEA不推荐使用@Autowired注解注入Bean？" title="Direct link to 为什么IDEA不推荐使用@Autowired注解注入Bean？">​</a></h3>
<p>主要有几个原因。</p>
<p>第一个是字段注入不利于单元测试。字段注入需要使用反射或 Spring 容器才能注入依赖，测试更复杂；而构造方法注入可以直接通过构造方法传入 Mock 对象，测试起来更简单。
第二个是字段注入会隐藏循环依赖问题，而构造方法注入会在项目启动时就去检查依赖关系，能更早发现问题。</p>
<p>第三个是构造方法注入可以使用 final 字段确保依赖在对象创建时就被初始化，避免了后续修改的风险。
在技术派项目中，我们已经在使用构造方法注入的方式来管理依赖关系。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="autowired-和-resource-注解的区别">@Autowired 和 @Resource 注解的区别？<a href="#autowired-和-resource-注解的区别" class="hash-link" aria-label="Direct link to @Autowired 和 @Resource 注解的区别？" title="Direct link to @Autowired 和 @Resource 注解的区别？">​</a></h3>
<p>首先从来源上说，@Autowired 是 Spring 框架提供的注解，而 @Resource 是 Java EE 标准提供的注解。换句话说，@Resource 是 JDK 自带的，而 @Autowired 是 Spring 特有的。</p>
<p>虽然 IDEA 不推荐使用 @Autowired，但对 @Resource 注解却没有任何提示。
从注入方式上说，@Autowired 默认按照类型，也就是 byType 进行注入，而 @Resource 默认按照名称，也就是 byName 进行注入。</p>
<p>当容器中存在多个相同类型的 Bean， 比如说有两个 UserRepository 的实现类，直接用 @Autowired 注入 UserRepository 时就会报错，因为 Spring 容器不知道该注入哪个实现类。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Component</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class UserRepository21 implements UserRepository2 {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Component</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class UserRepository22 implements UserRepository2 {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Component</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class UserService2 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Autowired</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private UserRepository2 userRepository; // 冲突</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>这时候，有两种解决方案，第一种是使用 @Autowired + @Qualifier 指定具体的 Bean 名称来解决冲突。
第二种是使用 @Resource 注解按名称进行注入。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="autowired的实现原理了解吗">@Autowired的实现原理了解吗？<a href="#autowired的实现原理了解吗" class="hash-link" aria-label="Direct link to @Autowired的实现原理了解吗？" title="Direct link to @Autowired的实现原理了解吗？">​</a></h3>
<p>@Autowired 是 Spring 实现依赖注入的核心注解，其实现原理基于反射机制和 BeanPostProcessor 接口。</p>
<p>整个过程分为两个主要阶段。第一个阶段是依赖收集阶段，发生在 Bean 实例化之后、属性赋值之前。Autowired 的 Processor 会扫描 Bean 的所有字段、方法和构造方法，找出标注了 @Autowired 注解的地方，然后把这些信息封装成 Injection 元数据对象缓存起来。这个过程用到了大量的反射操作，需要分析类的结构、注解信息等等。
<img decoding="async" loading="lazy" alt="1756994077870" src="/doc/assets/images/1756994077870-31c500b5a67632b6e490f293cbf87513.png" width="6003" height="2092" class="img_ev3q"></p>
<p>第二个阶段是依赖注入阶段，Spring 会取出之前缓存的 Injection 元数据对象，然后逐个处理每个注入点。对于每个 @Autowired 标注的字段或方法，Spring 会根据类型去容器中查找匹配的 Bean。</p>
<p>在具体的注入过程中，Spring 会使用反射来设置字段的值或者调用 setter 方法。比如对于字段注入，会调用 Field.set() 方法；对于 setter 注入，会调用 Method.invoke() 方法。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是自动装配">什么是自动装配？<a href="#什么是自动装配" class="hash-link" aria-label="Direct link to 什么是自动装配？" title="Direct link to 什么是自动装配？">​</a></h3>
<p>自动装配的本质就是让 Spring 容器自动帮我们完成 Bean 之间的依赖关系注入，而不需要我们手动去指定每个依赖。简单来说，就是“我们不用告诉 Spring 具体怎么注入，Spring 自己会想办法找到合适的 Bean 注入进来”。</p>
<p>自动装配的工作原理简单来说就是，Spring 容器在启动时自动扫描 @ComponentScan 指定包路径下的所有类，然后根据类上的注解，比如 @Autowired、@Resource 等，来判断哪些 Bean 需要被自动装配。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Configuration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@ComponentScan(&quot;com.github.paicoding.forum.service&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@MapperScan(basePackages = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;com.github.paicoding.forum.service.article.repository.mapper&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;com.github.paicoding.forum.service.user.repository.mapper&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ... 更多包路径</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ServiceAutoConfig {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Spring自动扫描指定包下的所有组件并注册为Bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>之后分析每个 Bean 的依赖关系，在创建 Bean 的时候，根据装配规则自动找到合适的依赖 Bean，最后根据反射将这些依赖注入到目标 Bean 中。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="spring提供了哪几种自动装配类型">Spring提供了哪几种自动装配类型？<a href="#spring提供了哪几种自动装配类型" class="hash-link" aria-label="Direct link to Spring提供了哪几种自动装配类型？" title="Direct link to Spring提供了哪几种自动装配类型？">​</a></h3>
<p>Spring 的自动装配方式有好几种，在 XML 配置时代，主要有 byName、byType、constructor 和 autodetect 四种方式。
到了注解驱动时代，用得最多的是 @Autowired 注解，默认按照类型装配。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Service</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class UserService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Autowired  // 按类型自动装配</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private UserRepository userRepository;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>其次还有 @Resource 注解，它默认按照名称装配，如果找不到对应名称的 Bean，就会按类型装配。</p>
<p>Spring Boot 的自动装配还有一套更高级的机制，通过 @EnableAutoConfiguration 和各种 @Conditional 注解来实现，这个是框架级别的自动装配，会根据 classpath 中的类和配置来自动配置 Bean。
<img decoding="async" loading="lazy" alt="1756994778032" src="/doc/assets/images/1756994778032-59def0b20e16968aca554bc968789da3.png" width="791" height="551" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="bean的作用域有哪些">Bean的作用域有哪些?<a href="#bean的作用域有哪些" class="hash-link" aria-label="Direct link to Bean的作用域有哪些?" title="Direct link to Bean的作用域有哪些?">​</a></h3>
<p>Bean 的作用域决定了 Bean 实例的生命周期和创建策略，singleton 是默认的作用域。整个 Spring 容器中只会有一个 Bean 实例。不管在多少个地方注入这个 Bean，拿到的都是同一个对象。</p>
<p>生命周期和 Spring 容器相同，容器启动时创建，容器销毁时销毁。</p>
<p>实际开发中，像 Service、Dao 这些业务组件基本都是单例的，因为单例既能节省内存，又能提高性能。</p>
<p>当把 scope 设置为 prototype 时，每次从容器中获取 Bean 的时候都会创建一个新的实例。</p>
<p>当需要处理一些有状态的 Bean 时会用到 prototype，比如每个订单处理器需要维护不同的状态信息。</p>
<p>需要注意的是，在 singleton Bean 中注入 prototype Bean 时要小心，因为 singleton Bean 只创建一次，所以 prototype Bean 也只会注入一次。这时候可以用 @Lookup 注解或者 ApplicationContext 来动态获取。</p>
<p>除了 singleton 和 prototype，Spring 还支持其他作用域，比如 request、session、application 和 websocket。
如果作用于是 request，表示在 Web 应用中，每个 HTTP 请求都会创建一个新的 Bean 实例，请求结束后 Bean 就被销毁。
如果作用于是 session，表示在 Web 应用中，每个 HTTP 会话都会创建一个新的 Bean 实例，会话结束后 Bean 被销毁。
application 作用域表示在整个应用中只有一个 Bean 实例，类似于 singleton，但它的生命周期与 ServletContext 绑定。
websocket 作用域表示在 WebSocket 会话中每个连接都有自己的 Bean 实例。WebSocket 连接建立时创建，连接关闭时销毁。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="spring中的单例bean会存在线程安全问题吗">Spring中的单例Bean会存在线程安全问题吗？<a href="#spring中的单例bean会存在线程安全问题吗" class="hash-link" aria-label="Direct link to Spring中的单例Bean会存在线程安全问题吗？" title="Direct link to Spring中的单例Bean会存在线程安全问题吗？">​</a></h3>
<p>首先要明确一点。Spring 容器本身保证了 Bean 创建过程的线程安全，也就是说不会出现多个线程同时创建同一个单例 Bean 的情况。但是 Bean 创建完成后的使用过程，Spring 就不管了。</p>
<p>换句话说，单例 Bean 在被创建后，如果它的内部状态是可变的，那么在多线程环境下就可能会出现线程安全问题。
比如说在技术派项目中，有一个敏感词过滤的 Bean，我们就需要使用 volatile 关键字来保证多线程环境下的可见性。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="单例bean的线程安全问题怎么解决呢">单例Bean的线程安全问题怎么解决呢？<a href="#单例bean的线程安全问题怎么解决呢" class="hash-link" aria-label="Direct link to 单例Bean的线程安全问题怎么解决呢？" title="Direct link to 单例Bean的线程安全问题怎么解决呢？">​</a></h3>
<p>第一种，使用局部变量，也就是使用无状态的单例 Bean，把所有状态都通过方法参数传递：
第二种，当确实需要维护线程相关的状态时，可以使用 ThreadLocal 来保存状态。ThreadLocal 可以保证每个线程都有自己的变量副本，互不干扰。
第三种，如果需要缓存数据或者计数，使用 JUC 包下的线程安全类，比如说 AtomicInteger、ConcurrentHashMap、CopyOnWriteArrayList 等。
第四种，对于复杂的状态操作，可以使用 synchronized 或 Lock：
第五种，如果 Bean 确实需要维护状态，可以考虑将其改为 prototype 作用域，这样每次注入都会创建一个新的实例，避免了多线程共享同一个实例的问题。
或者使用 request 作用域，这样每个 HTTP 请求都会创建一个新的实例。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是循环依赖">什么是循环依赖?<a href="#什么是循环依赖" class="hash-link" aria-label="Direct link to 什么是循环依赖?" title="Direct link to 什么是循环依赖?">​</a></h3>
<p>简单来说就是两个或多个 Bean 相互依赖，比如说 A 依赖 B，B 依赖 A，或者 C 依赖 C，就成了循环依赖。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="spring怎么解决循环依赖呢">🌟Spring怎么解决循环依赖呢？<a href="#spring怎么解决循环依赖呢" class="hash-link" aria-label="Direct link to 🌟Spring怎么解决循环依赖呢？" title="Direct link to 🌟Spring怎么解决循环依赖呢？">​</a></h3>
<p>Spring 通过三级缓存机制来解决循环依赖：</p>
<p>一级缓存：存放完全初始化好的单例 Bean。
二级缓存：存放提前暴露的 Bean，实例化完成，但未初始化完成。
三级缓存：存放 Bean 工厂，用于生成提前暴露的 Bean。
<img decoding="async" loading="lazy" alt="1756995414693" src="/doc/assets/images/1756995414693-541b6ecc3d8cbf8f05eb0153b6e14ed8.png" width="1157" height="415" class="img_ev3q">
以 A、B 两个类发生循环依赖为例：</p>
<p>第 1 步：开始创建 Bean A。</p>
<p>Spring 调用 A 的构造方法，创建 A 的实例。此时 A 对象已存在，但 b属性还是 null。
将 A 的对象工厂放入三级缓存。
开始进行 A 的属性注入。
<img decoding="async" loading="lazy" alt="1756995638996" src="/doc/assets/images/1756995638996-124d5579d1579e38b4ad71f16c7645a1.png" width="939" height="438" class="img_ev3q">
第 2 步：A 需要注入 B，开始创建 Bean B。</p>
<p>发现需要 B，但 B 还不存在，所以开始创建 B。
调用 B 的构造方法，创建 B 的实例。此时 B 对象已存在，但 a 属性还是 null。
将 B 的对象工厂放入三级缓存。
开始进行 B 的属性注入。</p>
<p>第 3 步：B 需要注入 A，从缓存中获取 A。</p>
<p>B 需要注入 A，先从一级缓存找 A，没找到。
再从二级缓存找 A，也没找到。
最后从三级缓存找 A，找到了 A 的对象工厂。
调用 A 的对象工厂得到 A 的实例。这时 A 已经实例化了，虽然还没完全初始化。
将 A 从三级缓存移到二级缓存。
B 拿到 A 的引用，完成属性注入。</p>
<p><img decoding="async" loading="lazy" alt="1756995693541" src="/doc/assets/images/1756995693541-7f7b68515cee02ea59a2886dacd1d396.png" width="877" height="421" class="img_ev3q">
第 4 步：B 完成初始化。</p>
<p>B 的属性注入完成，执行 @PostConstruct 等初始化逻辑。
B 完全创建完成，从三级缓存移除，放入一级缓存。</p>
<p>第 5 步：A 完成初始化。</p>
<p>回到 A 的创建过程，A 拿到完整的 B 实例，完成属性注入。
A 执行初始化逻辑，创建完成。
A 从二级缓存移除，放入一级缓存。
<img decoding="async" loading="lazy" alt="1756995713675" src="/doc/assets/images/1756995713675-1516ae681947ab8097f43fc1c76625bb.png" width="817" height="472" class="img_ev3q"></p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 模拟Spring的解决过程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class CircularDependencyDemo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 三级缓存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Map&lt;String, Object&gt; singletonObjects = new HashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Map&lt;String, ObjectFactory&gt; singletonFactories = new HashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object getBean(String beanName) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 先从一级缓存获取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object bean = singletonObjects.get(beanName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (bean != null) return bean;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 再从二级缓存获取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bean = earlySingletonObjects.get(beanName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (bean != null) return bean;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 最后从三级缓存获取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ObjectFactory factory = singletonFactories.get(beanName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (factory != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            bean = factory.getObject();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            earlySingletonObjects.put(beanName, bean);  // 移到二级缓存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            singletonFactories.remove(beanName);        // 从三级缓存移除</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return bean;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="哪些情况下spring无法解决循环依赖">哪些情况下Spring无法解决循环依赖？<a href="#哪些情况下spring无法解决循环依赖" class="hash-link" aria-label="Direct link to 哪些情况下Spring无法解决循环依赖？" title="Direct link to 哪些情况下Spring无法解决循环依赖？">​</a></h3>
<p>Spring 虽然能解决大部分循环依赖问题，但确实有几种情况是无法处理的，我来详细说说。</p>
<p>第一种，构造方法的循环依赖，这种情况 Spring 会直接抛出 BeanCurrentlyInCreationException 异常。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Component</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class A {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private B b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public A(B b) {  // 构造方法注入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.b = b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Component</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class B {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private A a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public B(A a) {  // 构造方法注入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.a = a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>因为构造方法注入发生在实例化阶段，创建 A 的时候必须先有 B，但创建 B又必须先有 A，这时候两个对象都还没创建出来，无法提前暴露到缓存中。</p>
<p>第二种，prototype 作用域的循环依赖。prototype 作用域的 Bean 每次获取都会创建新实例，Spring 无法缓存这些实例，所以也无法解决循环依赖。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么需要三级缓存而不是两级">为什么需要三级缓存而不是两级？<a href="#为什么需要三级缓存而不是两级" class="hash-link" aria-label="Direct link to 为什么需要三级缓存而不是两级？" title="Direct link to 为什么需要三级缓存而不是两级？">​</a></h3>
<p>Spring 设计三级缓存主要是为了解决 AOP 代理的问题。</p>
<p>我举个具体的例子来说明一下。假设我们有 A 和 B 两个类相互依赖，A 的某个方法上面还标注了 @Transactional 注解，这意味着 A 最终需要被 Spring 创建成一个代理对象。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Component</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class A {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Autowired</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private B b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Transactional  // A需要被AOP代理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void doSomething() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 业务逻辑</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Component</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class B {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Autowired</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private A a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>如果只有二级缓存的话，当创建 A 的时候，我们需要把 A 的原始对象提前放到缓存里面，然后 B 在创建的时候从缓存中拿到 A 的原始对象。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 假设只有两级缓存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Map&lt;String, Object&gt; singletonObjects = new HashMap&lt;&gt;();     // 完整Bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;&gt;(); // 半成品Bean</span><br></span></code></pre></div></div>
<p>但是问题来了，A 完成初始化后，由于有 @Transactional 注解，Spring 会把 A 包装成一个代理对象放到容器中。这样就出现了一个很严重的问题：B 里面持有的是 A 的原始对象，而容器中存的是 A 的代理对象，同一个 Bean 居然有两个不同的实例，这肯定是不对的。
<img decoding="async" loading="lazy" alt="1756996021967" src="/doc/assets/images/1756996021967-bc4e0170b99924f8def0546054fc6fcd.png" width="1009" height="129" class="img_ev3q"></p>
<p>三级缓存就是为了解决这个问题而设计的。三级缓存里面存放的不是 Bean 的实例，而是一个对象工厂，这是一个函数式接口。</p>
<p>当 B 需要 A 的时候，会调用这个对象工厂的 getObject 方法，这个方法里面会判断 A 是否需要被代理。如果需要代理，就创建 A 的代理对象返回给 B；如果不需要代理，就返回 A 的原始对象。这样就保证了 B 拿到的 A 和最终放入容器的 A 是同一个对象。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Spring源码中的逻辑</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Object exposedObject = bean;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (BeanPostProcessor bp : getBeanPostProcessors()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 关键：如果需要代理，这里会创建代理对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return exposedObject;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>简单来说，三级缓存的核心作用就是延迟决策。它让 Spring 在真正需要 Bean 的时候才决定返回原始对象还是代理对象，这样就避免了对象不一致的问题。如果没有三级缓存，Spring 要么无法在循环依赖的情况下支持 AOP，要么就会出现同一个 Bean 有多个实例的问题，这些都是不可接受的。
<img decoding="async" loading="lazy" alt="1756996082525" src="/doc/assets/images/1756996082525-482400972cfd62766883b8a055800867.png" width="1080" height="1446" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如果缺少二级缓存会有什么问题">如果缺少二级缓存会有什么问题？<a href="#如果缺少二级缓存会有什么问题" class="hash-link" aria-label="Direct link to 如果缺少二级缓存会有什么问题？" title="Direct link to 如果缺少二级缓存会有什么问题？">​</a></h3>
<p>二级缓存 earlySingletonObjects 主要是用来存放那些已经通过三级缓存的对象工厂创建出来的早期 Bean 引用。
<img decoding="async" loading="lazy" alt="1756996229932" src="/doc/assets/images/1756996229932-756bb3c15d6b1232f0cb9f7de29114d0.png" width="1606" height="1210" class="img_ev3q">
假设我们有 A、B、C 三个 Bean，A 依赖 B 和 C，B 和 C 都依赖 A，形成了一个复杂的循环依赖。在没有二级缓存的情况下，每次 B 或者 C 需要获取 A 的时候，都需要调用三级缓存中 A 的 ObjectFactory.getObject() 方法。这意味着如果 A 需要被代理的话，代理对象可能会被重复创建多次，这显然是不合理的。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 没有二级缓存的伪代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public Object getSingleton(String beanName) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Object singletonObject = singletonObjects.get(beanName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 直接从三级缓存获取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ObjectFactory&lt;?&gt; singletonFactory = singletonFactories.get(beanName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (singletonFactory != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return singletonFactory.getObject(); // 每次都会创建新的代理对象！</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return singletonObject;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>我举个具体的例子。比如 A 有 @Transactional 注解需要被 AOP 代理，B 在初始化的时候需要 A，会调用一次对象工厂创建 A 的代理对象。接着 C 在初始化的时候也需要 A，又会调用一次对象工厂，可能又创建了一个 A 的代理对象。这样 B 和 C 拿到的可能就是两个不同的 A 代理对象，这就违反了单例 Bean 的语义。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Service</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ServiceA {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Autowired</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private ServiceB serviceB;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Transactional  // 需要 AOP 代理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void methodA() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 业务逻辑</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Service</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ServiceB {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Autowired</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private ServiceA serviceA;  // 获得代理对象 A1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Autowired</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private ServiceC serviceC;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Service</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ServiceC {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Autowired</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private ServiceA serviceA;  // 可能获得代理对象 A2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>二级缓存就是为了解决这个问题。当第一次通过对象工厂创建了 A 的早期引用之后，就把这个引用放到二级缓存中，同时从三级缓存中移除对象工厂。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 第一次获取 A</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ObjectFactory&lt;A&gt; factory = singletonFactories.get(&quot;serviceA&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Object proxyA = factory.getObject(); // 创建代理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">earlySingletonObjects.put(&quot;serviceA&quot;, proxyA); // 缓存代理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">singletonFactories.remove(&quot;serviceA&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 第二次获取 A</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Object cachedA = earlySingletonObjects.get(&quot;serviceA&quot;); // 直接返回缓存的代理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// proxyA == cachedA  ✓</span><br></span></code></pre></div></div>
<p>后续如果再有其他 Bean 需要 A，就直接从二级缓存中获取，不需要再调用对象工厂了。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="aop">AOP<a href="#aop" class="hash-link" aria-label="Direct link to AOP" title="Direct link to AOP">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说什么是-aop">🌟说说什么是 AOP？<a href="#说说什么是-aop" class="hash-link" aria-label="Direct link to 🌟说说什么是 AOP？" title="Direct link to 🌟说说什么是 AOP？">​</a></h3>
<p>AOP，也就是面向切面编程，简单点说，AOP 就是把一些业务逻辑中的相同代码抽取到一个独立的模块中，让业务逻辑更加清爽。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="spring-aop-有哪些核心概念">Spring AOP 有哪些核心概念？<a href="#spring-aop-有哪些核心概念" class="hash-link" aria-label="Direct link to Spring AOP 有哪些核心概念？" title="Direct link to Spring AOP 有哪些核心概念？">​</a></h3>
<p>①、切面：我们定义的一个类，包含了要在什么时候、什么地方执行什么逻辑。比如我们定义一个日志切面，专门负责记录方法的执行情况。在 Spring 中，我们会用 @Aspect 注解来标识一个切面类。
②、切点：定义了在哪些地方应用切面逻辑。说白了就是告诉 Spring，我这个切面要在哪些方法上生效。比如我们可以定义一个切点表达式，让它匹配所有 Service 层的方法，或者匹配某个特定包下的所有方法。在 Spring 中用 @Pointcut 注解来定义，通常会写一些表达式，比如 execution( com.example.service..*(..)) 这样的。
③、通知：是切面中具体要执行的代码逻辑。它有几种类型：@Before 是在方法执行前执行，@After 是在方法执行后执行，@Around 是环绕通知，可以在方法执行前后都执行，@AfterReturning 是在方法正常返回后执行，@AfterThrowing 是在方法抛出异常后执行。我一般用得最多的是 @Around，因为它最灵活，可以控制方法是否执行，也可以修改参数和返回值。
④、连接点：被拦截到的点，因为 Spring 只支持方法类型的连接点，所以在 Spring 中，连接点指的是被拦截到的方法，实际上连接点还可以是字段或者构造方法。
⑤、织入：是把切面逻辑应用到目标对象的过程。Spring AOP 是在运行时通过动态代理来实现织入的，当我们从 Spring 容器中获取 Bean 的时候，如果这个 Bean 需要被切面处理，Spring 就会返回一个代理对象给我们。
⑥、目标对象：被切面处理的对象，也就是我们平时写的 Service、Controller 等类。Spring AOP 会在目标对象上织入切面逻辑。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">切面（Aspect）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ├── 切入点（Pointcut）─── 定义在哪里执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    └── 通知（Advice）   ─── 定义何时执行什么</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ├── @Before</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ├── @After</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ├── @AfterReturning</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ├── @AfterThrowing</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            └── @Around</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">目标对象（Target）──→ 代理对象（Proxy）──→ 织入（Weaving）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ↑                                    ↓</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">连接点（Join Point）                    客户端调用</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="spring-aop-织入有哪几种方式">Spring AOP 织入有哪几种方式？<a href="#spring-aop-织入有哪几种方式" class="hash-link" aria-label="Direct link to Spring AOP 织入有哪几种方式？" title="Direct link to Spring AOP 织入有哪几种方式？">​</a></h3>
<p>织入有三种主要方式，我按照它们的执行时机来说一下。
编译期织入是在编译 Java 源码的时候就把切面逻辑织入到目标类中。这种方式最典型的实现就是 AspectJ 编译器。它会在编译的时候直接修改字节码，把切面的逻辑插入到目标方法中。
编译期织入的优点是性能最好，因为没有代理的开销，但缺点是需要使用特殊的编译器，而且比较复杂，在 Spring 项目中用得不多。</p>
<p>类加载期织入是在 JVM 加载 class 文件的时候进行织入。这种方式通过 Java 的 Instrumentation API 或者自定义的 ClassLoader 来实现，在类被加载到 JVM 之前修改字节码。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class WeavingClassLoader extends ClassLoader {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        byte[] classBytes = loadClassBytes(name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 在这里进行字节码织入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        byte[] wovenBytes = weaveAspects(classBytes);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return defineClass(name, wovenBytes, 0, wovenBytes.length);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private byte[] weaveAspects(byte[] classBytes) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 使用 ASM 或其他字节码操作库进行织入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return classBytes;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>运行时织入是我们在 Spring 中最常见的方式，也就是通过动态代理来实现。Spring AOP 采用的就是这种方式。当 Spring 容器启动的时候，如果发现某个 Bean 需要被切面处理，就会为这个 Bean 创建一个代理对象。如果目标类实现了接口，Spring 会使用 JDK 的动态代理技术。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface UserService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void saveUser(String username);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 实现类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Service</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class UserServiceImpl implements UserService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void saveUser(String username) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;保存用户: &quot; + username);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Spring 自动创建的代理（伪代码）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class UserServiceProxy implements UserService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private UserService target;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private List&lt;Advisor&gt; advisors;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void saveUser(String username) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 执行前置通知</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (Advisor advisor : advisors) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (advisor.getPointcut().matches(this.getClass().getMethod(&quot;saveUser&quot;, String.class))) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                advisor.getAdvice().before();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 执行目标方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        target.saveUser(username);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 执行后置通知</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (Advisor advisor : advisors) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            advisor.getAdvice().after();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>如果目标类没有实现接口，就会使用 CGLIB 来创建一个子类作为代理。运行时织入的优点是实现简单，不需要特殊的编译器或 JVM 配置，缺点是有一定的性能开销，因为每次方法调用都要经过代理。</p>
<p>Spring AOP 默认的织入方式就是运行时织入，使用起来非常简单，只需要加个 @Aspect 注解和相应的通知注解就可以了。虽然性能上不如编译期织入，但是对于大部分业务场景来说，这点性能开销是完全可以接受的。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Spring AOP 的代理创建过程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Configuration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@EnableAspectJAutoProxy  // 启用 AOP 自动代理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class AopConfig {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Spring 内部的代理创建逻辑（简化版）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DefaultAopProxyFactory implements AopProxyFactory {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public AopProxy createAopProxy(AdvisedSupport config) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 使用 CGLIB 代理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return new CglibAopProxy(config);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 使用 JDK 动态代理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return new JdkDynamicAopProxy(config);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="aspectj-是什么">AspectJ 是什么？<a href="#aspectj-是什么" class="hash-link" aria-label="Direct link to AspectJ 是什么？" title="Direct link to AspectJ 是什么？">​</a></h3>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="spring-aop-有哪些通知方式">Spring AOP 有哪些通知方式？<a href="#spring-aop-有哪些通知方式" class="hash-link" aria-label="Direct link to Spring AOP 有哪些通知方式？" title="Direct link to Spring AOP 有哪些通知方式？">​</a></h3>
<p>感觉不重要
前置通知 (@Before)
主要用来做一些准备工作，比如参数校验、权限检查、记录方法开始执行的日志等等。前置通知无法阻止目标方法的执行，也无法修改方法的参数，它只能在方法执行前做一些额外的操作。我们在项目中经常用它来记录操作日志，比如记录谁在什么时候调用了什么方法。</p>
<p>返回通知 (@AfterReturning)
返回通知是在目标方法正常返回后执行的。这种通知可以获取到方法的返回值，我们可以在注解中指定 returning 参数来接收返回值。返回通知经常用来做一些基于返回结果的后续处理，比如缓存方法的返回结果、根据返回值发送通知等等。如果方法抛出异常的话，返回通知是不会执行的。</p>
<p>异常通知 (@AfterThrowing)
异常通知是在目标方法抛出异常后执行的。我们可以在注解中指定 throwing 参数来接收异常对象。异常通知主要用来做异常处理和记录，比如记录错误日志、发送告警、异常统计等等。需要注意的是，异常通知不能处理异常，异常还是会继续向上抛出。</p>
<p>后置通知 (@After)
后置通知是在目标方法执行完成后执行的，不管方法是正常返回还是抛出异常都会执行。这种通知主要用来做一些清理工作，比如释放资源、记录方法执行完成的日志等等。需要注意的是，后置通知拿不到方法的返回值，也捕获不到异常信息，它就是纯粹的在方法执行后做一些收尾工作。</p>
<p>环绕通知 (@Around)
环绕通知是最强大也是我们用得最多的一种通知。它可以在方法执行前后都执行逻辑，而且可以控制目标方法是否执行，还可以修改方法的参数和返回值。环绕通知的方法必须接收一个 ProceedingJoinPoint 参数，通过调用其 proceed() 方法来执行目标方法。</p>
<p><strong>如果有多个切面，还可以通过 @Order 注解指定先后顺序，数字越小，优先级越高。代码示例如下：</strong></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="spring-aop-发生在什么时候">Spring AOP 发生在什么时候？<a href="#spring-aop-发生在什么时候" class="hash-link" aria-label="Direct link to Spring AOP 发生在什么时候？" title="Direct link to Spring AOP 发生在什么时候？">​</a></h3>
<p>Spring AOP 是在 Bean 的初始化阶段发生的，具体来说是在 Bean 生命周期的后置处理阶段。
在 Bean 实例化完成、属性注入完成之后，Spring 会调用所有 BeanPostProcessor 的 postProcessAfterInitialization 方法，AOP 代理的创建就是在这个阶段完成的。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="简单总结一下-aop">简单总结一下 AOP<a href="#简单总结一下-aop" class="hash-link" aria-label="Direct link to 简单总结一下 AOP" title="Direct link to 简单总结一下 AOP">​</a></h3>
<p>AOP，也就是面向切面编程，是一种编程范式，旨在提高代码的模块化。比如说可以将日志记录、事务管理等分离出来，来提高代码的可重用性。</p>
<p>AOP 的核心概念包括切面、连接点、通知、切点和织入等。</p>
<p>① 像日志打印、事务管理等都可以抽离为切面，可以声明在类的方法上。像 @Transactional 注解，就是一个典型的 AOP 应用，它就是通过 AOP 来实现事务管理的。我们只需要在方法上添加 @Transactional 注解，Spring 就会在方法执行前后添加事务管理的逻辑。</p>
<p>② Spring AOP 是基于代理的，它默认使用 JDK 动态代理和 CGLIB 代理来实现 AOP。</p>
<p>③ Spring AOP 的织入方式是运行时织入，而 AspectJ 支持编译时织入、类加载时织入。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="aop和-oop-的关系">AOP和 OOP 的关系？<a href="#aop和-oop-的关系" class="hash-link" aria-label="Direct link to AOP和 OOP 的关系？" title="Direct link to AOP和 OOP 的关系？">​</a></h3>
<p>OOP 通过类和对象封装数据和行为，专注于核心业务逻辑。
AOP 提供了解决横切关注点（如日志、权限、事务等）的机制，将这些逻辑集中管理。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="aop的应用场景有哪些">🌟AOP的应用场景有哪些？<a href="#aop的应用场景有哪些" class="hash-link" aria-label="Direct link to 🌟AOP的应用场景有哪些？" title="Direct link to 🌟AOP的应用场景有哪些？">​</a></h3>
<p>AOP 在实际工作/编码学习中有很多应用场景，我按照使用频率来说说几个主要的。</p>
<p>事务管理是用得最多的场景，基本上每个项目都会用到。只需要在 Service 方法上加个 @Transactional 注解，Spring 就会自动帮我们管理事务的开启、提交和回滚。</p>
<p>日志记录也是一个很常见的应用。在技术派实战项目中，就利用了 AOP 来打印接口的入参和出参日志、执行时间，方便后期 bug 溯源和性能调优。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说-spring-aop-和-aspectj-区别">说说 Spring AOP 和 AspectJ 区别?<a href="#说说-spring-aop-和-aspectj-区别" class="hash-link" aria-label="Direct link to 说说 Spring AOP 和 AspectJ 区别?" title="Direct link to 说说 Spring AOP 和 AspectJ 区别?">​</a></h3>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说jdk动态代理和cglib代理的区别">🌟说说JDK动态代理和CGLIB代理的区别？<a href="#说说jdk动态代理和cglib代理的区别" class="hash-link" aria-label="Direct link to 🌟说说JDK动态代理和CGLIB代理的区别？" title="Direct link to 🌟说说JDK动态代理和CGLIB代理的区别？">​</a></h3>
<p>JDK 动态代理和 CGLIB 代理是 Spring AOP 用来创建代理对象的两种方式。</p>
<p><img decoding="async" loading="lazy" alt="1756997217569" src="/doc/assets/images/1756997217569-7f25baca0207676225d9c1b025cd5a56.png" width="982" height="453" class="img_ev3q">
从使用条件来说，JDK 动态代理要求目标类必须实现至少一个接口，因为它是基于接口来创建代理的。而 CGLIB 代理不需要目标类实现接口，它是通过继承目标类来创建代理的。</p>
<p>这是两者最根本的区别。比如我们有一个 TransferService 接口和 TransferServiceImpl 实现类，如果用 JDK 动态代理，创建的代理对象会实现 TransferService 接口；
如果用 CGLIB，代理对象会继承 TransferServiceImpl 类。</p>
<p>从实现原理来说，JDK 动态代理是 Java 原生支持的，它通过反射机制在运行时动态创建一个实现了指定接口的代理类。当我们调用代理对象的方法时，会被转发到 InvocationHandler 的 invoke 方法中，我们可以在这个方法里插入切面逻辑，然后再通过反射调用目标对象的真实方法。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class JdkProxyExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        UserService target = new UserServiceImpl();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        UserService proxy = (UserService) Proxy.newProxyInstance(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            target.getClass().getClassLoader(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            target.getClass().getInterfaces(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            (proxy1, method, args1) -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;Before method: &quot; + method.getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Object result = method.invoke(target, args1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;After method: &quot; + method.getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        proxy.findUser(1L);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>CGLIB 则是一个第三方的字节码生成库，它通过 ASM 字节码框架动态生成目标类的子类，然后重写父类的方法来插入切面逻辑。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class CglibProxyExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Enhancer enhancer = new Enhancer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        enhancer.setSuperclass(UserController.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        enhancer.setCallback(new MethodInterceptor() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;Before method: &quot; + method.getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Object result = proxy.invokeSuper(obj, args);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;After method: &quot; + method.getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        UserController proxy = (UserController) enhancer.create();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        proxy.getUser(1L);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="选择-cglib-还是-jdk-动态代理">选择 CGLIB 还是 JDK 动态代理？<a href="#选择-cglib-还是-jdk-动态代理" class="hash-link" aria-label="Direct link to 选择 CGLIB 还是 JDK 动态代理？" title="Direct link to 选择 CGLIB 还是 JDK 动态代理？">​</a></h3>
<p>如果目标对象没有实现任何接口，就只能使用 CGLIB 代理，就比如说 Controller 层的类。</p>
<p>如果目标对象实现了接口，通常首选 JDK 动态代理，比如说 Service 层的类，一般都会先定义接口，再实现接口。</p>
<p>在 Spring Boot 2.0 之后，Spring AOP 默认使用 CGLIB 代理。这是因为 Spring Boot 作为一个追求“约定优于配置”的框架，选择 CGLIB，可以简化开发者的心智负担，避免因为忘记实现接口而导致 AOP 不生效的问题。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="你会用-jdk-动态代理吗">你会用 JDK 动态代理吗？<a href="#你会用-jdk-动态代理吗" class="hash-link" aria-label="Direct link to 你会用 JDK 动态代理吗？" title="Direct link to 你会用 JDK 动态代理吗？">​</a></h3>
<p>Proxy.newProxyInstance</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="你会用-cglib-动态代理吗">你会用 CGLIB 动态代理吗？<a href="#你会用-cglib-动态代理吗" class="hash-link" aria-label="Direct link to 你会用 CGLIB 动态代理吗？" title="Direct link to 你会用 CGLIB 动态代理吗？">​</a></h3>
<p>MethodInterceptor</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="事务">事务<a href="#事务" class="hash-link" aria-label="Direct link to 事务" title="Direct link to 事务">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说你对spring事务的理解">🌟说说你对Spring事务的理解？<a href="#说说你对spring事务的理解" class="hash-link" aria-label="Direct link to 🌟说说你对Spring事务的理解？" title="Direct link to 🌟说说你对Spring事务的理解？">​</a></h3>
<p>Spring 提供了两种事务管理方式，编程式事务和声明式事务。编程式事务就是我们要手动调用事务的开始、提交、回滚这些操作，虽然灵活但是代码比较繁琐。声明式事务只需要在需要事务的方法上加上 @Transactional 注解就好了，Spring 会帮我们自动处理事务的整个生命周期。
<img decoding="async" loading="lazy" alt="1756997519288" src="/doc/assets/images/1756997519288-b70c901d8653dd3e1469b68c911c1701.png" width="3674" height="1575" class="img_ev3q"></p>
<p>编程式事务可以使用 TransactionTemplate 和 PlatformTransactionManager 来实现，允许我们在代码中直接控制事务的边界。</p>
<p>Spring 事务的底层实现是通过 AOP 来完成的。当我们在方法上加 @Transactional 注解后，Spring 会为这个 Bean 创建代理对象，在方法执行前开启事务，方法正常返回时提交事务，如果方法抛出异常就回滚事务。
声明式事务的优点是不需要在业务逻辑代码中掺杂事务管理的代码，缺点是，最细粒度只能到方法级别，无法到代码块级别。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="声明式事务的实现原理了解吗">声明式事务的实现原理了解吗？<a href="#声明式事务的实现原理了解吗" class="hash-link" aria-label="Direct link to 声明式事务的实现原理了解吗？" title="Direct link to 声明式事务的实现原理了解吗？">​</a></h3>
<p>Spring 的声明式事务管理是通过 AOP 和代理机制实现的，大致可以分为两个阶段。</p>
<p>第一个阶段发生在 Spring 容器启动时，它会扫描所有的 Bean。如果发现某个 Bean 的方法上标注了 @Transactional 注解，Spring 不会直接返回这个原始的 Bean 实例。而是为这个 Bean 创建一个代理对象。这个代理对象拥有和原始对象完全相同的方法，但在内部悄悄地包裹了事务处理的逻辑。</p>
<p>第二个阶段发生在方法调用的运行阶段，当我们的代码调用那个被 @Transactional 注解修饰的方法时，实际上调用的是 Spring 创建的那个代理对象的方法。</p>
<p>事务拦截器会在代理对象执行真正的业务逻辑之前，根据 @Transactional 注解的配置获取事务属性，比如传播行为、隔离级别等，然后通过事务管理器来开启一个新的事务。并从数据库连接池获取一个连接，关闭其自动提交。</p>
<p>接着，代理对象会调用原始 Bean 实例中真正的业务方法，如果业务方法顺利执行完毕，没有抛出任何异常，那么拦截器就会通过事务管理器提交事务，将之前的所有数据库操作永久保存。</p>
<p>如果业务方法抛出了异常，拦截器会捕获到这个异常，并通过事务管理器回滚事务，将之前的所有数据库操作撤销。</p>
<p>最后，无论事务是提交还是回滚，拦截器都会释放数据库连接。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="transactional在哪些情况下会失效">@Transactional在哪些情况下会失效？<a href="#transactional在哪些情况下会失效" class="hash-link" aria-label="Direct link to @Transactional在哪些情况下会失效？" title="Direct link to @Transactional在哪些情况下会失效？">​</a></h3>
<p>@Transactional 虽然用起来很方便，但确实有一些“坑”，如果使用不当是会导致事务失效的。根据我的理解和实践，主要有以下几种常见情况：</p>
<p>第一种，@Transactional 注解用在非 public 修饰的方法上。</p>
<p>Spring 的 AOP 代理机制决定了它无法代理 private 方法。因为 private 方法在子类中是不可见的，代理类无法覆盖它。因此，在 private 方法上加 @Transactional 注解是完全无效的。同理，protected 和 default 权限的方法也应避免使用。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">protected TransactionAttribute computeTransactionAttribute(Method method,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Class&lt;?&gt; targetClass) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Don&#x27;t allow no-public methods as required.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>第二种，方法内部调用，这也是最容易被忽略的一种失效场景。如果在一个类的方法 A 中，直接调用本类的另外一个加了 @Transactional 的方法 B，那么方法 B 的事务是不会生效的。</p>
<p>这是因为方法 A 调用方法 B 时，使用的是 this 引用，直接访问原始对象的方法，绕过了 Spring 的代理对象，也就导致代理对象中的事务逻辑没有机会执行。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class UserService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Transactional</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void createUser(User user) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 直接调用本类的另一个方法，事务不会生效</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        saveUser(user);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void saveUser(User user) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 保存用户逻辑</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>解决方法是把当前类作为一个 Bean 注入到自己中，然后通过这个注入的 Bean 来调用方法 B。</p>
<p>第三种，如果在事务方法内部用 try-catch 捕获了异常，但没有在 catch 块中将异常重新抛出，或者抛出一个新的能触发回滚的异常，那么 Spring 的事务拦截器就无法感知到异常的发生，也就没办法回滚。</p>
<p>第四种，Spring 事务默认只对 RuntimeException 和 Error 类型的异常进行回滚。如果在代码中抛出的是一个Checked Exception，是 Exception 的子类但不是 RuntimeException 的子类，又没有通过 @Transactional(rollbackFor = Exception.class) 指定事务回归的异常类型，那么事务同样不会回滚。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说spring的事务传播机制">🌟说说Spring的事务传播机制？<a href="#说说spring的事务传播机制" class="hash-link" aria-label="Direct link to 🌟说说Spring的事务传播机制？" title="Direct link to 🌟说说Spring的事务传播机制？">​</a></h3>
<p>简单来说，当一个事务方法 A 调用另一个事务方法 B 时，方法 B 的事务应该如何运行？是加入方法 A 的现有事务，还是开启一个新事务，或者以非事务方式运行？这就是事务传播机制要解决的问题。</p>
<p>Spring 定义了七种事务传播行为，其中 REQUIRED 是默认的传播行为，表示如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。
<img decoding="async" loading="lazy" alt="1756997983833" src="/doc/assets/images/1756997983833-23cba21fefaf1339e08edc38fa03acef.png" width="1568" height="908" class="img_ev3q">
当然，还有一些特殊情况。比如，我们希望记录一些操作日志，但不想因为主业务失败导致日志回滚。这时候 REQUIRES_NEW 就派上用场了。它不管当前有没有事务，都重新开启一个全新的、独立的事务来执行。这样，日志保存的事务和主业务的事务就互不干扰，即使主业务失败回滚，日志也能妥妥地保存下来。</p>
<p>另外，还有像 SUPPORTS、 NOT_SUPPORTED 这些。SUPPORTS 比较佛系，有事务就用，没事务就不用，适合一些不重要的更新操作。而 NOT_SUPPORTED 则更干脆，它会把当前的事务挂起，以非事务的方式去执行。比如说我们的事务里需要调用一个第三方的、响应很慢的接口，如果这个调用也包含在事务里，就会长时间占用数据库连接。把它用 NOT_SUPPORTED 包起来，就可以避免这个问题。
最后还有一个比较特殊的 NESTED，嵌套事务。它有点像 REQUIRES_NEW，但又不完全一样。NESTED 是父事务的一个子事务，父事务回滚，它肯定也得回滚。但它自己回滚，却不会影响到父事务。这个特性在处理一些批量操作，希望能部分回滚的场景下特别有用。不过它需要数据库支持 Savepoint 功能，MySQL 就支持。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="事务能在新线程中传播吗">事务能在新线程中传播吗？<a href="#事务能在新线程中传播吗" class="hash-link" aria-label="Direct link to 事务能在新线程中传播吗？" title="Direct link to 事务能在新线程中传播吗？">​</a></h3>
<p>事务传播机制是通过 ThreadLocal 实现的，所以，如果调用的方法是在新线程中，事务传播就会失效。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Transactional</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void parentMethod() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    new Thread(() -&gt; childMethod()).start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void childMethod() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这里的操作将不会在 parentMethod 的事务范围内执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="protected-和-private-方法加事务会生效吗">protected 和 private 方法加事务会生效吗？<a href="#protected-和-private-方法加事务会生效吗" class="hash-link" aria-label="Direct link to protected 和 private 方法加事务会生效吗？" title="Direct link to protected 和 private 方法加事务会生效吗？">​</a></h3>
<p>不重要</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="mvc">MVC<a href="#mvc" class="hash-link" aria-label="Direct link to MVC" title="Direct link to MVC">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="spring-mvc-的核心组件有哪些">Spring MVC 的核心组件有哪些？<a href="#spring-mvc-的核心组件有哪些" class="hash-link" aria-label="Direct link to Spring MVC 的核心组件有哪些？" title="Direct link to Spring MVC 的核心组件有哪些？">​</a></h3>
<p>Spring MVC 作为 Spring 框架中处理 Web 请求的核心模块，它的设计遵循了经典的 MVC 模式，根据我的理解，它的核心组件主要包括：</p>
<p>前端控制器 DispatcherServlet，这是 Spring MVC 的入口和核心调度器。当一个 HTTP 请求到达服务器时，首先由 DispatcherServlet 接收。它负责将请求分发到合适的处理器，也就是 Controller 中的方法，并协调其他组件的工作。
<img decoding="async" loading="lazy" alt="1756998445777" src="/doc/assets/images/1756998445777-eb71f4eabfef2a11c41ac1d94ee4af38.png" width="1798" height="1402" class="img_ev3q">
在 Spring Boot 项目中，DispatcherServlet 的启动是通过自动配置完成的。Spring Boot 会自动注册一个默认的 DispatcherServlet，并将其映射到 /。</p>
<p>处理器映射 HandlerMapping，当一个请求进来时，前端控制器会询问处理器映射：“这个 URL 应该由哪个 Controller 的哪个方法来处理？”然后它就会根据 @RequestMapping、@GetMapping 这些注解来匹配请求。</p>
<p>处理器 Handler，实际上就是我们写的 Controller 方法，这是真正处理业务逻辑的地方。</p>
<p>处理器适配器 HandlerAdapter，负责调用该处理器的方法，并处理参数绑定、类型转换等。因为处理器可能有不同的类型，比如注解方式、实现接口方式等，处理器适配器就是为了统一调用方式。</p>
<p>视图解析器 ViewResolver，处理完业务逻辑后，如果需要渲染视图，ViewResolver 会根据返回的视图名称解析实际的视图对象，比如 Thymeleaf。在前后端分离的项目中，这个组件更多用于返回 JSON 数据。</p>
<p>异常处理器 HandlerExceptionResolver，捕获并处理请求处理过程中抛出的异常。通常，我们可以通过 @ControllerAdvice 和 @ExceptionHandler 来自定义异常处理逻辑，确保返回友好的错误响应。</p>
<p>除此之外，还有文件上传解析器 MultipartResolver，用于处理文件上传请求；拦截器 HandlerInterceptor，用于在请求处理前后执行一些额外的逻辑，比如权限校验、日志记录等。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="spring-mvc-的工作流程了解吗">🌟Spring MVC 的工作流程了解吗？<a href="#spring-mvc-的工作流程了解吗" class="hash-link" aria-label="Direct link to 🌟Spring MVC 的工作流程了解吗？" title="Direct link to 🌟Spring MVC 的工作流程了解吗？">​</a></h3>
<p>简单来说，Spring MVC 是一个基于 Servlet 的请求处理框架，核心流程可以概括为：请求接收 → 路由分发 → 控制器处理 → 视图解析。</p>
<p><img decoding="async" loading="lazy" alt="1756998531876" src="/doc/assets/images/1756998531876-2ca38f5c54a4a347643215c8babef882.png" width="1100" height="589" class="img_ev3q">
用户发起的 HTTP 请求，首先会被 DispatcherServlet 捕获，这是 Spring MVC 的“前端控制器”，负责拦截所有请求，起到统一入口的作用。</p>
<p>DispatcherServlet 接收到请求后，会根据 URL、请求方法等信息，交给 HandlerMapping 进行路由匹配，查找对应的处理器，也就是 Controller 中的具体方法。
找到对应 Controller 方法后，DispatcherServlet 会委托给处理器适配器 HandlerAdapter 进行调用。处理器适配器负责执行方法本身，并处理参数绑定、数据类型转换等。在注解驱动开发中，常用的是 RequestMappingHandlerAdapter。这一层会把请求参数自动注入到方法形参中，并调用 Controller 执行实际的业务逻辑。
Controller 方法最终会返回结果，比如视图名称、ModelAndView 或直接返回 JSON 数据。</p>
<p>当 Controller 方法返回视图名时，DispatcherServlet 会调用 ViewResolver 将其解析为实际的 View 对象，比如 Thymeleaf 页面。在前后端分离的接口项目中，这一步则通常是返回 JSON 数据。</p>
<p>最后，由 View 对象完成渲染，或者将 JSON 结果直接通过 DispatcherServlet 返回给客户端。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么还需要-handleradapter">为什么还需要 HandlerAdapter？<a href="#为什么还需要-handleradapter" class="hash-link" aria-label="Direct link to 为什么还需要 HandlerAdapter？" title="Direct link to 为什么还需要 HandlerAdapter？">​</a></h3>
<p>Spring MVC 支持多种风格的处理器，比如基于 @Controller 注解的处理器、实现了 Controller 接口的处理器等。如果没有处理器适配器，DispatcherServlet 就需要硬编码每种处理器的调用方式，框架就会变得非常僵硬——新增一种 Controller 类型，就必须改 DispatcherServlet 的代码。</p>
<p>因此，Spring 引入了 HandlerAdapter 作为适配器，屏蔽不同控制器的差异，给 DispatcherServlet 提供一个统一的调用入口。</p>
<p>比如说，如果是实现了 Controller 接口的处理器，DispatcherServlet 会使用 SimpleControllerHandlerAdapter 来适配它。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class SimpleControllerHandlerAdapter implements HandlerAdapter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	@Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	public boolean supports(Object handler) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		return (handler instanceof Controller);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	@Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	@Nullable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		return ((Controller) handler).handleRequest(request, response);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ... 省略一个无关方法 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>如果是使用 @RequestMapping 注解的处理器，DispatcherServlet 则会使用 RequestMappingHandlerAdapter 来适配。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class RequestMappingHandlerAdapter implements HandlerAdapter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean supports(Object handler) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return (handler instanceof HandlerMethod);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Nullable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 执行方法并返回 ModelAndView      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return invokeHandlerMethod(handlerMethod, request, response);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="springmvc-restful-风格的接口流程是什么样的呢">SpringMVC Restful 风格的接口流程是什么样的呢？<a href="#springmvc-restful-风格的接口流程是什么样的呢" class="hash-link" aria-label="Direct link to SpringMVC Restful 风格的接口流程是什么样的呢？" title="Direct link to SpringMVC Restful 风格的接口流程是什么样的呢？">​</a></h3>
<p>在传统的 MVC 中，Controller 方法通常返回一个视图名称或者 ModelAndView 对象，然后由视图解析器 ViewResolver 解析并渲染成 HTML 页面。但在 RESTful 架构中，通常返回的是 JSON 或 XML，不再是一个完整的页面。</p>
<p>其中很重要的两个注解：@RestController 相当于 @Controller 和 @ResponseBody 的结合。当在一个类上使用 @RestController 时，它会告诉 Spring 这个类中所有方法的返回值都应该被直接写入 HTTP 响应体中，而不再被解析为视图。</p>
<p>@ResponseBody 可以用在方法级别，作用相同。它标志着该方法的返回值将作为响应体内容，Spring 会跳过视图解析的步骤。</p>
<p>HttpMessageConverter 是实现 RESTful 风格的关键。当 Spring 检测到 @ResponseBody 注解时，它会使用 HttpMessageConverter 来将 Controller 方法返回的 Java 对象序列化成指定的格式，如 JSON。</p>
<p>默认情况下，如果类路径下有 Jackson 库，Spring Boot 会自动配置 MappingJackson2HttpMessageConverter 来处理 JSON 的转换。相应的，对于带有 @RequestBody 注解的方法参数，它也会用这个转换器将请求体中的 JSON 数据反序列化成 Java 对象。</p>
<p>所以，RESTful 接口的流程可以概括为：请求到达前端控制器 DispatcherServlet → 通过 HandlerMapping 找到对应的 Controller 方法 → 执行方法并返回数据 → 使用 HttpMessageConverter 将数据转换为 JSON 或 XML 格式 → 直接写入 HTTP 响应体。
<img decoding="async" loading="lazy" alt="1756998747233" src="/doc/assets/images/1756998747233-4b6ec64ac0e8d5402517a746d34bf47c.png" width="3990" height="1671" class="img_ev3q"></p>
<p>总结来说，RESTful 接口的流程通过 @RestController 和 HttpMessageConverter “抄了近道”，省略了 ViewResolver 和 View 的渲染过程，直接将数据转换为指定的格式返回，非常适合前后端分离的应用场景。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="spring-boot">Spring Boot<a href="#spring-boot" class="hash-link" aria-label="Direct link to Spring Boot" title="Direct link to Spring Boot">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="介绍一下-springboot">🌟介绍一下 SpringBoot？<a href="#介绍一下-springboot" class="hash-link" aria-label="Direct link to 🌟介绍一下 SpringBoot？" title="Direct link to 🌟介绍一下 SpringBoot？">​</a></h3>
<p>Spring Boot 可以说是 Spring 生态的一个重大突破，它极大地简化了 Spring 应用的开发和部署过程。
以前我们用 Spring 开发项目的时候，需要配置一大堆 XML 文件，包括 Bean 的定义、数据源配置、事务配置等等，非常繁琐。而且还要手动管理各种 jar 包的依赖关系，很容易出现版本冲突的问题。部署的时候还要单独搭建 Tomcat 服务器，整个过程很复杂。Spring Boot 就是为了解决这些痛点而生的。</p>
<p>**“约定大于配置”**是 Spring Boot 最核心的理念。它预设了很多默认配置，比如默认使用内嵌的 Tomcat 服务器，默认的日志框架是 Logback 等等。这样，我们开发者就只需要关注业务逻辑，不用再纠结于各种配置细节。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="spring-boot常用注解有哪些">Spring Boot常用注解有哪些？<a href="#spring-boot常用注解有哪些" class="hash-link" aria-label="Direct link to Spring Boot常用注解有哪些？" title="Direct link to Spring Boot常用注解有哪些？">​</a></h3>
<p>@SpringBootApplication：这是 Spring Boot 的核心注解，它是一个组合注解，包含了 @Configuration、@EnableAutoConfiguration 和 @ComponentScan。它标志着一个 Spring Boot 应用的入口。
@SpringBootTest：用于测试 Spring Boot 应用的注解，它会加载整个 Spring 上下文，适合集成测试。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="spring-boot的自动装配原理了解吗">🌟Spring Boot的自动装配原理了解吗？<a href="#spring-boot的自动装配原理了解吗" class="hash-link" aria-label="Direct link to 🌟Spring Boot的自动装配原理了解吗？" title="Direct link to 🌟Spring Boot的自动装配原理了解吗？">​</a></h3>
<p>在 Spring Boot 中，开启自动装配的注解是@EnableAutoConfiguration。这个注解会告诉 Spring 去扫描所有可用的自动配置类。
Spring Boot 为了进一步简化，把这个注解包含到了 @SpringBootApplication 注解中。也就是说，当我们在主类上使用 @SpringBootApplication 注解时，实际上就已经开启了自动装配。</p>
<p>当 main 方法运行的时候，Spring 会去类路径下找 spring.factories 这个文件，读取里面配置的自动配置类列表。比如在我们的技术派项目中，paicoding-core 和 paicoding-service 模块里都有 spring.factories，分别注册了 ForumCoreAutoConfig 和 ServiceAutoConfig，这两个配置类就会在项目启动的时候被自动加载。</p>
<p>然后每个自动配置类内部，通常会有一个 @Configuration 注解，同时结合各种 @Conditional 注解来做条件控制。像技术派的 RabbitMqAutoConfig 类，就用了 @ConditionalOnProperty 注解来判断配置文件里有没有开启 rabbitmq.switchFlag，来决定是否初始化 RabbitMQ 消费线程。</p>
<p>另外一个常见的场景是自动注入 Bean，比如技术派的 ServiceAutoConfig 中就用了 @ComponentScan 来扫描 service 包，@MapperScan 扫描 MyBatis 的 mapper 接口，实现业务层和 DAO 层的自动装配。</p>
<p>具体的执行过程可以总结为：Spring Boot 项目在启动时加载所有的自动配置类，然后逐个检查它们的生效条件，当条件满足时就实例化并创建相应的 Bean。
<img decoding="async" loading="lazy" alt="1756998971585" src="/doc/assets/images/1756998971585-92ebd21cfa23274554082287f37f59e4.png" width="1175" height="395" class="img_ev3q"></p>
<p>自动装配的执行时机是在 Spring 容器启动的时候。具体来说是在 ConfigurationClassPostProcessor 这个 BeanPostProcessor 中处理的，它会解析 @Configuration 类，包括通过 @Import 导入的自动配置类。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 检查自动配置是否启用。如果@ConditionalOnClass等条件注解使得自动配置不适用于当前环境，则返回一个空的配置条目。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!isEnabled(annotationMetadata)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return EMPTY_ENTRY;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 获取启动类上的@EnableAutoConfiguration注解的属性，这可能包括对特定自动配置类的排除。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 从spring.factories中获取所有候选的自动配置类。这是通过加载META-INF/spring.factories文件中对应的条目来实现的。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 移除配置列表中的重复项，确保每个自动配置类只被考虑一次。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    configurations = removeDuplicates(configurations);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 根据注解属性解析出需要排除的自动配置类。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 检查排除的类是否存在于候选配置中，如果存在，则抛出异常。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    checkExcludedClasses(configurations, exclusions);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 从候选配置中移除排除的类。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    configurations.removeAll(exclusions);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 应用过滤器进一步筛选自动配置类。过滤器可能基于条件注解如@ConditionalOnBean等来排除特定的配置类。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    configurations = getConfigurationClassFilter().filter(configurations);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 触发自动配置导入事件，允许监听器对自动配置过程进行干预。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fireAutoConfigurationImportEvents(configurations, exclusions);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 创建并返回一个包含最终确定的自动配置类和排除的配置类的AutoConfigurationEntry对象。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new AutoConfigurationEntry(configurations, exclusions);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何自定义一个-springboot-starter">🌟如何自定义一个 SpringBoot Starter?<a href="#如何自定义一个-springboot-starter" class="hash-link" aria-label="Direct link to 🌟如何自定义一个 SpringBoot Starter?" title="Direct link to 🌟如何自定义一个 SpringBoot Starter?">​</a></h3>
<p>第一步，SpringBoot 官方建议第三方 starter 的命名格式是 xxx-spring-boot-starter，所以我们可以创建一个名为 my-spring-boot-starter 的项目，一共包括两个模块，一个是 autoconfigure 模块，包含自动配置逻辑；一个是 starter 模块，只包含依赖声明。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;properties&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;spring.boot.version&gt;2.3.1.RELEASE&lt;/spring.boot.version&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;/properties&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;dependencies&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;dependency&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;version&gt;${spring.boot.version}&lt;/version&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;/dependency&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;dependency&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;version&gt;${spring.boot.version}&lt;/version&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;/dependency&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;/dependencies&gt;</span><br></span></code></pre></div></div>
<p>第二步，创建一个自动配置类，通常在 autoconfigure 包下，该类的作用是根据配置文件中的属性来创建和配置 Bean。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Configuration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@EnableConfigurationProperties(MyStarterProperties.class)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class MyServiceAutoConfiguration {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @ConditionalOnMissingBean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public MyService myService(MyStarterProperties properties) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new MyService(properties.getMessage());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>第三步，创建一个配置属性类，用于读取配置文件中的属性。通常使用 @ConfigurationProperties 注解来标记这个类。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@ConfigurationProperties(prefix = &quot;mystarter&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class MyStarterProperties {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String message = &quot;二哥的 Java 进阶之路不错啊!&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String getMessage() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return message;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setMessage(String message) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.message = message;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>第四步，创建一个简单的服务类，用于提供业务逻辑。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class MyService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final String message;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public MyService(String message) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.message = message;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String getMessage() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return message;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>第五步，在 src/main/resources/META-INF 目录下创建一个名为 spring.factories 文件，告诉 SpringBoot 在启动时要加载我们的自动配置类。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">com.itwanger.mystarter.autoconfigure.MyServiceAutoConfiguration</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="spring-boot-starter-的原理了解吗">Spring Boot Starter 的原理了解吗？<a href="#spring-boot-starter-的原理了解吗" class="hash-link" aria-label="Direct link to Spring Boot Starter 的原理了解吗？" title="Direct link to Spring Boot Starter 的原理了解吗？">​</a></h3>
<p>Starter 的核心思想是把相关的依赖打包在一起，让开发者只需要引入一个 starter 依赖，就能获得完整的功能模块。</p>
<p>当我们在 pom.xml 中引入一个 starter 时，Maven 就会自动解析这个 starter 的依赖树，把所有需要的 jar 包都下载下来。</p>
<p>每个 starter 都会包含对应的自动配置类，这些配置类通过条件注解来判断是否应该生效。比如当我们引入了 spring-boot-starter-web，它会自动配置 Spring MVC、内嵌的 Tomcat 服务器等。</p>
<p>spring.factories 文件是 Spring Boot 自动装配的核心，它位于每个 starter 的 META-INF 目录下。这个文件列出了所有的自动配置类，Spring Boot 在启动时会读取这个文件，加载对应的配置类</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="spring-boot-启动原理了解吗">🌟Spring Boot 启动原理了解吗？<a href="#spring-boot-启动原理了解吗" class="hash-link" aria-label="Direct link to 🌟Spring Boot 启动原理了解吗？" title="Direct link to 🌟Spring Boot 启动原理了解吗？">​</a></h3>
<p>Spring Boot 的启动由 SpringApplication 类负责：</p>
<p>第一步，创建 SpringApplication 实例，负责应用的启动和初始化；
第二步，从 application.yml 中加载配置文件和环境变量；
第三步，创建上下文环境 ApplicationContext，并加载 Bean，完成依赖注入；
第四步，启动内嵌的 Web 容器。
第五步，发布启动完成事件 ApplicationReadyEvent，并调用 ApplicationRunner 的 run 方法完成启动后的逻辑。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public ConfigurableApplicationContext run(String... args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 1. 创建启动时的监听器并触发启动事件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    SpringApplicationRunListeners listeners = getRunListeners(args);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    listeners.starting();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 2. 准备运行环境</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ConfigurableEnvironment environment = prepareEnvironment(listeners);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    configureIgnoreBeanInfo(environment);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 3. 创建上下文</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ConfigurableApplicationContext context = createApplicationContext();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 4. 准备上下文</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        prepareContext(context, environment, listeners, args);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 5. 刷新上下文，完成 Bean 初始化和装配</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        refreshContext(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 6. 调用运行器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        afterRefresh(context, args);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 7. 触发启动完成事件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        listeners.started(context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (Exception ex) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        handleRunFailure(context, ex, listeners);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p><img decoding="async" loading="lazy" alt="1756999144664" src="/doc/assets/images/1756999144664-6594ca16165eaca00cf28d8cf30e0c81.png" width="1080" height="1096" class="img_ev3q">
该方法负责 Spring 应用的上下文环境（ApplicationContext）准备，包括：</p>
<p>扫描配置文件，添加依赖项
初始化和加载 Bean 定义
启动内嵌的 Web 容器等
发布启动完成事件</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="了解springbootapplication-注解吗">了解@SpringBootApplication 注解吗？<a href="#了解springbootapplication-注解吗" class="hash-link" aria-label="Direct link to 了解@SpringBootApplication 注解吗？" title="Direct link to 了解@SpringBootApplication 注解吗？">​</a></h3>
<p>@SpringBootApplication是 Spring Boot 的核心注解，经常用于主类上，作为项目启动入口的标识。它是一个组合注解：</p>
<p>@SpringBootConfiguration：继承自 @Configuration，标注该类是一个配置类，相当于一个 Spring 配置文件。
@EnableAutoConfiguration：告诉 Spring Boot 根据 pom.xml 中添加的依赖自动配置项目。例如，如果 spring-boot-starter-web 依赖被添加到项目中，Spring Boot 会自动配置 Tomcat 和 Spring MVC。
@ComponentScan：扫描当前包及其子包下被@Component、@Service、@Controller、@Repository 注解标记的类，并注册为 Spring Bean。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么-spring-boot-在启动的时候能够找到-main-方法上的springbootapplication-注解">为什么 Spring Boot 在启动的时候能够找到 main 方法上的@SpringBootApplication 注解？<a href="#为什么-spring-boot-在启动的时候能够找到-main-方法上的springbootapplication-注解" class="hash-link" aria-label="Direct link to 为什么 Spring Boot 在启动的时候能够找到 main 方法上的@SpringBootApplication 注解？" title="Direct link to 为什么 Spring Boot 在启动的时候能够找到 main 方法上的@SpringBootApplication 注解？">​</a></h3>
<p>Spring Boot 在启动时能够找到主类上的@SpringBootApplication注解，是因为它利用了 Java 的反射机制和类加载机制，结合 Spring 框架内部的一系列处理流程。</p>
<p>当运行一个 Spring Boot 程序时，通常会调用主类中的main方法，这个方法会执行SpringApplication.run()，比如：</p>
<p><code>SpringApplication.run(Class&lt;?&gt; primarySource, String... args)</code>方法接收两个参数：第一个是主应用类（即包含main方法的类），第二个是命令行参数。primarySource参数提供了一个起点，Spring Boot 通过它来加载应用上下文。</p>
<p>Spring Boot 利用 Java 反射机制来读取传递给run方法的类（MyApplication.class）。它会检查这个类上的注解，包括@SpringBootApplication</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="spring-boot-默认的包扫描路径是什么">Spring Boot 默认的包扫描路径是什么？<a href="#spring-boot-默认的包扫描路径是什么" class="hash-link" aria-label="Direct link to Spring Boot 默认的包扫描路径是什么？" title="Direct link to Spring Boot 默认的包扫描路径是什么？">​</a></h3>
<p>Spring Boot 的默认包扫描路径是以启动类 @SpringBootApplication 注解所在的包为根目录的，即默认情况下，Spring Boot 会扫描启动类所在包及其子包下的所有组件。</p>
<p>@SpringBootApplication 是一个组合注解，它里面的@ComponentScan注解可以指定要扫描的包路径，默认扫描启动类所在包及其子包下的所有组件。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public @interface SpringBootApplication {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>比如说带有 @Component、@Service、@Controller、@Repository 等注解的类都会被 Spring Boot 扫描到，并注册到 Spring 容器中。</p>
<p>如果需要自定义包扫描路径，可以在@SpringBootApplication注解上添加@ComponentScan注解，指定要扫描的包路径。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@SpringBootApplication</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@ComponentScan(basePackages = {&quot;com.github.paicoding.forum&quot;})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class QuickForumApplication {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SpringApplication.run(QuickForumApplication.class, args);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>这种方式会覆盖默认的包扫描路径，只扫描com.github.paicoding.forum包及其子包下的所有组件。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="springboot-和-springmvc-的区别补充">SpringBoot 和 SpringMVC 的区别？（补充）<a href="#springboot-和-springmvc-的区别补充" class="hash-link" aria-label="Direct link to SpringBoot 和 SpringMVC 的区别？（补充）" title="Direct link to SpringBoot 和 SpringMVC 的区别？（补充）">​</a></h3>
<p>Spring MVC 是基于 Spring 框架的一个模块，提供了一种 Model-View-Controller（模型-视图-控制器）的开发模式。</p>
<p>Spring Boot 旨在简化 Spring 应用的配置和部署过程，提供了大量的自动配置选项，以及运行时环境的内嵌 Web 服务器，这样就可以更快速地开发一个 SpringMVC 的 Web 项目。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="spring-boot-和-spring-有什么区别补充">Spring Boot 和 Spring 有什么区别？（补充）<a href="#spring-boot-和-spring-有什么区别补充" class="hash-link" aria-label="Direct link to Spring Boot 和 Spring 有什么区别？（补充）" title="Direct link to Spring Boot 和 Spring 有什么区别？（补充）">​</a></h3>
<p>Spring Boot 是 Spring Framework 的一个扩展，提供了一套快速配置和开发的机制，可以帮助我们快速搭建 Spring 项目的骨架，提高生产效率。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="spring-cloud">Spring Cloud<a href="#spring-cloud" class="hash-link" aria-label="Direct link to Spring Cloud" title="Direct link to Spring Cloud">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="对-springcloud-了解多少">对 SpringCloud 了解多少？<a href="#对-springcloud-了解多少" class="hash-link" aria-label="Direct link to 对 SpringCloud 了解多少？" title="Direct link to 对 SpringCloud 了解多少？">​</a></h3>
<p>Spring Cloud 是一个基于 Spring Boot，提供构建分布式系统和微服务架构的工具集。用于解决分布式系统中的一些常见问题，如配置管理、服务发现、负载均衡等等。
<img decoding="async" loading="lazy" alt="1756999410726" src="/doc/assets/images/1756999410726-e96ffe4045d98e0fa386ace78c3fd169.png" width="1080" height="594" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是微服务">什么是微服务？<a href="#什么是微服务" class="hash-link" aria-label="Direct link to 什么是微服务？" title="Direct link to 什么是微服务？">​</a></h3>
<p>微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合，每一个微服务提供单个业务功能的服务，一个服务做一件事情，从技术角度看就是一种小而独立的处理过程，类似进程的概念，能够自行单独启动或销毁，拥有自己独立的数据库。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="微服务架构主要要解决哪些问题">微服务架构主要要解决哪些问题？<a href="#微服务架构主要要解决哪些问题" class="hash-link" aria-label="Direct link to 微服务架构主要要解决哪些问题？" title="Direct link to 微服务架构主要要解决哪些问题？">​</a></h3>
<p>服务很多，客户端怎么访问，如何提供对外网关?
这么多服务，服务之间如何通信? HTTP 还是 RPC?
这么多服务，如何治理? 服务的注册和发现。
服务挂了怎么办？熔断机制。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="springcloud-有哪些核心组件">SpringCloud 有哪些核心组件？<a href="#springcloud-有哪些核心组件" class="hash-link" aria-label="Direct link to SpringCloud 有哪些核心组件？" title="Direct link to SpringCloud 有哪些核心组件？">​</a></h3>
<p><img decoding="async" loading="lazy" alt="1756999489923" src="/doc/assets/images/1756999489923-e682b6ed93cb76589750b2858a3e0b30.png" width="2776" height="3368" class="img_ev3q"></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-tags-row"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a rel="tag" class="tag_zVej tagRegular_sFm0" href="/doc/docs/tags/interview">INTERVIEW</a></li><li class="tag_QGVx"><a rel="tag" class="tag_zVej tagRegular_sFm0" href="/doc/docs/tags/spring">SPRING</a></li></ul></div></div><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/SPRING/spring-review.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/doc/docs/intereview/redis"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">REDIS_REVIEW</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/doc/docs/tmp"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">tmp</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#基础" class="table-of-contents__link toc-highlight">基础</a><ul><li><a href="#spring是什么" class="table-of-contents__link toc-highlight">Spring是什么？</a></li><li><a href="#spring有哪些特性" class="table-of-contents__link toc-highlight">Spring有哪些特性？</a></li><li><a href="#简单说一下什么是aop和ioc" class="table-of-contents__link toc-highlight">简单说一下什么是AOP和IoC？</a></li><li><a href="#spring源码看过吗" class="table-of-contents__link toc-highlight">Spring源码看过吗？</a></li><li><a href="#spring有哪些模块呢" class="table-of-contents__link toc-highlight">Spring有哪些模块呢？</a></li><li><a href="#spring有哪些常用注解呢" class="table-of-contents__link toc-highlight">Spring有哪些常用注解呢？</a></li><li><a href="#spring用了哪些设计模式" class="table-of-contents__link toc-highlight">🌟Spring用了哪些设计模式？</a></li><li><a href="#spring如何实现单例模式" class="table-of-contents__link toc-highlight">Spring如何实现单例模式？</a></li><li><a href="#spring容器和web容器之间的区别知道吗补充" class="table-of-contents__link toc-highlight">Spring容器和Web容器之间的区别知道吗？（补充）</a></li></ul></li><li><a href="#ioc" class="table-of-contents__link toc-highlight">IoC</a><ul><li><a href="#说一说什么是ioc" class="table-of-contents__link toc-highlight">🌟说一说什么是IoC？</a></li><li><a href="#di和ioc的区别了解吗" class="table-of-contents__link toc-highlight">DI和IoC的区别了解吗？</a></li><li><a href="#为什么要使用-ioc-呢" class="table-of-contents__link toc-highlight">为什么要使用 IoC 呢？</a></li><li><a href="#能说一下ioc的实现机制吗" class="table-of-contents__link toc-highlight">能说一下IoC的实现机制吗？</a></li><li><a href="#你是怎么理解-spring-ioc-的" class="table-of-contents__link toc-highlight">你是怎么理解 Spring IoC 的？</a></li><li><a href="#能手写一个简单的-ioc-容器吗" class="table-of-contents__link toc-highlight">能手写一个简单的 IoC 容器吗？</a></li><li><a href="#说说beanfactory和applicantcontext的区别" class="table-of-contents__link toc-highlight">说说BeanFactory和ApplicantContext的区别?</a></li><li><a href="#项目启动时spring的ioc会做什么" class="table-of-contents__link toc-highlight">🌟项目启动时Spring的IoC会做什么？</a></li><li><a href="#说说spring的bean实例化方式" class="table-of-contents__link toc-highlight">说说Spring的Bean实例化方式？</a></li><li><a href="#你是怎么理解bean的" class="table-of-contents__link toc-highlight">你是怎么理解Bean的？</a></li><li><a href="#component-和-bean-有什么区别" class="table-of-contents__link toc-highlight">@Component 和 @Bean 有什么区别？</a></li><li><a href="#能说一下bean的生命周期吗" class="table-of-contents__link toc-highlight">🌟能说一下Bean的生命周期吗？</a></li><li><a href="#aware-类型的接口有什么作用" class="table-of-contents__link toc-highlight">Aware 类型的接口有什么作用？</a></li><li><a href="#如果配置了-init-method-和-destroy-methodspring-会在什么时候调用其配置的方法" class="table-of-contents__link toc-highlight">如果配置了 init-method 和 destroy-method，Spring 会在什么时候调用其配置的方法？</a></li><li><a href="#为什么idea不推荐使用autowired注解注入bean" class="table-of-contents__link toc-highlight">为什么IDEA不推荐使用@Autowired注解注入Bean？</a></li><li><a href="#autowired-和-resource-注解的区别" class="table-of-contents__link toc-highlight">@Autowired 和 @Resource 注解的区别？</a></li><li><a href="#autowired的实现原理了解吗" class="table-of-contents__link toc-highlight">@Autowired的实现原理了解吗？</a></li><li><a href="#什么是自动装配" class="table-of-contents__link toc-highlight">什么是自动装配？</a></li><li><a href="#spring提供了哪几种自动装配类型" class="table-of-contents__link toc-highlight">Spring提供了哪几种自动装配类型？</a></li><li><a href="#bean的作用域有哪些" class="table-of-contents__link toc-highlight">Bean的作用域有哪些?</a></li><li><a href="#spring中的单例bean会存在线程安全问题吗" class="table-of-contents__link toc-highlight">Spring中的单例Bean会存在线程安全问题吗？</a></li><li><a href="#单例bean的线程安全问题怎么解决呢" class="table-of-contents__link toc-highlight">单例Bean的线程安全问题怎么解决呢？</a></li><li><a href="#什么是循环依赖" class="table-of-contents__link toc-highlight">什么是循环依赖?</a></li><li><a href="#spring怎么解决循环依赖呢" class="table-of-contents__link toc-highlight">🌟Spring怎么解决循环依赖呢？</a></li><li><a href="#哪些情况下spring无法解决循环依赖" class="table-of-contents__link toc-highlight">哪些情况下Spring无法解决循环依赖？</a></li><li><a href="#为什么需要三级缓存而不是两级" class="table-of-contents__link toc-highlight">为什么需要三级缓存而不是两级？</a></li><li><a href="#如果缺少二级缓存会有什么问题" class="table-of-contents__link toc-highlight">如果缺少二级缓存会有什么问题？</a></li></ul></li><li><a href="#aop" class="table-of-contents__link toc-highlight">AOP</a><ul><li><a href="#说说什么是-aop" class="table-of-contents__link toc-highlight">🌟说说什么是 AOP？</a></li><li><a href="#spring-aop-有哪些核心概念" class="table-of-contents__link toc-highlight">Spring AOP 有哪些核心概念？</a></li><li><a href="#spring-aop-织入有哪几种方式" class="table-of-contents__link toc-highlight">Spring AOP 织入有哪几种方式？</a></li><li><a href="#aspectj-是什么" class="table-of-contents__link toc-highlight">AspectJ 是什么？</a></li><li><a href="#spring-aop-有哪些通知方式" class="table-of-contents__link toc-highlight">Spring AOP 有哪些通知方式？</a></li><li><a href="#spring-aop-发生在什么时候" class="table-of-contents__link toc-highlight">Spring AOP 发生在什么时候？</a></li><li><a href="#简单总结一下-aop" class="table-of-contents__link toc-highlight">简单总结一下 AOP</a></li><li><a href="#aop和-oop-的关系" class="table-of-contents__link toc-highlight">AOP和 OOP 的关系？</a></li><li><a href="#aop的应用场景有哪些" class="table-of-contents__link toc-highlight">🌟AOP的应用场景有哪些？</a></li><li><a href="#说说-spring-aop-和-aspectj-区别" class="table-of-contents__link toc-highlight">说说 Spring AOP 和 AspectJ 区别?</a></li><li><a href="#说说jdk动态代理和cglib代理的区别" class="table-of-contents__link toc-highlight">🌟说说JDK动态代理和CGLIB代理的区别？</a></li><li><a href="#选择-cglib-还是-jdk-动态代理" class="table-of-contents__link toc-highlight">选择 CGLIB 还是 JDK 动态代理？</a></li><li><a href="#你会用-jdk-动态代理吗" class="table-of-contents__link toc-highlight">你会用 JDK 动态代理吗？</a></li><li><a href="#你会用-cglib-动态代理吗" class="table-of-contents__link toc-highlight">你会用 CGLIB 动态代理吗？</a></li></ul></li><li><a href="#事务" class="table-of-contents__link toc-highlight">事务</a><ul><li><a href="#说说你对spring事务的理解" class="table-of-contents__link toc-highlight">🌟说说你对Spring事务的理解？</a></li><li><a href="#声明式事务的实现原理了解吗" class="table-of-contents__link toc-highlight">声明式事务的实现原理了解吗？</a></li><li><a href="#transactional在哪些情况下会失效" class="table-of-contents__link toc-highlight">@Transactional在哪些情况下会失效？</a></li><li><a href="#说说spring的事务传播机制" class="table-of-contents__link toc-highlight">🌟说说Spring的事务传播机制？</a></li><li><a href="#事务能在新线程中传播吗" class="table-of-contents__link toc-highlight">事务能在新线程中传播吗？</a></li><li><a href="#protected-和-private-方法加事务会生效吗" class="table-of-contents__link toc-highlight">protected 和 private 方法加事务会生效吗？</a></li></ul></li><li><a href="#mvc" class="table-of-contents__link toc-highlight">MVC</a><ul><li><a href="#spring-mvc-的核心组件有哪些" class="table-of-contents__link toc-highlight">Spring MVC 的核心组件有哪些？</a></li><li><a href="#spring-mvc-的工作流程了解吗" class="table-of-contents__link toc-highlight">🌟Spring MVC 的工作流程了解吗？</a></li><li><a href="#为什么还需要-handleradapter" class="table-of-contents__link toc-highlight">为什么还需要 HandlerAdapter？</a></li><li><a href="#springmvc-restful-风格的接口流程是什么样的呢" class="table-of-contents__link toc-highlight">SpringMVC Restful 风格的接口流程是什么样的呢？</a></li></ul></li><li><a href="#spring-boot" class="table-of-contents__link toc-highlight">Spring Boot</a><ul><li><a href="#介绍一下-springboot" class="table-of-contents__link toc-highlight">🌟介绍一下 SpringBoot？</a></li><li><a href="#spring-boot常用注解有哪些" class="table-of-contents__link toc-highlight">Spring Boot常用注解有哪些？</a></li><li><a href="#spring-boot的自动装配原理了解吗" class="table-of-contents__link toc-highlight">🌟Spring Boot的自动装配原理了解吗？</a></li><li><a href="#如何自定义一个-springboot-starter" class="table-of-contents__link toc-highlight">🌟如何自定义一个 SpringBoot Starter?</a></li><li><a href="#spring-boot-starter-的原理了解吗" class="table-of-contents__link toc-highlight">Spring Boot Starter 的原理了解吗？</a></li><li><a href="#spring-boot-启动原理了解吗" class="table-of-contents__link toc-highlight">🌟Spring Boot 启动原理了解吗？</a></li><li><a href="#了解springbootapplication-注解吗" class="table-of-contents__link toc-highlight">了解@SpringBootApplication 注解吗？</a></li><li><a href="#为什么-spring-boot-在启动的时候能够找到-main-方法上的springbootapplication-注解" class="table-of-contents__link toc-highlight">为什么 Spring Boot 在启动的时候能够找到 main 方法上的@SpringBootApplication 注解？</a></li><li><a href="#spring-boot-默认的包扫描路径是什么" class="table-of-contents__link toc-highlight">Spring Boot 默认的包扫描路径是什么？</a></li><li><a href="#springboot-和-springmvc-的区别补充" class="table-of-contents__link toc-highlight">SpringBoot 和 SpringMVC 的区别？（补充）</a></li><li><a href="#spring-boot-和-spring-有什么区别补充" class="table-of-contents__link toc-highlight">Spring Boot 和 Spring 有什么区别？（补充）</a></li></ul></li><li><a href="#spring-cloud" class="table-of-contents__link toc-highlight">Spring Cloud</a><ul><li><a href="#对-springcloud-了解多少" class="table-of-contents__link toc-highlight">对 SpringCloud 了解多少？</a></li><li><a href="#什么是微服务" class="table-of-contents__link toc-highlight">什么是微服务？</a></li><li><a href="#微服务架构主要要解决哪些问题" class="table-of-contents__link toc-highlight">微服务架构主要要解决哪些问题？</a></li><li><a href="#springcloud-有哪些核心组件" class="table-of-contents__link toc-highlight">SpringCloud 有哪些核心组件？</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/doc/docs/intro">Tutorial</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://x.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">X<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/doc/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>