<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-java/java_concurrent" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.8.1">
<title data-rh="true">java_concurrent | My Site</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://your-docusaurus-site.example.com/doc/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://your-docusaurus-site.example.com/doc/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://your-docusaurus-site.example.com/doc/docs/java/java_concurrent"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="java_concurrent | My Site"><meta data-rh="true" name="description" content="基础"><meta data-rh="true" property="og:description" content="基础"><link data-rh="true" rel="icon" href="/doc/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://your-docusaurus-site.example.com/doc/docs/java/java_concurrent"><link data-rh="true" rel="alternate" href="https://your-docusaurus-site.example.com/doc/docs/java/java_concurrent" hreflang="en"><link data-rh="true" rel="alternate" href="https://your-docusaurus-site.example.com/doc/docs/java/java_concurrent" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"java","item":"https://your-docusaurus-site.example.com/doc/docs/java/"},{"@type":"ListItem","position":2,"name":"java_concurrent","item":"https://your-docusaurus-site.example.com/doc/docs/java/java_concurrent"}]}</script><link rel="alternate" type="application/rss+xml" href="/doc/blog/rss.xml" title="My Site RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/doc/blog/atom.xml" title="My Site Atom Feed"><link rel="stylesheet" href="/doc/assets/css/styles.a7778f11.css">
<script src="/doc/assets/js/runtime~main.6d11ab78.js" defer="defer"></script>
<script src="/doc/assets/js/main.6f7b6557.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t="light";var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",e||t),document.documentElement.setAttribute("data-theme-choice",e||t)}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/doc/img/logo.svg"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/doc/"><div class="navbar__logo"><img src="/doc/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/doc/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">My Site</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/doc/docs/intro">Tutorial</a><a class="navbar__item navbar__link" href="/doc/blog">Blog</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="Switch between dark and light mode (currently system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/doc/docs/intro">Tutorial Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/doc/docs/category/tutorial---basics">Tutorial - Basics</a><button aria-label="Expand sidebar category &#x27;Tutorial - Basics&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/doc/docs/category/tutorial---extras">Tutorial - Extras</a><button aria-label="Expand sidebar category &#x27;Tutorial - Extras&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/doc/docs/java/">java</a><button aria-label="Collapse sidebar category &#x27;java&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/doc/docs/java/java-aqs">java-aqs</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/doc/docs/INTERVIEW/JAVA/JVM">JAVA-JVM</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/doc/docs/java/java_collection_review">java_collection_review</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/doc/docs/java/java_concurrent">java_concurrent</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/doc/docs/java/java_review">java_review</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/intereview/rocketmq">mq</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/mysql/mysql-review">mysql</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/nginx/nginx-review">nginx</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/intereview/redis">redis</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/spring/spring-review">spring</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/doc/docs/tmp">tmp</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/分布式/分布式 -review">分布式</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/微服务/微服务-review">微服务</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/doc/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><a class="breadcrumbs__link" href="/doc/docs/java/"><span>java</span></a></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">java_concurrent</span></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>java_concurrent</h1></header><h2 class="anchor anchorWithStickyNavbar_LWe7" id="基础">基础<a href="#基础" class="hash-link" aria-label="Direct link to 基础" title="Direct link to 基础">​</a></h2>
<p>并行跟并发有什么区别？
并行是多核 CPU 上的多任务处理，多个任务在同一时间真正地同时执行。
并发是单核 CPU 上的多任务处理，多个任务在同一时间段内交替执行，通过时间片轮转实现交替执行，用于解决 IO 密集型任务的瓶颈。
举个例子，就好像我们去食堂打饭，并行就是每个人对应一个阿姨，同时打饭；而并发就是一个阿姨，轮流给每个人打饭，假如有个人磨磨唧唧，阿姨就会吆喝下一个人，这样就能提高食堂的打饭效率。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="你是如何理解线程安全的">你是如何理解线程安全的？<a href="#你是如何理解线程安全的" class="hash-link" aria-label="Direct link to 你是如何理解线程安全的？" title="Direct link to 你是如何理解线程安全的？">​</a></h3>
<p>推荐阅读：多线程带来了哪些问题？
如果一段代码块或者一个方法被多个线程同时执行，还能够正确地处理共享数据，那么这段代码块或者这个方法就是线程安全的。
可以从三个要素来确保线程安全：
①、原子性：一个操作要么完全执行，要么完全不执行，不会出现中间状态。
<img decoding="async" loading="lazy" alt="线程原子性" src="/doc/assets/images/线程原子性-22462c8134d95b26f1112fa153b67478.png" width="1234" height="630" class="img_ev3q">
可以通过同步关键字 synchronized 或原子操作，如 AtomicInteger 来保证原子性。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">AtomicInteger count = new AtomicInteger(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">count.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">incrementAndGet(); // 原子操作</span><br></span></code></pre></div></div>
<p>②、可见性：当一个线程修改了共享变量，其他线程能够立即看到变化。
<img decoding="async" loading="lazy" alt="线程可见性" src="/doc/assets/images/线程可见性-ffe78e6b69d8982bf46b0850ff454ce8.png" width="796" height="914" class="img_ev3q"></p>
<p>③、有序性：要确保线程不会因为死锁、饥饿、活锁等问题导致无法继续执行。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private volatile String itwanger = &quot;沉默王二&quot;;</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说进程和线程的区别">🌟说说进程和线程的区别？<a href="#说说进程和线程的区别" class="hash-link" aria-label="Direct link to 🌟说说进程和线程的区别？" title="Direct link to 🌟说说进程和线程的区别？">​</a></h3>
<p>推荐阅读:进程与线程的区别是什么？
进程说简单点就是我们在电脑上启动的一个个应用。它是操作系统分配资源的最小单位。
线程是进程中的独立执行单元。多个线程可以共享同一个进程的资源，如内存；每个线程都有自己独立的栈和寄存器。
<img decoding="async" loading="lazy" alt="线程和进程" src="/doc/assets/images/线程和进程-39faec3e36f8e547e402d25576e45c76.png" width="744" height="454" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何理解协程">如何理解协程？<a href="#如何理解协程" class="hash-link" aria-label="Direct link to 如何理解协程？" title="Direct link to 如何理解协程？">​</a></h3>
<p>协程被视为比线程更轻量级的并发单元，可以在单线程中实现并发执行，由我们开发者显式调度。
协程是在用户态进行调度的，避免了线程切换时的内核态开销。
Java 自身是不支持协程的，我们可以使用 Quasar、Kotlin 等框架来实现协程。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fun main() =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">runBlocking {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    launch {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        delay(1000L)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(&quot;World!&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;Hello,&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="线程间是如何进行通信的">线程间是如何进行通信的？<a href="#线程间是如何进行通信的" class="hash-link" aria-label="Direct link to 线程间是如何进行通信的？" title="Direct link to 线程间是如何进行通信的？">​</a></h3>
<p>原则上可以通过消息传递和共享内存两种方法来实现。Java 采用的是共享内存的并发模型。
这个模型被称为 Java 内存模型，简写为 JMM，它决定了一个线程对共享变量的写入，何时对另外一个线程可见。当然了，本地内存是 JMM
的一个抽象概念，并不真实存在。
用一句话来概括就是：共享变量存储在主内存中，每个线程的私有本地内存，存储的是这个共享变量的副本。
<img decoding="async" loading="lazy" alt="共享内存通信" src="/doc/assets/images/共享内存通信-941c15c9a0f467f8e5232fb366bf1d54.png" width="423" height="377" class="img_ev3q">
线程 A 与线程 B 之间如要通信，需要要经历 2 个步骤：
线程 A 把本地内存 A 中的共享变量副本刷新到主内存中。
线程 B 到主内存中读取线程 A 刷新过的共享变量，再同步到自己的共享变量副本中。
<img decoding="async" loading="lazy" alt="共享内存通信1" src="data:image/png;base64,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" width="440" height="334" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说线程有几种创建方式">🌟说说线程有几种创建方式？<a href="#说说线程有几种创建方式" class="hash-link" aria-label="Direct link to 🌟说说线程有几种创建方式？" title="Direct link to 🌟说说线程有几种创建方式？">​</a></h3>
<p>推荐阅读：室友打了一把王者就学会了 Java 多线程
有三种，分别是继承 Thread 类、实现 Runnable 接口、实现 Callable 接口。
第一种需要重写父类 Thread 的 run() 方法，并且调用 start() 方法启动线程。
第二种需要重写 Runnable 接口的 run() 方法，并将实现类的对象作为参数传递给 Thread 对象的构造方法，最后调用 start() 方法启动线程。
这种方法的优点是可以避免 Java 的单继承限制，并且更符合面向对象的编程思想，因为 Runnable 接口将任务代码和线程控制的代码解耦了。
第三种需要重写 Callable 接口的 call() 方法，然后创建 FutureTask 对象，参数为 Callable 实现类的对象；紧接着创建 Thread
对象，参数为 FutureTask 对象，最后调用 start() 方法启动线程。
这种方法的优点是可以获取线程的执行结果。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="一个-8g-内存的系统最多能创建多少个线程">一个 8G 内存的系统最多能创建多少个线程?<a href="#一个-8g-内存的系统最多能创建多少个线程" class="hash-link" aria-label="Direct link to 一个 8G 内存的系统最多能创建多少个线程?" title="Direct link to 一个 8G 内存的系统最多能创建多少个线程?">​</a></h3>
<p>推荐阅读：深入理解 JVM 的运行时数据区
理论上大约 8000 个。
创建线程的时候，至少需要分配一个虚拟机栈，在 64 位操作系统中，默认大小为 1M，因此一个线程大约需要 1M 的内存。
但 JVM、操作系统本身的运行就要占一定的内存空间，所以实际上可以创建的线程数远比 8000 少。
详细解释一下。
可以通过 java -XX:+PrintFlagsFinal -version | grep ThreadStackSize 命令查看 JVM 栈的默认大小。
<img decoding="async" loading="lazy" alt="jvm栈内存大小设置" src="/doc/assets/images/jvm栈内存大小设置-dd0d764a3d1589398539be91b286e8d6.png" width="1716" height="354" class="img_ev3q">
其中 ThreadStackSize 的单位是 KB，也就是说默认的 JVM 栈大小是 1024 KB，也就是 1M。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="启动一个-java-程序你能说说里面有哪些线程吗">启动一个 Java 程序，你能说说里面有哪些线程吗？<a href="#启动一个-java-程序你能说说里面有哪些线程吗" class="hash-link" aria-label="Direct link to 启动一个 Java 程序，你能说说里面有哪些线程吗？" title="Direct link to 启动一个 Java 程序，你能说说里面有哪些线程吗？">​</a></h3>
<p>首先是 main 线程，这是程序执行的入口。
然后是垃圾回收线程，它是一个后台线程，负责回收不再使用的对象。
还有编译器线程，比如 JIT，负责把一部分热点代码编译后放到 codeCache 中。
<img decoding="async" loading="lazy" alt="java中运行的线程" src="/doc/assets/images/java中运行的线程-1f605bc38eaa8d78151572694347e369.png" width="928" height="930" class="img_ev3q"></p>
<p>可以通过下面的代码进行检测：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class ThreadLister {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 获取所有线程的堆栈跟踪</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Map&lt;Thread, StackTraceElement[]&gt; threads = Thread.getAllStackTraces();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (Thread thread : threads.keySet()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;Thread: &quot; + thread.getName() + &quot; (ID=&quot; + thread.getId() + &quot;)&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>简单解释下：
Thread: main (ID=1) - 主线程，Java 程序启动时由 JVM 创建。
Thread: Reference Handler (ID=2) - 这个线程是用来处理引用对象的，如软引用、弱引用和虚引用。负责清理被 JVM 回收的对象。
Thread: Finalizer (ID=3) - 终结器线程，负责调用对象的 finalize 方法。对象在垃圾回收器标记为可回收之前，由该线程执行其
finalize 方法，用于执行特定的资源释放操作。
Thread: Signal Dispatcher (ID=4) - 信号调度线程，处理来自操作系统的信号，将它们转发给 JVM 进行进一步处理，例如响应中断、停止等信号。
Thread: Monitor Ctrl-Break (ID=5) - 监视器线程，通常由一些特定的 IDE 创建，用于在开发过程中监控和管理程序执行或者处理中断。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="调用-start-方法时会执行-run-方法那怎么不直接调用-run方法">🌟调用 start 方法时会执行 run 方法，那怎么不直接调用 run方法？<a href="#调用-start-方法时会执行-run-方法那怎么不直接调用-run方法" class="hash-link" aria-label="Direct link to 🌟调用 start 方法时会执行 run 方法，那怎么不直接调用 run方法？" title="Direct link to 🌟调用 start 方法时会执行 run 方法，那怎么不直接调用 run方法？">​</a></h3>
<p>调用 start() 会创建一个新的线程，并异步执行 run() 方法中的代码。
直接调用 run() 方法只是一个普通的同步方法调用，所有代码都在当前线程中执行，不会创建新线程。没有新的线程创建，也就达不到多线程并发的目的。
通过敲代码体验一下。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class MyThread extends Thread {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(Thread.currentThread().getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        MyThread t1 = new MyThread();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t1.start(); // 正确的方式，创建一个新线程，并在新线程中执行 run()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t1.run(); // 仅在主线程中执行 run()，没有创建新线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>也就是说，调用 start() 方法会通知 JVM，去调用底层的线程调度机制来启动新线程。
<img decoding="async" loading="lazy" alt="启动线程" src="/doc/assets/images/启动线程-d6093790d1bf49c67e89618c1120a550.png" width="559" height="422" class="img_ev3q">
调用 start() 后，线程进入就绪状态，等待操作系统调度；一旦调度执行，线程会执行其 run() 方法中的代码。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="线程有哪些常用的调度方法">线程有哪些常用的调度方法？<a href="#线程有哪些常用的调度方法" class="hash-link" aria-label="Direct link to 线程有哪些常用的调度方法？" title="Direct link to 线程有哪些常用的调度方法？">​</a></h3>
<p>比如说 start 方法用于启动线程并让操作系统调度执行；sleep 方法用于让当前线程休眠一段时间；wait 方法会让当前线程等待，notify
会唤醒一个等待的线程。
<img decoding="async" loading="lazy" alt="线程通信" src="/doc/assets/images/线程通信-7dfcde8ccba7ea5623ca9b54bcd6d9a7.png" width="617" height="532" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说wait方法和notify方法">说说wait方法和notify方法？<a href="#说说wait方法和notify方法" class="hash-link" aria-label="Direct link to 说说wait方法和notify方法？" title="Direct link to 说说wait方法和notify方法？">​</a></h3>
<p>当线程 A 调用共享对象的 wait() 方法时，线程 A 会被阻塞挂起，直到： 线程 B 调用了共享对象的 notify() 方法或者 notifyAll()
方法；
其他线程调用线程 A 的 interrupt() 方法，导致线程 A 抛出 InterruptedException 异常。
线程 A 调用共享对象的 wait(timeout)方法后，没有在指定的 timeout 时间内被其它线程唤醒，那么这个方法会因为超时而返回。</p>
<p>当线程 A 调用共享对象的 notify() 方法后，会唤醒一个在这个共享对象上调用 wait 系列方法被挂起的线程。
共享对象上可能会有多个线程在等待，具体唤醒哪个线程是随机的。
如果调用的是 notifyAll 方法，会唤醒所有在这个共享变量上调用 wait 系列方法而被挂起的线程。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说-sleep-方法">说说 sleep 方法？<a href="#说说-sleep-方法" class="hash-link" aria-label="Direct link to 说说 sleep 方法？" title="Direct link to 说说 sleep 方法？">​</a></h3>
<p>当线程 A 调用了 Thread 的 sleep 方法后，线程 A 会暂时让出指定时间的执行权。
指定的睡眠时间到了后该方法会正常返回，接着参与 CPU 调度，获取到 CPU 资源后可以继续执行。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说yield方法">说说yield方法？<a href="#说说yield方法" class="hash-link" aria-label="Direct link to 说说yield方法？" title="Direct link to 说说yield方法？">​</a></h3>
<p>yield() 方法的目的是让当前线程让出 CPU 使用权，回到就绪状态。但是线程调度器可能会忽略</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说interrupt方法">说说interrupt方法？<a href="#说说interrupt方法" class="hash-link" aria-label="Direct link to 说说interrupt方法？" title="Direct link to 说说interrupt方法？">​</a></h3>
<p>推荐阅读：interrupt 方法
interrupt() 方法用于通知线程停止，但不会直接终止线程，需要线程自行处理中断标志。
常与 isInterrupted() 或 Thread.interrupted() 配合使用。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Thread thread = new Thread(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (!Thread.currentThread().isInterrupted()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;Running&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Interrupted&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    thread.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    thread.interrupt(); // 中断线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说-stop-方法">说说 stop 方法？<a href="#说说-stop-方法" class="hash-link" aria-label="Direct link to 说说 stop 方法？" title="Direct link to 说说 stop 方法？">​</a></h3>
<p>stop 方法用来强制停止线程，目前已经处于废弃状态，因为 stop 方法可能会在不一致的状态下释放锁，破坏对象的一致性。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="线程有几种状态">🌟线程有几种状态？<a href="#线程有几种状态" class="hash-link" aria-label="Direct link to 🌟线程有几种状态？" title="Direct link to 🌟线程有几种状态？">​</a></h3>
<p>6 种。</p>
<ol>
<li>new 代表线程被创建但未启动</li>
<li>runnable 代表线程处于就绪或正在运行状态，由操作系统调度</li>
<li>blocked 代表线程被阻塞，等待获取锁</li>
<li>waiting 代表线程等待其他线程的通知或中断</li>
<li>timed_waiting 代表线程会等待一段时间，超时后自动恢复</li>
<li>terminated 代表线程执行完毕，生命周期结束
<img decoding="async" loading="lazy" alt="线程状态" src="/doc/assets/images/线程状态-85493ffcb151a9831453644a4285f694.png" width="1037" height="708" class="img_ev3q">
也就是说，线程的生命周期可以分为五个主要阶段：新建、就绪、运行、阻塞和终止。线程在运行过程中会根据状态的变化在这些阶段之间切换。</li>
</ol>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class ThreadStateExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread thread = new Thread(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Thread.sleep(2000); // TIMED_WAITING</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                synchronized (ThreadStateExample.class) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ThreadStateExample.class.wait(); // WAITING</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Thread.currentThread().interrupt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;State after creation: &quot; + thread.getState()); // NEW</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;State after start: &quot; + thread.getState()); // RUNNABLE</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread.sleep(2500); // 这里的时间要比子线程的多，不然会提前唤醒</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;State while sleeping: &quot; + thread.getState()); // TIMED_WAITING</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        synchronized (ThreadStateExample.class) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ThreadStateExample.class.notify(); // 唤醒线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread.join();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;State after termination: &quot; + thread.getState()); // TERMINATED</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>总结说明</p>
<ol>
<li>NEW：当线程被创建后，如通过new Thread()，它处于新建状态。此时，线程已经被分配了必要的资源，但还没有开始执行。</li>
<li>RUNNABLE： 当调用线程的start()方法后，线程进入可运行状态。在这个状态下，线程可能正在运行也可能正在等待获取 CPU
时间片，具体取决于线程调度器的调度策略。</li>
<li>BLOCKED： 线程在<strong>试图获取一个锁以进入同步块/方法时如果锁被其他线程持有</strong>，线程将进入阻塞状态，直到它获取到锁。
（这里的意思是只有使用synchronized且将线程唤醒时，线程没有获取到锁才进入这个状态）</li>
<li>WAITING： 线程进入等待状态是因为调用了如下方法之一：Object.wait()或LockSupport.park()。在等待状态下，*
<em>线程需要其他线程显式地唤醒，否则不会自动执行</em>*。</li>
<li>TIME_WAITING 当线程调用带有超时参数的方法时，如Thread.sleep(long millis)、Object.wait(long timeout)
或LockSupport.parkNanos()，它将进入超时等待状态。线程在指定的等待时间过后会自动返回可运行状态。</li>
<li>TERMINATED 当线程的run()方法执行完毕后，或者因为一个未捕获的异常终止了执行，线程进入终止状态。一旦线程终止，它的生命周期结束，不能再被重新启动。</li>
</ol>
<p>AQS框架的锁竞争失败后会进入到WAITING / TIMED_WAITING</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何强制终止线程">如何强制终止线程？<a href="#如何强制终止线程" class="hash-link" aria-label="Direct link to 如何强制终止线程？" title="Direct link to 如何强制终止线程？">​</a></h3>
<p>第一步，调用线程的 interrupt() 方法，请求终止线程。
第二步，在线程的 run() 方法中检查中断状态，如果线程被中断，就退出线程。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class MyTask implements Runnable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (!Thread.currentThread().isInterrupted()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;Running...&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Thread.sleep(1000); // 模拟工作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 捕获中断异常后，重置中断状态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Thread.currentThread().interrupt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;Thread interrupted, exiting...&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread thread = new Thread(new MyTask());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread.sleep(3000); // 主线程等待3秒</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread.interrupt(); // 请求终止线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是线程上下文切换">什么是线程上下文切换？<a href="#什么是线程上下文切换" class="hash-link" aria-label="Direct link to 什么是线程上下文切换？" title="Direct link to 什么是线程上下文切换？">​</a></h3>
<p>线程上下文切换是指 CPU 从一个线程切换到另一个线程执行时的过程。
在线程切换的过程中，CPU 需要保存当前线程的执行状态，并加载下一个线程的上下文。
之所以要这样，是因为 CPU 在同一时刻只能执行一个线程，为了实现多线程并发执行，需要不断地在多个线程之间切换。
<img decoding="async" loading="lazy" alt="线程执行中的上下文切换" src="data:image/png;base64,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" width="755" height="423" class="img_ev3q">
为了让用户感觉多个线程是在同时执行的， CPU 资源的分配采用了时间片轮转的方式，线程在时间片内占用 CPU 执行任务。当线程使用完时间片后，就会让出
CPU 让其他线程占用。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="线程可以被多核调度吗">线程可以被多核调度吗？<a href="#线程可以被多核调度吗" class="hash-link" aria-label="Direct link to 线程可以被多核调度吗？" title="Direct link to 线程可以被多核调度吗？">​</a></h3>
<p>多核处理器提供了并行执行多个线程的能力。每个核心可以独立执行一个或多个线程，操作系统的任务调度器会根据策略和算法，如优先级调度、轮转调度等，决定哪个线程何时在哪个核心上运行。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="守护线程了解吗">守护线程了解吗？<a href="#守护线程了解吗" class="hash-link" aria-label="Direct link to 守护线程了解吗？" title="Direct link to 守护线程了解吗？">​</a></h3>
<p>了解，守护线程是一种特殊的线程，它的作用是为其他线程提供服务。
Java 中的线程分为两类，一种是守护线程，另外一种是用户线程。
JVM 启动时会调用 main 方法，main 方法所在的线程就是一个用户线程。
在 JVM 内部，同时还启动了很多守护线程，比如垃圾回收线程。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="守护线程和用户线程有什么区别呢">守护线程和用户线程有什么区别呢？<a href="#守护线程和用户线程有什么区别呢" class="hash-link" aria-label="Direct link to 守护线程和用户线程有什么区别呢？" title="Direct link to 守护线程和用户线程有什么区别呢？">​</a></h3>
<p>区别之一是当最后一个非守护线程束时， JVM 会正常退出，不管当前是否存在守护线程，也就是说守护线程是否结束并不影响 JVM 退出。
换而言之，只要有一个用户线程还没结束，正常情况下 JVM 就不会退出。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="线程间有哪些通信方式">线程间有哪些通信方式？<a href="#线程间有哪些通信方式" class="hash-link" aria-label="Direct link to 线程间有哪些通信方式？" title="Direct link to 线程间有哪些通信方式？">​</a></h3>
<p>线程之间传递信息的方式有多种，比如说使用 volatile 和 synchronized 关键字共享对象、使用 wait() 和 notify() 方法实现生产者-消费者模式、使用
Exchanger 进行数据交换、使用 Condition 实现线程间的协调等。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="简单说说-volatile-和-synchronized-的使用方式">简单说说 volatile 和 synchronized 的使用方式？<a href="#简单说说-volatile-和-synchronized-的使用方式" class="hash-link" aria-label="Direct link to 简单说说 volatile 和 synchronized 的使用方式？" title="Direct link to 简单说说 volatile 和 synchronized 的使用方式？">​</a></h3>
<p>多个线程可以通过 volatile 和 synchronized 关键字访问和修改同一个对象，从而实现信息的传递。
关键字 volatile 可以用来修饰成员变量，告知程序任何对该变量的访问均需要从共享内存中获取，并同步刷新回共享内存，保证所有线程对变量访问的可见性。
关键字 synchronized 可以修饰方法，或者同步代码块，确保多个线程在同一个时刻只有一个线程在执行方法或代码块。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class SharedObject {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String message;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private boolean hasMessage = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized void writeMessage(String message) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (hasMessage) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                wait();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Thread.currentThread().interrupt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.message = message;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        hasMessage = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        notifyAll();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized String readMessage() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (!hasMessage) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                wait();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Thread.currentThread().interrupt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        hasMessage = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        notifyAll();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return message;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SharedObject sharedObject = new SharedObject();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread writer = new Thread(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sharedObject.writeMessage(&quot;Hello from Writer!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread reader = new Thread(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String message = sharedObject.readMessage();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;Reader received: &quot; + message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        writer.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        reader.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="wait-和-notify-方法的使用方式了解吗">wait() 和 notify() 方法的使用方式了解吗？<a href="#wait-和-notify-方法的使用方式了解吗" class="hash-link" aria-label="Direct link to wait() 和 notify() 方法的使用方式了解吗？" title="Direct link to wait() 和 notify() 方法的使用方式了解吗？">​</a></h3>
<p>一个线程调用共享对象的 wait() 方法时，它会进入该对象的等待池，释放已经持有的锁，进入等待状态。
一个线程调用 notify() 方法时，它会唤醒在该对象等待池中等待的一个线程，使其进入锁池，等待获取锁。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class MessageBox {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String message;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private boolean empty = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized void produce(String message) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (!empty) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                wait();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Thread.currentThread().interrupt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        empty = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.message = message;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        notifyAll();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized String consume() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (empty) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                wait();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Thread.currentThread().interrupt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        empty = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        notifyAll();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return message;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Main {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        MessageBox box = new MessageBox();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread producer = new Thread(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            box.produce(&quot;Message from producer&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread consumer = new Thread(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String message = box.consume();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;Consumer received: &quot; + message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        producer.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        consumer.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>通常与锁 ReentrantLock 一起使用，为线程提供了一种等待某个条件成真的机制，并允许其他线程在该条件变化时通知等待线程。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="exchanger-的使用方式了解吗">Exchanger 的使用方式了解吗？<a href="#exchanger-的使用方式了解吗" class="hash-link" aria-label="Direct link to Exchanger 的使用方式了解吗？" title="Direct link to Exchanger 的使用方式了解吗？">​</a></h3>
<p>Exchanger 是一个同步点，可以在两个线程之间交换数据。一个线程调用 exchange() 方法，将数据传递给另一个线程，同时接收另一个线程的数据。
<strong>ps:我尝试使用3个线程，会导致阻塞？</strong></p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class ExchangerTest {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Exchanger&lt;String&gt; exchanger = new Exchanger&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread thread1 = new Thread(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                String message = &quot;Message from thread1&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                String response = exchanger.exchange(message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;Thread1 received: &quot; + response);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Thread.currentThread().interrupt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread thread2 = new Thread(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                String message = &quot;Message from thread2&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                String response = exchanger.exchange(message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;Thread2 received: &quot; + response);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Thread.currentThread().interrupt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread1.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread2.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="completablefuture-的使用方式了解吗">CompletableFuture 的使用方式了解吗？<a href="#completablefuture-的使用方式了解吗" class="hash-link" aria-label="Direct link to CompletableFuture 的使用方式了解吗？" title="Direct link to CompletableFuture 的使用方式了解吗？">​</a></h3>
<p>CompletableFuture 是 Java 8 引入的一个类，支持异步编程，允许线程在完成计算后将结果传递给其他线程。
<strong>me: 只要使用 CompletableFuture，就一定要考虑异常处理。使用 exceptionally, handle,
whenComplete等方法，确保异常能被妥善处理或记录，避免异常被“吞掉”</strong></p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 模拟长时间计算</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return &quot;Message from CompletableFuture&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    future.thenAccept(message -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Received: &quot; + message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="请说说-sleep-和-wait-的区别补充">🌟请说说 sleep 和 wait 的区别？（补充）<a href="#请说说-sleep-和-wait-的区别补充" class="hash-link" aria-label="Direct link to 🌟请说说 sleep 和 wait 的区别？（补充）" title="Direct link to 🌟请说说 sleep 和 wait 的区别？（补充）">​</a></h3>
<p>sleep 会让当前线程休眠，不需要获取对象锁，属于 Thread 类的方法；
wait 会让获得对象锁的线程等待，要提前获得对象锁，属于 Object 类的方法。</p>
<ol>
<li>
<p>所属类不同
sleep() 方法专属于 Thread 类 , wait() 方法专属于 Object 类,</p>
</li>
<li>
<p>锁行为不同
如果一个线程在持有某个对象锁时调用了 sleep 方法，它在睡眠期间仍然会持有这个锁。</p>
</li>
<li>
<p>使用条件不同
sleep() 方法可以在任何地方被调用。
wait() 方法必须在同步代码块或同步方法中被调用，这是因为调用 wait() 方法的前提是当前线程必须持有对象的锁。否则会抛出
IllegalMonitorStateException 异常。</p>
</li>
<li>
<p>唤醒方式不同
调用 sleep 方法后，线程会进入 TIMED_WAITING 状态，即在指定的时间内暂停执行。当指定的时间结束后，线程会自动恢复到 RUNNABLE
状态，等待 CPU 调度再次执行。
调用 wait 方法后，线程会进入 WAITING 状态，直到有其他线程在同一对象上调用 notify 或 notifyAll 方法，线程才会从 WAITING
状态转变为 RUNNABLE 状态，准备再次获得 CPU 的执行权。</p>
</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="怎么保证线程安全补充">🌟怎么保证线程安全？（补充）<a href="#怎么保证线程安全补充" class="hash-link" aria-label="Direct link to 🌟怎么保证线程安全？（补充）" title="Direct link to 🌟怎么保证线程安全？（补充）">​</a></h3>
<p>线程安全是指在并发环境下，多个线程访问共享资源时，程序能够正确地执行，而不会出现数据不一致的问题。
为了保证线程安全，可以使用 synchronized 关键字对方法加锁，对代码块加锁。
线程在执行同步方法、同步代码块时，会获取类锁或者对象锁，其他线程就会阻塞并等待锁。
如果需要更细粒度的锁，可以使用 ReentrantLock 并发重入锁等。
如果需要保证变量的内存可见性，可以使用 volatile 关键字。</p>
<p>对于简单的原子变量操作，还可以使用 Atomic 原子类。</p>
<p>对于线程独立的数据，可以使用 ThreadLocal 来为每个线程提供专属的变量副本。</p>
<p>对于需要并发容器的地方，可以使用 ConcurrentHashMap、CopyOnWriteArrayList 等。</p>
<p>有个int的变量为0，十个线程轮流对其进行++操作（循环10000次），结果大于10 万还是小于等于10万，为什么？
在这个场景中，最终的结果会小于 100000，原因是多线程环境下，++ 操作并不是一个原子操作，而是分为读取、加 1、写回三个步骤。
读取变量的值 -&gt; 将读取到的值加 -&gt; 将结果写回变量。
这样的话，就会有多个线程读取到相同的值，然后对这个值进行加 1 操作，最终导致结果小于 100000。</p>
<p>详细解释下。
多个线程在并发执行 ++ 操作时，可能出现以下竞态条件：
线程 1 读取变量值为 0。
线程 2 也读取变量值为 0。
线程 1 进行加法运算并将结果 1 写回变量。
线程 2 进行加法运算并将结果 1 写回变量，覆盖了线程 1 的结果。</p>
<p>可以通过 synchronized 关键字为 ++ 操作加锁。
或者使用 AtomicInteger 的 incrementAndGet() 方法来替代 ++ 操作，保证变量的原子性。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="场景有一个-key-对应的-value-是一个json-结构json-当中有好几个子任务这些子任务如果对-key-进行修改的话会不会存在线程安全的问题">场景:有一个 key 对应的 value 是一个json 结构，json 当中有好几个子任务，这些子任务如果对 key 进行修改的话，会不会存在线程安全的问题？<a href="#场景有一个-key-对应的-value-是一个json-结构json-当中有好几个子任务这些子任务如果对-key-进行修改的话会不会存在线程安全的问题" class="hash-link" aria-label="Direct link to 场景:有一个 key 对应的 value 是一个json 结构，json 当中有好几个子任务，这些子任务如果对 key 进行修改的话，会不会存在线程安全的问题？" title="Direct link to 场景:有一个 key 对应的 value 是一个json 结构，json 当中有好几个子任务，这些子任务如果对 key 进行修改的话，会不会存在线程安全的问题？">​</a></h3>
<p>在单节点环境中，可以使用 synchronized 关键字或 ReentrantLock 来保证对 key 的修改操作是原子的。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class KeyManager {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final ReentrantLock lock = new ReentrantLock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String key = &quot;{\&quot;tasks\&quot;: [\&quot;task1\&quot;, \&quot;task2\&quot;]}&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String readKey() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lock.lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return key;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lock.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void updateKey(String newKey) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lock.lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.key = newKey;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lock.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>在多节点环境中，可以使用分布式锁 Redisson 来保证对 key 的修改操作是原子的。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class DistributedKeyManager {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final RedissonClient redisson;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public DistributedKeyManager() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Config config = new Config();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        config.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.redisson = Redisson.create(config);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void updateKey(String key, String newValue) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        RLock lock = redisson.getLock(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lock.lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 模拟读取和更新操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String currentValue = readFromDatabase(key); // 假设读取 JSON 数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String updatedValue = modifyJson(currentValue, newValue); // 修改 JSON</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            writeToDatabase(key, updatedValue); // 写回数据库</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lock.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String readFromDatabase(String key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 模拟从数据库读取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return &quot;{\&quot;tasks\&quot;: [\&quot;task1\&quot;, \&quot;task2\&quot;]}&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String modifyJson(String json, String newValue) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 使用 JSON 库解析并修改</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return json.replace(&quot;task1&quot;, newValue);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void writeToDatabase(String key, String value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 模拟写回数据库</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说一个线程安全的使用场景">说一个线程安全的使用场景？<a href="#说一个线程安全的使用场景" class="hash-link" aria-label="Direct link to 说一个线程安全的使用场景？" title="Direct link to 说一个线程安全的使用场景？">​</a></h3>
<p>单例模式。在多线程环境下，如果多个线程同时尝试创建实例，单例类必须确保只创建一个实例，并提供一个全局访问点。
饿汉式是一种比较直接的实现方式，它通过在类加载时就立即初始化单例对象来保证线程安全。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Singleton {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final Singleton instance = new Singleton();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Singleton() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static Singleton getInstance() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return instance;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre></div></div>
<p>懒汉式单例则在第一次使用时初始化单例对象，这种方式需要使用双重检查锁定来确保线程安全，
volatile 关键字用来保证可见性，syncronized 关键字用来保证同步。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class LazySingleton {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static volatile LazySingleton instance;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private LazySingleton() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static LazySingleton getInstance() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (instance == null) { // 第一次检查</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            synchronized (LazySingleton.class) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (instance == null) { // 第二次检查</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    instance = new LazySingleton();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return instance;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="能说一下-hashtable-的底层数据结构吗">能说一下 Hashtable 的底层数据结构吗？<a href="#能说一下-hashtable-的底层数据结构吗" class="hash-link" aria-label="Direct link to 能说一下 Hashtable 的底层数据结构吗？" title="Direct link to 能说一下 Hashtable 的底层数据结构吗？">​</a></h3>
<p>与 HashMap 类似，Hashtable 的底层数据结构也是一个数组加上链表的方式，然后通过 synchronized 加锁来保证线程安全。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="threadlocal">ThreadLocal<a href="#threadlocal" class="hash-link" aria-label="Direct link to ThreadLocal" title="Direct link to ThreadLocal">​</a></h2>
<p>推荐阅读：ThreadLocal 全面解析</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="threadlocal-是什么">🌟ThreadLocal 是什么？<a href="#threadlocal-是什么" class="hash-link" aria-label="Direct link to 🌟ThreadLocal 是什么？" title="Direct link to 🌟ThreadLocal 是什么？">​</a></h3>
<p>ThreadLocal 是一种用于实现线程局部变量的工具类。它允许每个线程都拥有自己的独立副本，从而实现线程隔离。
<img decoding="async" loading="lazy" alt="ThreadLocal" src="/doc/assets/images/ThreadLocal-191479ff3e6e7b81fd2713d2298aea69.png" width="666" height="468" class="img_ev3q">
使用 ThreadLocal 通常分为四步：
①、创建 ThreadLocal
//创建一个ThreadLocal变量
<code>public static ThreadLocal&lt;String&gt; localVariable = new ThreadLocal&lt;&gt;();</code>
②、设置 ThreadLocal 的值
//设置ThreadLocal变量的值
<code>localVariable.set(&quot;沉默王二是沙雕&quot;);</code>
③、获取 ThreadLocal 的值
//获取ThreadLocal变量的值
<code>String value = localVariable.get();</code>
④、删除 ThreadLocal 的值
//删除ThreadLocal变量的值
<code>localVariable.remove();</code></p>
<p>在 Web 应用中，可以使用 ThreadLocal 存储用户会话信息，这样每个线程在处理用户请求时都能方便地访问当前用户的会话信息。
在数据库操作中，可以使用 ThreadLocal 存储数据库连接对象，每个线程有自己独立的数据库连接，从而避免了多线程竞争同一数据库连接的问题。
在格式化操作中，例如日期格式化，可以使用 ThreadLocal 存储 SimpleDateFormat 实例，避免多线程共享同一实例导致的线程安全问题。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="threadlocal-有哪些优点">ThreadLocal 有哪些优点？<a href="#threadlocal-有哪些优点" class="hash-link" aria-label="Direct link to ThreadLocal 有哪些优点？" title="Direct link to ThreadLocal 有哪些优点？">​</a></h3>
<p>每个线程访问的变量副本都是独立的，避免了共享变量引起的线程安全问题。由于 ThreadLocal 实现了变量的线程独占，使得变量不需要同步处理，因此能够避免资源竞争。
ThreadLocal 可用于跨方法、跨类时传递上下文数据，不需要在方法间传递参数。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="你在工作中用到过-threadlocal-吗">你在工作中用到过 ThreadLocal 吗？<a href="#你在工作中用到过-threadlocal-吗" class="hash-link" aria-label="Direct link to 你在工作中用到过 ThreadLocal 吗？" title="Direct link to 你在工作中用到过 ThreadLocal 吗？">​</a></h3>
<p>有用到过，用来存储用户信息。
技术派实战项目是典型的 MVC 架构，登录后的用户每次访问接口，都会在请求头中携带一个 token，在控制层可以根据这个
token，解析出用户的基本信息。
假如在服务层和持久层也要用到用户信息，就可以在控制层拦截请求把用户信息存入 ThreadLocal。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="threadlocal-怎么实现的呢">🌟ThreadLocal 怎么实现的呢？<a href="#threadlocal-怎么实现的呢" class="hash-link" aria-label="Direct link to 🌟ThreadLocal 怎么实现的呢？" title="Direct link to 🌟ThreadLocal 怎么实现的呢？">​</a></h3>
<p>当我们创建一个 ThreadLocal 对象并调用 set 方法时，其实是在当前线程中初始化了一个 ThreadLocalMap。
ThreadLocalMap 是 ThreadLocal 的一个静态内部类，它内部维护了一个 Entry 数组，key 是 ThreadLocal 对象，value
是线程的局部变量，这样就相当于为每个线程维护了一个变量副本。</p>
<p><img decoding="async" loading="lazy" alt="ThreadLocal原理" src="/doc/assets/images/ThreadLocal原理-eec8dff33ffae48592769c1a1f8362dd.png" width="776" height="467" class="img_ev3q">
Entry 继承了 WeakReference，它限定了 key 是一个弱引用，弱引用的好处是当内存不足时，JVM 会回收 ThreadLocal 对象，并且将其对应的
Entry.value 设置为 null，这样可以在很大程度上避免内存泄漏。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /** The value associated with this ThreadLocal. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Object value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //节点类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Entry(ThreadLocal&lt;?&gt; k, Object v) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //key赋值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super(k);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //value赋值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        value = v;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>总结一下：
ThreadLocal 的实现原理是，每个线程维护一个 Map，key 为 ThreadLocal 对象，value 为想要实现线程隔离的对象。
1、通过 ThreadLocal 的 set 方法将对象存入 Map 中。
2、通过 ThreadLocal 的 get 方法从 Map 中取出对象。
3、Map 的大小由 ThreadLocal 对象的多少决定。
<img decoding="async" loading="lazy" alt="ThreadLocal结构" src="/doc/assets/images/ThreadLocal结构-762d09a544dc33de43d2cfcd472c2bc8.png" width="1182" height="1534" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是弱引用什么是强引用">什么是弱引用，什么是强引用？<a href="#什么是弱引用什么是强引用" class="hash-link" aria-label="Direct link to 什么是弱引用，什么是强引用？" title="Direct link to 什么是弱引用，什么是强引用？">​</a></h3>
<p>我先说一下强引用，比如 User user = new User(&quot;沉默王二&quot;) 中，user 就是一个强引用，new User(&quot;沉默王二&quot;) 就是强引用对象。
当 user 被置为 null 时（user = null），new User(&quot;沉默王二&quot;) 对象就会被垃圾回收；否则即便是内存空间不足，JVM 也不会回收 new
User(&quot;沉默王二&quot;) 这个强引用对象，宁愿抛出 OutOfMemoryError。
弱引用，比如说在使用 ThreadLocal 中，Entry 的 key 就是一个弱引用对象。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ThreadLocal&lt;User&gt; userThreadLocal = new ThreadLocal&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    userThreadLocal.set(new User(&quot;沉默王二&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>userThreadLocal 是一个强引用，<code>new ThreadLocal&lt;&gt;()</code> 是一个强引用对象；
new User(&quot;沉默王二&quot;) 是一个强引用对象。
调用 set 方法后，会将 <code>key = new ThreadLocal&lt;&gt;()</code> 放入 ThreadLocalMap 中，此时的 key 是一个弱引用对象。当 JVM
进行垃圾回收时，如果发现了弱引用对象，就会将其回收。
<img decoding="async" loading="lazy" alt="ThreadLocal对象引用" src="/doc/assets/images/ThreadLocal对象引用-539f99a2fd5f0c2f32a9d51d964a425c.png" width="930" height="404" class="img_ev3q">
其关系链就是：
ThreadLocal 强引用 -&gt; ThreadLocal 对象。
Thread 强引用 -&gt; ThreadLocalMap。
ThreadLocalMap[i] 强引用了 -&gt; Entry。
Entry.key 弱引用 -&gt; ThreadLocal 对象。
Entry.value 强引用 -&gt; 线程的局部变量对象。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="threadlocal-内存泄露是怎么回事">🌟ThreadLocal 内存泄露是怎么回事？<a href="#threadlocal-内存泄露是怎么回事" class="hash-link" aria-label="Direct link to 🌟ThreadLocal 内存泄露是怎么回事？" title="Direct link to 🌟ThreadLocal 内存泄露是怎么回事？">​</a></h3>
<p>ThreadLocalMap 的 Key 是 弱引用(所以如果对应的ThreadLocal对象被释放了，key就能随着被释放)，
但 Value 是强引用。 如果一个线程一直在运行，并且 value 一直指向某个强引用对象，那么这个对象就不会被回收，从而导致内存泄漏。
<img decoding="async" loading="lazy" alt="ThreadLocalMap" src="/doc/assets/images/ThreadLocalMap-6b4e3231106482132b5cdaa9e7be4627.png" width="960" height="954" class="img_ev3q">
那怎么解决内存泄漏问题呢？
很简单，使用完 ThreadLocal 后，及时调用 remove() 方法释放内存空间。
remove() 会调用 ThreadLocalMap 的 remove 方法遍历哈希表，找到 key 等于当前 ThreadLocal 的 Entry，找到后会调用 Entry 的
clear 方法，将 Entry 的 value 设置为 null。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private void remove(ThreadLocal&lt;?&gt; key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Entry[] tab = table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int len = tab.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 计算 key 的 hash 值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int i = key.threadLocalHashCode &amp; (len - 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 遍历数组，找到 key 为 null 的 Entry</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (Entry e = tab[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         e != null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         e = tab[i = nextIndex(i, len)]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (e.get() == key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 将该 Entry 的 key 置为 null（即 Entry 失效）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.clear();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 清理过期的 entry</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            expungeStaleEntry(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void clear() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.referent = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>然后执行 expungeStaleEntry() 方法，清除 key 为 null 的 Entry。
<img decoding="async" loading="lazy" alt="expungeStaleEntry代码解析" src="/doc/assets/images/expungeStaleEntry代码解析-5d0bac9505f540bceb438113b20b7364.png" width="1324" height="1318" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="那为什么-key-要设计成弱引用">那为什么 key 要设计成弱引用？<a href="#那为什么-key-要设计成弱引用" class="hash-link" aria-label="Direct link to 那为什么 key 要设计成弱引用？" title="Direct link to 那为什么 key 要设计成弱引用？">​</a></h3>
<p>弱引用的好处是，当内存不足的时候，JVM 能够及时回收掉弱引用的对象。
WeakReference key = new WeakReference(new ThreadLocal());
key 是弱引用，new WeakReference(new ThreadLocal()) 是弱引用对象，当 JVM 进行垃圾回收时，只要发现了弱引用对象，就会将其回收。
一旦 key 被回收，ThreadLocalMap 在进行 <strong>set、get 的时候就会对 key 为 null 的 Entry 进行清理</strong>。</p>
<p><img decoding="async" loading="lazy" alt="ThreadLocalMap垃圾回收" src="/doc/assets/images/ThreadLocalMap垃圾回收-e635f83faa9626687e8426158dfc3660.png" width="838" height="470" class="img_ev3q">
总结一下，在 ThreadLocal 被垃圾收集后，下一次访问 ThreadLocalMap 时，Java 会自动清理那些键为 null 的 entry，这个过程会在执行
get()、set()、remove()时触发。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="你了解哪些-threadlocal-的改进方案">你了解哪些 ThreadLocal 的改进方案？<a href="#你了解哪些-threadlocal-的改进方案" class="hash-link" aria-label="Direct link to 你了解哪些 ThreadLocal 的改进方案？" title="Direct link to 你了解哪些 ThreadLocal 的改进方案？">​</a></h3>
<p>在 JDK 20 Early-Access Build 28 版本中，出现了 ThreadLocal 的改进方案，即 ScopedValue。
还有 Netty 中的 FastThreadLocal，它是 Netty 对 ThreadLocal 的优化，内部维护了一个索引常量 index，每次创建 FastThreadLocal
中都会自动+1，用来取代 hash 冲突带来的损耗，用空间换时间。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private final int index;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public FastThreadLocal() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    index = InternalThreadLocalMap.nextVariableIndex();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static int nextVariableIndex() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int index = nextIndex.getAndIncrement();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (index &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        nextIndex.decrementAndGet();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return index;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>以及阿里的 TransmittableThreadLocal，不仅实现了子线程可以继承父线程 ThreadLocal 的功能，并且还可以跨线程池传递值。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">TransmittableThreadLocal&lt;String&gt; context = new TransmittableThreadLocal&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 在父线程中设置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">context.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">set(&quot;value-set-in-parent&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 在子线程中可以读取，值是&quot;value-set-in-parent&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String value = context.get();</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="threadlocalmap-的源码看过吗">ThreadLocalMap 的源码看过吗？<a href="#threadlocalmap-的源码看过吗" class="hash-link" aria-label="Direct link to ThreadLocalMap 的源码看过吗？" title="Direct link to ThreadLocalMap 的源码看过吗？">​</a></h3>
<p>ThreadLocalMap 虽然被叫做 Map，但它并没有实现 Map 接口，是一个简单的线性探测哈希表。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static class ThreadLocalMap {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Entry(ThreadLocal&lt;?&gt; k, Object v) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            super(k);  // 这里的 Key 是 WeakReference</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            value = v;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Entry[] table;  // 存储 ThreadLocal 变量的数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int size;       // 当前 Entry 数量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int threshold;  // 触发扩容的阈值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>底层的数据结构也是数组，数组中的每个元素是一个 Entry 对象，Entry 对象继承了 WeakReference，key 是 ThreadLocal 对象，value
是线程的局部变量。
<img decoding="async" loading="lazy" alt="ThreadLocalMap结构" src="/doc/assets/images/ThreadLocalMap结构-c83bc6609105c0c47b5344e499069009.png" width="1208" height="474" class="img_ev3q">
当调用 ThreadLocal.set(value) 时，会将 value 存入 ThreadLocalMap。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public void set(T value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Thread t = Thread.currentThread();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ThreadLocalMap map = getMap(t);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (map != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        map.set(this, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        createMap(t, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>set() 方法是 ThreadLocalMap 的核心方法，通过 key 的哈希码与数组长度取模，计算出 key 在数组中的位置，这一点和 HashMap 的实现类似。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private void set(ThreadLocal&lt;?&gt; key, Object value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Entry[] tab = table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int len = tab.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int i = key.threadLocalHashCode &amp; (len - 1); // 计算索引</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (Entry e = tab[i]; e != null; e = tab[nextIndex(i, len)]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ThreadLocal&lt;?&gt; k = e.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (k == key) { // 如果 key 已存在，更新 value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.value = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (k == null) { // Key 为 null，清理无效 Entry</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            replaceStaleEntry(key, value, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    tab[i] = new Entry(key, value); // 直接插入 Entry</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    size++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (size &gt;= threshold) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rehash();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>threadLocalHashCode 的计算有点东西，每创建一个 ThreadLocal 对象，它就会新增一个黄金分割数，可以让哈希码分布的非常均匀。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private static final int HASH_INCREMENT = 0x61c88647;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static int nextHashCode() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return nextHashCode.getAndAdd(HASH_INCREMENT);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>当调用 ThreadLocal.get() 时，会调用 ThreadLocalMap 的 getEntry() 方法，根据 key 的哈希码找到对应的线程局部变量。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private Entry getEntry(ThreadLocal&lt;?&gt; key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int i = key.threadLocalHashCode &amp; (table.length - 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Entry e = table[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (e != null &amp;&amp; e.get() == key) { // 如果 key 存在，直接返回</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return getEntryAfterMiss(key, i, e); // 继续查找</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>当调用 ThreadLocal.remove() 时，会调用 ThreadLocalMap 的 remove() 方法，根据 key 的哈希码找到对应的线程局部变量，将其清除，防止内存泄漏。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private void remove(ThreadLocal&lt;?&gt; key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Entry[] tab = table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int len = tab.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int i = key.threadLocalHashCode &amp; (len - 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (Entry e = tab[i]; e != null; e = tab[nextIndex(i, len)]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (e.get() == key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.clear(); // 清除 WeakReference</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.value = null; // 释放 Value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            expungeStaleEntries();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="threadlocalmap-怎么解决-hash-冲突的">ThreadLocalMap 怎么解决 Hash 冲突的？<a href="#threadlocalmap-怎么解决-hash-冲突的" class="hash-link" aria-label="Direct link to ThreadLocalMap 怎么解决 Hash 冲突的？" title="Direct link to ThreadLocalMap 怎么解决 Hash 冲突的？">​</a></h3>
<p>开放定址法。
如果计算得到的槽位 i 已经被占用，ThreadLocalMap 会采用开放地址法中的线性探测来寻找下一个空闲槽位：
如果 i 位置被占用，尝试 i+1。
如果 i+1 也被占用，继续探测 i+2，直到找到一个空位。
如果到达数组末尾，则回到数组头部，继续寻找空位。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private static int nextIndex(int i, int len) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return ((i + 1 &lt; len) ? i + 1 : 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>为什么要用线性探测法而不是HashMap 的拉链法来解决哈希冲突？
ThreadLocalMap 设计的目的是存储线程私有数据，不会有大量的 Key，所以采用线性探测更节省空间。
拉链法还需要单独维护一个链表，甚至红黑树，不适合 ThreadLocal 这种场景。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="开放地址法了解吗">开放地址法了解吗？<a href="#开放地址法了解吗" class="hash-link" aria-label="Direct link to 开放地址法了解吗？" title="Direct link to 开放地址法了解吗？">​</a></h3>
<p>简单来说，就是这个坑被人占了，那就接着去找空着的坑。
<img decoding="async" loading="lazy" alt="开放地址法" src="/doc/assets/images/开放地址法-36eabe92de0c29523deffd2cb1629ce6.png" width="1002" height="448" class="img_ev3q">
如果我们插入一个 value=27 的数据，通过 hash 计算后应该落入第 4 个槽位，而槽位 4 已经有数据了，而且 key 和当前的不等。
此时就会线性向后查找，一直找到 Entry 为 null 的槽位才会停止。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="threadlocalmap-扩容机制了解吗">ThreadLocalMap 扩容机制了解吗？<a href="#threadlocalmap-扩容机制了解吗" class="hash-link" aria-label="Direct link to ThreadLocalMap 扩容机制了解吗？" title="Direct link to ThreadLocalMap 扩容机制了解吗？">​</a></h3>
<p>与 HashMap 不同，ThreadLocalMap 并不会直接在元素数量达到阈值时立即扩容，而是先清理被 GC 回收的 key，然后在填充率达到四分之三时进行扩容。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private void rehash() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 清理被 GC 回收的 key</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    expungeStaleEntries();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //扩容</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (size &gt;= threshold - threshold / 4)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        resize();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>清理过程会遍历整个数组，将 key 为 null 的 Entry 清除。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private void expungeStaleEntries() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Entry[] tab = table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int len = tab.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int j = 0; j &lt; len; j++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Entry e = tab[j];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果 key 为 null，清理 Entry</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (e != null &amp;&amp; e.get() == null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            expungeStaleEntry(j);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>阈值 threshold 的默认值是数组长度的三分之二。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private void setThreshold(int len) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    threshold = len * 2 / 3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>扩容时，会将数组长度翻倍，然后重新计算每个 Entry 的位置，采用线性探测法来寻找新的空位，然后将 Entry 放入新的数组中。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private void resize() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Entry[] oldTab = table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int oldLen = oldTab.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 扩容为原来的两倍</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int newLen = oldLen * 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Entry[] newTab = new Entry[newLen];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int count = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 遍历老数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int j = 0; j &lt; oldLen; ++j) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Entry e = oldTab[j];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (e != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ThreadLocal&lt;?&gt; k = e.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (k == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e.value = null; // 释放 Value，防止内存泄漏</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 重新计算位置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int h = k.threadLocalHashCode &amp; (newLen - 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                while (newTab[h] != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 线性探测寻找新位置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    h = nextIndex(h, newLen);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 放入新数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                newTab[h] = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                count++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    table = newTab;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    size = count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    threshold = newLen * 2 / 3; // 重新计算扩容阈值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>一句话总结：ThreadLocalMap 采用的是“<strong>先清理再扩容</strong>”的策略，扩容时，数组长度翻倍，并重新计算索引，如果发生哈希冲突，采用线性探测法来解决。
<img decoding="async" loading="lazy" alt="ThreadLocalMap扩容" src="/doc/assets/images/ThreadLocalMap扩容-be5b4b0516be296811c32c362191609e.png" width="1006" height="358" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="父线程能用-threadlocal-给子线程传值吗">父线程能用 ThreadLocal 给子线程传值吗？<a href="#父线程能用-threadlocal-给子线程传值吗" class="hash-link" aria-label="Direct link to 父线程能用 ThreadLocal 给子线程传值吗？" title="Direct link to 父线程能用 ThreadLocal 给子线程传值吗？">​</a></h3>
<p>不能。
因为 ThreadLocal 变量存储在每个线程的 ThreadLocalMap 中，而子线程不会继承父线程的 ThreadLocalMap。
可以使用 InheritableThreadLocal来解决这个问题。
在 Thread 类的定义中，每个线程都有两个 ThreadLocalMap：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class Thread {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* 普通 ThreadLocal 变量存储的地方 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ThreadLocal.ThreadLocalMap threadLocals = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* InheritableThreadLocal 变量存储的地方 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>普通 ThreadLocal 变量存储在 threadLocals 中，不会被子线程继承。
InheritableThreadLocal 变量存储在 inheritableThreadLocals 中，
<strong>当 new Thread() 创建一个子线程时，Thread 的 init()</strong>
ps: 线程池中无法使用
方法会检查父线程是否有 inheritableThreadLocals，
如果有，就会拷贝 InheritableThreadLocal 变量到子线程：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private void init(ThreadGroup g, Runnable target, String name, long stackSize) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 获取当前父线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Thread parent = currentThread();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 复制 InheritableThreadLocal 变量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (parent.inheritableThreadLocals != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.inheritableThreadLocals =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>阿里的<code>TransmittableThreadLocal&lt;T&gt;</code>需要com.alibaba.ttl.threadpool.TtlExecutors创建的线程池才行</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="java-内存模型">Java 内存模型<a href="#java-内存模型" class="hash-link" aria-label="Direct link to Java 内存模型" title="Direct link to Java 内存模型">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说一下你对-java-内存模型的理解">🌟说一下你对 Java 内存模型的理解？<a href="#说一下你对-java-内存模型的理解" class="hash-link" aria-label="Direct link to 🌟说一下你对 Java 内存模型的理解？" title="Direct link to 🌟说一下你对 Java 内存模型的理解？">​</a></h3>
<p>推荐阅读：说说 Java 的内存模型
Java 内存模型是 Java 虚拟机规范中定义的一个抽象模型，用来描述多线程环境中共享变量的内存可见性。
<img decoding="async" loading="lazy" alt="JAVA内存模型" src="/doc/assets/images/JAVA内存模型-711ff811ebb73ec816748c3476c3a602.png" width="1278" height="998" class="img_ev3q"></p>
<p>共享变量存储在主内存中，每个线程都有一个私有的本地内存，存储了共享变量的副本。
当一个线程更改了本地内存中共享变量的副本，它需要 JVM 刷新到主内存中，以确保其他线程可以看到这些更改。
当一个线程需要读取共享变量时，它一版会从本地内存中读取。如果本地内存中的副本是过时的，JVM 会将主内存中的共享变量最新值刷新到本地内存中。
<img decoding="async" loading="lazy" alt="JAVA内存模型1" src="/doc/assets/images/JAVA内存模型1-710eda8cdee93a020458255063e9c861.png" width="654" height="610" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么线程要用自己的内存">为什么线程要用自己的内存？<a href="#为什么线程要用自己的内存" class="hash-link" aria-label="Direct link to 为什么线程要用自己的内存？" title="Direct link to 为什么线程要用自己的内存？">​</a></h3>
<p>线程从主内存拷贝变量到工作内存，可以减少 CPU 访问 RAM 的开销。
每个线程都有自己的变量副本，可以避免多个线程同时修改共享变量导致的数据冲突。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="i是原子操作吗">i++是原子操作吗？<a href="#i是原子操作吗" class="hash-link" aria-label="Direct link to i++是原子操作吗？" title="Direct link to i++是原子操作吗？">​</a></h3>
<p>不是，它包括三个步骤：
从内存中读取 i 的值。
对 i 进行加 1 操作。
将新的值写回内存。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="说说你对原子性可见性有序性的理解">说说你对原子性、可见性、有序性的理解？<a href="#说说你对原子性可见性有序性的理解" class="hash-link" aria-label="Direct link to 说说你对原子性、可见性、有序性的理解？" title="Direct link to 说说你对原子性、可见性、有序性的理解？">​</a></h4>
<p>原子性要求一个操作是不可分割的，要么全部执行成功，要么完全不执行。
举个例子：就比如说 count++ 就不是一个原子操作，它包括读取 count 的值、加 1、写回 count 三个步骤，所以需要加锁或者使用AtomicInteger代替
int 来保证原子性。
可见性要求一个线程对共享变量的修改，能够被其他线程及时看见。
我通过下面的代码解释一下：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private static boolean flag = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    new Thread(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (flag) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } // 线程 A 可能一直看不到 flag=false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;线程 A 退出&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }).start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread.sleep(1000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    flag = false; // 线程 B 修改 flag</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>上述代码问题：
线程 A 会在本地内存中缓存 flag=true，虽然线程 B 修改了 flag=false，但不会立即同步到主内存以及线程 A 的本地内存，因此线程 A
会一直处于死循环。
解决办法就是通过 volatile 关键字来保证可见性。
有序性是指程序执行的顺序是否按照代码编写的顺序执行。</p>
<p>在单线程环境下，代码能够准确无误地按照编写顺序执行。但在多线程环境下，CPU 和编译器可能会进行指令重排，代码的执行顺序因此会发生变化。
我通过下面的代码解释一下：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int a = 0, b = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">boolean flag = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void thread1() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    a = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    flag = true; // 可能会被 CPU 优化，先执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void thread2() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (flag) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(a); // 可能打印 0，而不是 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>由于指令重排，flag = true 可能会在 a = 1 之前执行，导致 thread2() 读取 flag=true 后，a 仍然是 0，出现不符合代码逻辑的情况。
简要回答：
原子性保证操作不可中断，可见性保证变量修改后线程能看到最新值，有序性保证代码执行顺序一致，可以通过 volatile、synchronized 和
CAS 机制来保证这些特性。</p>
<p>下面的代码是原子操作吗？</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int i = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int j = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">i++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">i =i +1;</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说什么是指令重排">说说什么是指令重排？<a href="#说说什么是指令重排" class="hash-link" aria-label="Direct link to 说说什么是指令重排？" title="Direct link to 说说什么是指令重排？">​</a></h3>
<p>指令重排是指 CPU 或编译器为了提高程序的执行效率，改变代码执行顺序的一种优化技术。
从 Java 源代码到最终执行的指令序列，会经历 3 种重排序：编译器重排序、指令并行重排序、内存系统重排序。
<img decoding="async" loading="lazy" alt="指令重排" src="/doc/assets/images/指令重排-978bd555543a68ccf2ce9c8bfefbb57d.png" width="1035" height="195" class="img_ev3q"></p>
<p>指令重排可能会导致双重检查锁失效，比如下面的单例模式代码：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class Singleton {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static Singleton instance;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static Singleton getInstance() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (instance == null) { // 第一次检查</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            synchronized (Singleton.class) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (instance == null) { // 第二次检查</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    instance = new Singleton(); // 可能发生指令重排</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return instance;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>如果线程 A 执行了 instance = new Singleton();
但构造方法还没执行完，线程 B 可能会读取到一个未初始化的对象，导致出现空指针异常。？？？
<img decoding="async" loading="lazy" alt="单例恶汉指定重排可能存在问题" src="/doc/assets/images/单例恶汉指定重排可能存在问题-87dfa5c0aaecc772537085d93d63fffc.png" width="901" height="604" class="img_ev3q">
正确的方式是给 instance 变量加上 volatile 关键字，禁止指令重排。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Singleton {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static volatile Singleton instance;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static Singleton getInstance() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (instance == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            synchronized (Singleton.class) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (instance == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    instance = new Singleton(); // 由于 volatile，禁止指令重排</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return instance;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="happens-before-了解吗">happens-before 了解吗？<a href="#happens-before-了解吗" class="hash-link" aria-label="Direct link to happens-before 了解吗？" title="Direct link to happens-before 了解吗？">​</a></h3>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="as-if-serial-了解吗">as-if-serial 了解吗？<a href="#as-if-serial-了解吗" class="hash-link" aria-label="Direct link to as-if-serial 了解吗？" title="Direct link to as-if-serial 了解吗？">​</a></h3>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="volatile-了解吗">🌟volatile 了解吗？<a href="#volatile-了解吗" class="hash-link" aria-label="Direct link to 🌟volatile 了解吗？" title="Direct link to 🌟volatile 了解吗？">​</a></h3>
<p>推荐阅读：volatile 关键字解析
了解。
第一，保证可见性，线程修改 volatile 变量后，其他线程能够立即看到最新值；
第二，防止指令重排，volatile 变量的写入不会被重排序到它之前的代码。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="volatile-怎么保证可见性的">volatile 怎么保证可见性的？<a href="#volatile-怎么保证可见性的" class="hash-link" aria-label="Direct link to volatile 怎么保证可见性的？" title="Direct link to volatile 怎么保证可见性的？">​</a></h4>
<p>当线程对 volatile 变量进行写操作时，JVM 会在这个变量写入之后插入一个写屏障指令，这个指令会强制将本地内存中的变量值刷新到主内存中。
<img decoding="async" loading="lazy" alt="volatile保证可见性" src="/doc/assets/images/volatile保证可见性-c14d58c68e9c7ba11db2d3af83757918.png" width="796" height="592" class="img_ev3q"></p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">StoreStore;   // 保证写入之前的操作不会重排</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">volatile_write(); // 写入 volatile 变量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">StoreLoad;    // 保证写入后，其他线程立即可见</span><br></span></code></pre></div></div>
<p>在 x86 架构下，通常会使用 lock 指令来实现写屏障，例如：</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">mov [a], 2          ; 将值 2 写入内存地址 a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">lock add [a], 0     ; lock 指令充当写屏障，确保内存可见性</span><br></span></code></pre></div></div>
<p>当线程对 volatile 变量进行读操作时，JVM 会插入一个读屏障指令，这个指令会强制让本地内存中的变量值失效，从而重新从主内存中读取最新的值。
<img decoding="async" loading="lazy" alt="volatile加入屏障指令" src="/doc/assets/images/volatile加入屏障指令-fb02ff1e8cc9c16cbffa2e68e2043caa.png" width="795" height="593" class="img_ev3q">
我们来声明一个 volatile 变量 x：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">volatile int x = 0</span><br></span></code></pre></div></div>
<p>线程 A 对 x 写入后会将其最新的值刷新到主内存中，线程 B 读取 x 时由于本地内存中的 x 失效了，就会从主内存中读取最新的值。
<img decoding="async" loading="lazy" alt="volatile修饰变量多线程修改" src="/doc/assets/images/volatile修饰变量多线程修改-55447d7a7d019ba2e041a459ce39eaa5.png" width="1136" height="432" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="volatile-怎么保证有序性的">volatile 怎么保证有序性的？<a href="#volatile-怎么保证有序性的" class="hash-link" aria-label="Direct link to volatile 怎么保证有序性的？" title="Direct link to volatile 怎么保证有序性的？">​</a></h3>
<p>JVM 会在 volatile 变量的读写前后插入 “内存屏障”，以约束 CPU 和编译器的优化行为：</p>
<p>StoreStore 屏障可以禁止普通写操作与 volatile 写操作的重排
StoreLoad 屏障会禁止 volatile 写与 volatile 读重排
LoadLoad 屏障会禁止 volatile 读与后续普通读操作重排
LoadStore 屏障会禁止 volatile 读与后续普通写操作重排</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="volatile-和-synchronized-的区别">volatile 和 synchronized 的区别？<a href="#volatile-和-synchronized-的区别" class="hash-link" aria-label="Direct link to volatile 和 synchronized 的区别？" title="Direct link to volatile 和 synchronized 的区别？">​</a></h3>
<p>volatile 关键字用于修饰变量，确保该变量的更新操作对所有线程是可见的，即一旦某个线程修改了 volatile 变量，其他线程会立即看到最新的值。</p>
<p>synchronized 关键字用于修饰方法或代码块，确保同一时刻只有一个线程能够执行该方法或代码块，从而实现互斥访问。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="volatile-加在基本类型和对象上的区别">volatile 加在基本类型和对象上的区别？<a href="#volatile-加在基本类型和对象上的区别" class="hash-link" aria-label="Direct link to volatile 加在基本类型和对象上的区别？" title="Direct link to volatile 加在基本类型和对象上的区别？">​</a></h3>
<p>当 volatile 用于基本数据类型时，能确保该变量的读写操作是直接从主内存中读取或写入的。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private volatile int count = 0;</span><br></span></code></pre></div></div>
<p>当 volatile 用于引用类型时，能确保引用本身的可见性，即确保引用指向的对象地址是最新的。
但是，volatile 并不能保证引用对象内部状态的线程安全。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private volatile SomeObject obj = new SomeObject();</span><br></span></code></pre></div></div>
<p>虽然 volatile 确保了 obj 引用的可见性，但对 obj 引用的 new SomeObject() 对象并不受 volatile 保护。</p>
<p>如果需要保证引用对象内部状态的线程安全，需要使用 synchronized 或 ReentrantLock 等锁机制。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="锁">锁<a href="#锁" class="hash-link" aria-label="Direct link to 锁" title="Direct link to 锁">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="synchronized-用过吗">synchronized 用过吗？<a href="#synchronized-用过吗" class="hash-link" aria-label="Direct link to synchronized 用过吗？" title="Direct link to synchronized 用过吗？">​</a></h3>
<p>用过，频率还很高。</p>
<p>synchronized 在 JDK 1.6 之后，进行了锁优化，增加了偏向锁、轻量级锁，大大提升了 synchronized 的性能。</p>
<p>synchronized 上锁的对象是什么？
synchronized 用在普通方法上时，上锁的是执行这个方法的对象。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public synchronized void increment() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.count++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>synchronized 用在静态方法上时，上锁的是这个类的 Class 对象。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public static synchronized void increment() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    count++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>synchronized 用在代码块上时，上锁的是括号中指定的对象，比如说当前对象 this。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public void increment() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    synchronized (this) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.count++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="synchronized-的实现原理了解吗">synchronized 的实现原理了解吗？<a href="#synchronized-的实现原理了解吗" class="hash-link" aria-label="Direct link to synchronized 的实现原理了解吗？" title="Direct link to synchronized 的实现原理了解吗？">​</a></h3>
<p>synchronized 依赖 JVM 内部的 Monitor 对象来实现线程同步。使用的时候不用手动去 lock 和 unlock，JVM 会自动加锁和解锁。
synchronized 加锁代码块时，JVM 会通过 monitorenter、monitorexit 两个指令来实现同步：
前者表示线程正在尝试获取 lock 对象的 Monitor；
后者表示线程执行完了同步代码块，正在释放锁。
使用 javap -c -s -v -l SynchronizedDemo.class 反编译 synchronized 代码块时，就能看到这两个指令。
<img decoding="async" loading="lazy" alt="img_1.png" src="/doc/assets/images/img_1-537cb7198f2d4929095428496a1d59ae.png" width="957" height="698" class="img_ev3q">
synchronized 修饰普通方法时，JVM 会通过 ACC_SYNCHRONIZED 标记符来实现同步。
<img decoding="async" loading="lazy" alt="img_2.png" src="/doc/assets/images/img_2-caf2ce0f1c5405124c69f2369c2f078e.png" width="943" height="448" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="你对-monitor-了解多少">你对 Monitor 了解多少？<a href="#你对-monitor-了解多少" class="hash-link" aria-label="Direct link to 你对 Monitor 了解多少？" title="Direct link to 你对 Monitor 了解多少？">​</a></h3>
<p>waitx ,没人问过</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="synchronized-怎么保证可见性">synchronized 怎么保证可见性？<a href="#synchronized-怎么保证可见性" class="hash-link" aria-label="Direct link to synchronized 怎么保证可见性？" title="Direct link to synchronized 怎么保证可见性？">​</a></h3>
<p>通过两步操作：</p>
<p>加锁时，线程必须从主内存读取最新数据。
释放锁时，线程必须将修改的数据刷回主内存，这样其他线程获取锁后，就能看到最新的数据。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">线程 A                  线程 B</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ┌────────────────────┐</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  │ synchronized(lock) │</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  │    x = 1;          │  // 1. 线程 A 修改变量 x</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  └────────────────────┘</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ↓ 释放锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  （JVM 强制刷新 x 到主内存）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        （线程 B 获取锁）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ┌────────────────────┐</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  │ synchronized(lock) │</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  │    print(x);       │  // 2. 线程 B 读取最新 x=1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  └────────────────────┘</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="synchronized-怎么保证有序性">synchronized 怎么保证有序性？<a href="#synchronized-怎么保证有序性" class="hash-link" aria-label="Direct link to synchronized 怎么保证有序性？" title="Direct link to synchronized 怎么保证有序性？">​</a></h3>
<p>synchronized 通过 JVM 指令 monitorenter 和 monitorexit，来确保加锁代码块内的指令不会被重排。</p>
<p>来解释一下，比如说对于：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">synchronized (lock){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">x =1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">flag =true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span></code></pre></div></div>
<p>javap 反编译后的伪代码：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">monitorenter   // 获取锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">store x, 1     // 变量 x = 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">store flag, true  // 变量 flag = true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">monitorexit    // 释放锁</span><br></span></code></pre></div></div>
<p>实际 javap 反编译后的结果：
<img decoding="async" loading="lazy" alt="img_3.png" src="/doc/assets/images/img_3-cf985eebd54a654b7fdbb6034451b476.png" width="1114" height="992" class="img_ev3q">
指令解释一下：</p>
<p>指令 作用
monitorenter 获取锁，进入同步代码块
iconst_1 将整数 1 压入操作数栈
istore_1 存储 1 到局部变量 x
iconst_1 再次将整数 1 压入操作数栈
istore_2 存储 1 到局部变量 flag
aload 4 加载 lock 对象引用
monitorexit 释放锁，退出同步代码块</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="synchronized-怎么实现可重入的呢">synchronized 怎么实现可重入的呢？<a href="#synchronized-怎么实现可重入的呢" class="hash-link" aria-label="Direct link to synchronized 怎么实现可重入的呢？" title="Direct link to synchronized 怎么实现可重入的呢？">​</a></h3>
<p>可重入意味着同一个线程可以多次获得同一个锁，而不会被阻塞。
<img decoding="async" loading="lazy" alt="img_7.png" src="/doc/assets/images/img_7-9f973d5df0dea48e99487623793442be.png" width="1838" height="1058" class="img_ev3q">
synchronized 之所以支持可重入，是因为 Java 的对象头包含了一个 Mark Word，用于存储对象的状态，包括锁信息。</p>
<p>当一个线程获取对象锁时，JVM 会将该线程的 ID 写入 Mark Word，并将锁计数器设为 1。</p>
<p>如果一个线程尝试再次获取已经持有的锁，JVM 会检查 Mark Word 中的线程 ID。如果 ID 匹配，表示的是同一个线程，锁计数器递增。</p>
<p>当线程退出同步块时，锁计数器递减。如果计数器值为零，JVM 将锁标记为未持有状态，并清除线程 ID 信息。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class ReentrantExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized void method1() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Method1 acquired lock&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        method2();  // 线程已经持有锁，能继续调用 method2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized void method2() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Method2 acquired lock&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ReentrantExample example = new ReentrantExample();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        example.method1();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>因为 synchronized 支持可重入，所以 method1 获取锁后，method2 仍然可以获取锁。</p>
<p>底层是通过 Monitor 对象的 owner 和 count 字段实现的，owner 记录持有锁的线程，count 记录线程获取锁的次数。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="synchronized-锁升级了解吗">🌟synchronized 锁升级了解吗？<a href="#synchronized-锁升级了解吗" class="hash-link" aria-label="Direct link to 🌟synchronized 锁升级了解吗？" title="Direct link to 🌟synchronized 锁升级了解吗？">​</a></h3>
<p>waitx 没问过</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="synchronized-和-reentrantlock-的区别了解吗">🌟synchronized 和 ReentrantLock 的区别了解吗？<a href="#synchronized-和-reentrantlock-的区别了解吗" class="hash-link" aria-label="Direct link to 🌟synchronized 和 ReentrantLock 的区别了解吗？" title="Direct link to 🌟synchronized 和 ReentrantLock 的区别了解吗？">​</a></h3>
<p>两句话回答：synchronized 由 JVM 内部的 Monitor 机制实现，ReentrantLock基于 AQS 实现。</p>
<p>synchronized 可以自动加锁和解锁，ReentrantLock 需要手动 lock() 和 unlock()。
<img decoding="async" loading="lazy" alt="img_8.png" src="/doc/assets/images/img_8-d63c32e2c1ae2825d1a3597199ee49e8.png" width="756" height="422" class="img_ev3q">
如果面试官还想知道更多，可以继续回答：
①、ReentrantLock 可以实现多路选择通知，绑定多个 Condition，而 synchronized 只能通过 wait 和 notify 唤醒，属于单路通知；</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ReentrantLock lock = new ReentrantLock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Condition condition = lock.newCondition();</span><br></span></code></pre></div></div>
<p>②、synchronized 可以在方法和代码块上加锁，ReentrantLock 只能在代码块上加锁，但可以指定是公平锁还是非公平锁。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// synchronized 修饰方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public synchronized void method() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 业务代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// synchronized 修饰代码块</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">synchronized (this){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 业务代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// ReentrantLock 加锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ReentrantLock lock = new ReentrantLock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">lock.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">try{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 业务代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }finally{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lock.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>③、ReentrantLock 提供了一种能够中断等待锁的线程机制，通过 lock.lockInterruptibly() 来实现。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ReentrantLock lock = new ReentrantLock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">try{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lock.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">lockInterruptibly();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}catch(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">InterruptedException e){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 处理中断异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span></code></pre></div></div>
<p>并发量大的情况下，使用 synchronized 还是 ReentrantLock？
我更倾向于 ReentrantLock，因为：
ReentrantLock 提供了超时和公平锁等特性，可以应对更复杂的并发场景。
ReentrantLock 允许更细粒度的锁控制，能有效减少锁竞争。
ReentrantLock 支持条件变量 Condition，可以实现比 synchronized 更友好的线程间通信机制。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="lock-了解吗">Lock 了解吗？<a href="#lock-了解吗" class="hash-link" aria-label="Direct link to Lock 了解吗？" title="Direct link to Lock 了解吗？">​</a></h3>
<p>Lock 是 JUC 中的一个接口，最常用的实现类包括可重入锁 ReentrantLock、读写锁 ReentrantReadWriteLock 等</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="reentrantlock-的-lock-方法实现逻辑了解吗">ReentrantLock 的 lock() 方法实现逻辑了解吗？<a href="#reentrantlock-的-lock-方法实现逻辑了解吗" class="hash-link" aria-label="Direct link to ReentrantLock 的 lock() 方法实现逻辑了解吗？" title="Direct link to ReentrantLock 的 lock() 方法实现逻辑了解吗？">​</a></h3>
<p>lock 方法的具体实现由 ReentrantLock 内部的 Sync 类来实现，涉及到线程的自旋、阻塞队列、CAS、AQS 等。</p>
<p>lock 方法会首先尝试通过 CAS 来获取锁。如果当前锁没有被持有，会将锁状态设置为 1，表示锁已被占用。否则，会将当前线程加入到 AQS
的等待队列中。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">final void lock() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (compareAndSetState(0, 1))  // 尝试直接获取锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        setExclusiveOwnerThread(Thread.currentThread());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        acquire(1);  // 如果获取失败，进入AQS队列等待</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="aqs-了解多少">AQS 了解多少？<a href="#aqs-了解多少" class="hash-link" aria-label="Direct link to AQS 了解多少？" title="Direct link to AQS 了解多少？">​</a></h3>
<p>推荐阅读：到底什么是 AQS?
AQS 是一个抽象类，它维护了一个共享变量 state 和一个线程等待队列，为 ReentrantLock 等类提供底层支持。
<img decoding="async" loading="lazy" alt="AQS结构" src="/doc/assets/images/AQS结构-c7138e63792975fd0efaad907d4a9599.png" width="1291" height="461" class="img_ev3q">
AQS 的思想是，如果被请求的共享资源处于空闲状态，则当前线程成功获取锁；否则，将当前线程加入到等待队列中，当其他线程释放锁时，从等待队列中挑选一个线程，把锁分配给它。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="aqs-的源码阅读过吗">AQS 的源码阅读过吗？<a href="#aqs-的源码阅读过吗" class="hash-link" aria-label="Direct link to AQS 的源码阅读过吗？" title="Direct link to AQS 的源码阅读过吗？">​</a></h3>
<p>有研究过。
第一，状态 state 由 volatile 变量修饰，用于保证多线程之间的可见性；</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private volatile int state;</span><br></span></code></pre></div></div>
<p>②、同步队列由内部定义的 Node 类实现，每个 Node 包含了等待状态、前后节点、线程的引用等，是一个先进先出的双向链表。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static final class Node {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static final int CANCELLED = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static final int SIGNAL = -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static final int CONDITION = -2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static final int PROPAGATE = -3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    volatile Node prev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    volatile Node next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    volatile Thread thread;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>AQS 支持两种同步方式：
独占模式下：每次只能有一个线程持有锁，例如 ReentrantLock。
共享模式下：多个线程可以同时获取锁，例如 Semaphore 和 CountDownLatch。
核心方法包括：
acquire：获取锁，失败进入等待队列；
release：释放锁，唤醒等待队列中的线程；
acquireShared：共享模式获取锁；
releaseShared：共享模式释放锁。</p>
<p>AQS 使用一个 CLH 队列来维护等待线程，CLH 是三个作者 Craig、Landin 和 Hagersten 的首字母缩写，是一种基于链表的自旋锁。
<img decoding="async" loading="lazy" alt="AQS的抽象同步队列" src="/doc/assets/images/AQS的抽象同步队列-f40829bf919d3888c3a418765c3233e0.png" width="1200" height="331" class="img_ev3q">
在 CLH 中，当一个线程尝试获取锁失败后，会被添加到队列的尾部并自旋，等待前一个节点的线程释放锁。
<img decoding="async" loading="lazy" alt="AQS的抽象同步队列尾部自旋" src="/doc/assets/images/AQS的抽象同步队列尾部自旋-572919830bfc251ec31824df2e8b9a1e.png" width="1215" height="357" class="img_ev3q">
CLH 的优点是，假设有 100 个线程在等待锁，锁释放之后，只会通知队列中的第一个线程去竞争锁。避免同时唤醒大量线程，浪费 CPU 资源。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说-reentrantlock-的实现原理">🌟说说 ReentrantLock 的实现原理？<a href="#说说-reentrantlock-的实现原理" class="hash-link" aria-label="Direct link to 🌟说说 ReentrantLock 的实现原理？" title="Direct link to 🌟说说 ReentrantLock 的实现原理？">​</a></h3>
<p>ReentrantLock 是基于 AQS 实现的 可重入排他锁，使用 CAS 尝试获取锁，失败的话，会进入 CLH 阻塞队列，支持公平锁、非公平锁，可以中断、超时等待。
<img decoding="async" loading="lazy" alt="ReentrantLock原理" src="/doc/assets/images/ReentrantLock原理-5fbe7e8181be6399df2720ae6e918294.png" width="686" height="478" class="img_ev3q">
内部通过一个计数器 state 来跟踪锁的状态和持有次数。当线程调用 lock() 方法获取锁时，ReentrantLock 会检查 state 的值，如果为
0，通过 CAS 修改为 1，表示成功加锁。否则根据当前线程的公平性策略，加入到等待队列中。</p>
<p>线程首次获取锁时，state 值设为 1；如果同一个线程再次获取锁时，state 加 1；每释放一次锁，state 减 1。
当线程调用 unlock() 方法时，ReentrantLock 会将持有锁的 state 减 1，如果 state = 0，则释放锁，并唤醒等待队列中的线程来竞争锁。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class CounterWithLock {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int count = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Lock lock = new ReentrantLock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void increment() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lock.lock();  // 获取锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            count++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lock.unlock();  // 释放锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int getCount() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>new ReentrantLock() 默认创建的是非公平锁 NonfairSync。在非公平锁模式下，锁可能会授予刚刚请求它的线程，而不考虑等待时间。当切换到公平锁模式下，锁会授予等待时间最长的线程。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="reentrantlock-怎么创建公平锁">ReentrantLock 怎么创建公平锁？<a href="#reentrantlock-怎么创建公平锁" class="hash-link" aria-label="Direct link to ReentrantLock 怎么创建公平锁？" title="Direct link to ReentrantLock 怎么创建公平锁？">​</a></h3>
<p>很简单，创建 ReentrantLock 的时候，传递参数 true 就可以了。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ReentrantLock lock = new ReentrantLock(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// true 代表公平锁，false 代表非公平锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public ReentrantLock(boolean fair) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sync = fair ? new FairSync() : new NonfairSync();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="怎么创建一个非公平锁呢">怎么创建一个非公平锁呢？<a href="#怎么创建一个非公平锁呢" class="hash-link" aria-label="Direct link to 怎么创建一个非公平锁呢？" title="Direct link to 怎么创建一个非公平锁呢？">​</a></h3>
<p>创建 ReentrantLock 时，不传递参数或者传递参数就好了。
非公平锁和公平锁有什么不同？
两句话回答：
公平锁意味着在多个线程竞争锁时，获取锁的顺序与线程请求锁的顺序相同，即先来先服务。
非公平锁不保证线程获取锁的顺序，当锁被释放时，任何请求锁的线程都有机会获取锁，而不是按照请求的顺序。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="公平锁的实现逻辑了解吗">公平锁的实现逻辑了解吗？<a href="#公平锁的实现逻辑了解吗" class="hash-link" aria-label="Direct link to 公平锁的实现逻辑了解吗？" title="Direct link to 公平锁的实现逻辑了解吗？">​</a></h3>
<p>公平锁的核心逻辑在 AQS 的 hasQueuedPredecessors() 方法中，该方法用于判断当前线程前面是否有等待的线程。
<img decoding="async" loading="lazy" alt="AQS的hasQueuedPredecessors" src="/doc/assets/images/AQS的hasQueuedPredecessors-81782203ef763b7a60f40d1e7b2e92e4.png" width="1284" height="590" class="img_ev3q">
如果队列前面有等待线程，当前线程就不能抢占锁，必须按照队列顺序排队。如果队列前面没有线程，或者当前线程是队列头部的线程，就可以获取锁。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="cas-了解多少">🌟CAS 了解多少？<a href="#cas-了解多少" class="hash-link" aria-label="Direct link to 🌟CAS 了解多少？" title="Direct link to 🌟CAS 了解多少？">​</a></h3>
<p>推荐阅读：一文彻底搞清楚 Java 实现 CAS 的原理
CAS 是一种乐观锁，用于比较一个变量的当前值是否等于预期值，如果相等，则更新值，否则重试。
<img decoding="async" loading="lazy" alt="CAS原理" src="/doc/assets/images/CAS原理-9cf17f1efbe4034f6225b1a34732d4c6.png" width="1242" height="1172" class="img_ev3q">
在 CAS 中，有三个值：
V：要更新的变量(var)
E：预期值(expected)
N：新值(new)
先判断 V 是否等于 E，如果等于，将 V 的值设置为 N；如果不等，说明已经有其它线程更新了 V，当前线程就放弃更新。
这个比较和替换的操作需要是原子的，不可中断的。Java 中的 CAS 是由 Unsafe 类实现的。
AtomicInteger 类的 compareAndSet 就是一个 CAS 方法：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">AtomicInteger atomicInteger = new AtomicInteger(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int expect = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int update = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">atomicInteger.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">compareAndSet(expect, update);</span><br></span></code></pre></div></div>
<p>它调用的是 Unsafe 的 compareAndSwapInt。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="怎么保证-cas-的原子性">怎么保证 CAS 的原子性？<a href="#怎么保证-cas-的原子性" class="hash-link" aria-label="Direct link to 怎么保证 CAS 的原子性？" title="Direct link to 怎么保证 CAS 的原子性？">​</a></h3>
<p>CPU 会发出一个 LOCK 指令进行总线锁定，阻止其他处理器对内存地址进行操作，直到当前指令执行完成。</p>
<div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">lock cmpxchg </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">esi</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> eax  </span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> 比较 esi 地址中的值与 eax，如果相等则替换</span><br></span></code></pre></div></div>
<p><img decoding="async" loading="lazy" alt="CAS流程" src="/doc/assets/images/CAS流程-df450a4600529a4031f79ca1e0f92edc.png" width="637" height="763" class="img_ev3q">
CAS 存在三个经典问题，ABA 问题、自旋开销大、只能操作一个变量等。
<img decoding="async" loading="lazy" alt="CAS三大问题" src="/doc/assets/images/CAS三大问题-9c549859e2a192844914eab99c9fa70a.png" width="836" height="336" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是-aba-问题">什么是 ABA 问题？<a href="#什么是-aba-问题" class="hash-link" aria-label="Direct link to 什么是 ABA 问题？" title="Direct link to 什么是 ABA 问题？">​</a></h3>
<p>ABA 问题指的是，一个值原来是 A，后来被改为 B，再后来又被改回 A，这时 CAS 会误认为这个值没有发生变化。
线程 1：CAS(A → B)，修改变量 A → B
线程 2：CAS(B → A)，变量又变回 A
线程 3：CAS(A → C)，CAS 成功，但实际数据已被修改过！
可以使用版本号/时间戳的方式来解决 ABA 问题。
比如说，每次变量更新时，不仅更新变量的值，还更新一个版本号。CAS 操作时，不仅比较变量的值，还比较版本号。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class OptimisticLockExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int version;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public synchronized boolean updateValue(int newValue, int currentVersion) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (this.version == currentVersion) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.value = newValue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.version++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>Java 的 AtomicStampedReference 就增加了版本号，它会同时检查引用值和 stamp 是否都相等
使用示例：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class ABAFix {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static AtomicStampedReference&lt;String&gt; ref = new AtomicStampedReference&lt;&gt;(&quot;100&quot;, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new Thread(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int stamp = ref.getStamp();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ref.compareAndSet(&quot;100&quot;, &quot;200&quot;, stamp, stamp + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ref.compareAndSet(&quot;200&quot;, &quot;100&quot;, ref.getStamp(), ref.getStamp() + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }).start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new Thread(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Thread.sleep(100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int stamp = ref.getStamp();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;CAS 结果：&quot; + ref.compareAndSet(&quot;100&quot;, &quot;300&quot;, stamp, stamp + 1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }).start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="自旋开销大怎么解决">自旋开销大怎么解决？<a href="#自旋开销大怎么解决" class="hash-link" aria-label="Direct link to 自旋开销大怎么解决？" title="Direct link to 自旋开销大怎么解决？">​</a></h3>
<p>CAS 失败时会不断自旋重试，如果一直不成功，会给 CPU 带来非常大的执行开销。
可以加一个自旋次数的限制，超过一定次数，就切换到 synchronized 挂起线程。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public void cas() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int MAX_RETRIES = 10;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int retries = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (!atomicInt.compareAndSet(expect, update)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        retries++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (retries &gt; MAX_RETRIES) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            synchronized (this) { // 超过次数，使用 synchronized 处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (atomicInt.get() == expect) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    atomicInt.set(update);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>涉及到多个变量同时更新怎么办？
可以将多个变量封装为一个对象，使用 AtomicReference 进行 CAS 更新。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Account {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static class Balance {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final int money;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final int points;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Balance(int money, int points) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.money = money;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.points = points;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private AtomicReference&lt;Balance&gt; balance = new AtomicReference&lt;&gt;(new Balance(100, 10));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void update(int newMoney, int newPoints) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Balance oldBalance, newBalance;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        do {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            oldBalance = balance.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            newBalance = new Balance(newMoney, newPoints);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } while (!balance.compareAndSet(oldBalance, newBalance));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="java-有哪些保证原子性的方法">Java 有哪些保证原子性的方法？<a href="#java-有哪些保证原子性的方法" class="hash-link" aria-label="Direct link to Java 有哪些保证原子性的方法？" title="Direct link to Java 有哪些保证原子性的方法？">​</a></h3>
<p><img decoding="async" loading="lazy" alt="原子性的方法" src="/doc/assets/images/原子性的方法-a661315f85817a91d126a6f534aca115.png" width="666" height="274" class="img_ev3q">
比如说以 Atomic 开头的原子类，synchronized 关键字，ReentrantLock 锁等。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="原子操作类了解多少">原子操作类了解多少？<a href="#原子操作类了解多少" class="hash-link" aria-label="Direct link to 原子操作类了解多少？" title="Direct link to 原子操作类了解多少？">​</a></h3>
<p>原子操作类是基于 CAS + volatile 实现的，底层依赖于 Unsafe 类，最常用的有 AtomicInteger、AtomicLong、AtomicReference 等。
<img decoding="async" loading="lazy" alt="原子类" src="/doc/assets/images/原子类-a4f6b48e9c9b6c324955718419747420.png" width="981" height="815" class="img_ev3q">
像 AtomicIntegerArray 这种以 Array 结尾的，还可以原子更新数组里的元素。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class AtomicArrayExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        AtomicIntegerArray atomicArray = new AtomicIntegerArray(new int[]{1, 2, 3});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        atomicArray.incrementAndGet(1); // 对索引 1 进行自增</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(atomicArray.get(1)); // 输出 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>像 AtomicStampedReference 还可以通过版本号的方式解决 CAS 中的 ABA 问题。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class AtomicStampedReferenceExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        AtomicStampedReference&lt;Integer&gt; ref = new AtomicStampedReference&lt;&gt;(100, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int stamp = ref.getStamp(); // 获取版本号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ref.compareAndSet(100, 200, stamp, stamp + 1); // A → B</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ref.compareAndSet(200, 100, ref.getStamp(), ref.getStamp() + 1); // B → A</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="atomicinteger-的源码读过吗">AtomicInteger 的源码读过吗？<a href="#atomicinteger-的源码读过吗" class="hash-link" aria-label="Direct link to AtomicInteger 的源码读过吗？" title="Direct link to AtomicInteger 的源码读过吗？">​</a></h3>
<p>AtomicInteger 是基于 volatile 和 CAS 实现的，底层依赖于 Unsafe 类。核心方法包括 getAndIncrement、compareAndSet 等。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public final int getAndIncrement() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return unsafe.getAndAddInt(this, valueOffset, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="线程死锁了解吗">线程死锁了解吗？<a href="#线程死锁了解吗" class="hash-link" aria-label="Direct link to 线程死锁了解吗？" title="Direct link to 线程死锁了解吗？">​</a></h3>
<p>死锁发生在多个线程相互等待对方释放锁时。比如说线程 1 持有锁 R1，等待锁 R2；线程 2 持有锁 R2，等待锁 R1。
<img decoding="async" loading="lazy" alt="线程死锁" src="/doc/assets/images/线程死锁-fe03af14261a22cf7adad9e4fc8056be.png" width="976" height="526" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="死锁发生的四个条件了解吗">死锁发生的四个条件了解吗？<a href="#死锁发生的四个条件了解吗" class="hash-link" aria-label="Direct link to 死锁发生的四个条件了解吗？" title="Direct link to 死锁发生的四个条件了解吗？">​</a></h3>
<p>第一条件是互斥：资源不能被多个线程共享，一次只能由一个线程使用。如果一个线程已经占用了一个资源，其他请求该资源的线程必须等待，直到资源被释放。
第二个条件是持有并等待：一个线程已经持有一个资源，并且在等待获取其他线程持有的资源。
第三个条件是不可抢占：资源不能被强制从线程中夺走，必须等线程自己释放。
第四个条件是循环等待：存在一种线程等待链，线程 A 等待线程 B 持有的资源，线程 B 等待线程 C 持有的资源，直到线程 N 又等待线程
A 持有的资源。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="该如何避免死锁呢">该如何避免死锁呢？<a href="#该如何避免死锁呢" class="hash-link" aria-label="Direct link to 该如何避免死锁呢？" title="Direct link to 该如何避免死锁呢？">​</a></h3>
<p>第一，所有线程都按照固定的顺序来申请资源。例如，先申请 R1 再申请 R2。
第二，如果线程发现无法获取某个资源，可以先释放已经持有的资源，重新尝试申请。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="死锁问题怎么排查呢">🌟死锁问题怎么排查呢？<a href="#死锁问题怎么排查呢" class="hash-link" aria-label="Direct link to 🌟死锁问题怎么排查呢？" title="Direct link to 🌟死锁问题怎么排查呢？">​</a></h3>
<p>waitx</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="聊聊线程同步和互斥补充">聊聊线程同步和互斥？（补充）<a href="#聊聊线程同步和互斥补充" class="hash-link" aria-label="Direct link to 聊聊线程同步和互斥？（补充）" title="Direct link to 聊聊线程同步和互斥？（补充）">​</a></h3>
<p>同步，意味着线程之间要密切合作，按照一定的顺序来执行任务。比如说，线程 A 先执行，线程 B 再执行。
互斥，意味着线程之间要抢占资源，同一时间只能有一个线程访问共享资源。比如说，线程 A 在访问共享资源时，线程 B 不能访问。
同步关注的是线程之间的协作，互斥关注的是线程之间的竞争。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何实现同步和互斥">如何实现同步和互斥？<a href="#如何实现同步和互斥" class="hash-link" aria-label="Direct link to 如何实现同步和互斥？" title="Direct link to 如何实现同步和互斥？">​</a></h3>
<p>可以使用 synchronized 关键字或者 Lock 接口的实现类，如 ReentrantLock 来给资源加锁。
锁在操作系统层面的意思是 Mutex，某个线程进入临界区后，也就是获取到锁后，其他线程不能再进入临界区，要阻塞等待持有锁的线程离开临界区。
<img decoding="async" loading="lazy" alt="实现同步和互斥" src="/doc/assets/images/实现同步和互斥-f681ddd79c8d2c554973f4c91f238fb1.png" width="1538" height="1072" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="锁要解决哪些问题">锁要解决哪些问题？<a href="#锁要解决哪些问题" class="hash-link" aria-label="Direct link to 锁要解决哪些问题？" title="Direct link to 锁要解决哪些问题？">​</a></h3>
<p>第一，谁可以拿到锁，可以是类对象，可以是当前的 this 对象，也可以是任何其他新建的对象。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">synchronized (this){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 临界区</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span></code></pre></div></div>
<p>第二，抢占锁的规则，能不能抢占多次，自己能不能反复抢。
第三，抢不到怎么办，自旋？阻塞？或者超时放弃？
第四，锁被释放了还在等待锁的线程怎么办？是通知所有线程一起抢或者只告诉一个线程抢？</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说自旋锁">说说自旋锁？<a href="#说说自旋锁" class="hash-link" aria-label="Direct link to 说说自旋锁？" title="Direct link to 说说自旋锁？">​</a></h3>
<p>自旋锁是指当线程尝试获取锁时，如果锁已经被占用，线程不会立即阻塞，而是通过自旋，也就是循环等待的方式不断尝试获取锁。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">线程1        线程2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|            |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| 获取锁成功   | 尝试获取锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|------------&gt;|（锁已被占用，自旋等待）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| 释放锁      |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|&lt;------------| 获取锁成功</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|            |</span><br></span></code></pre></div></div>
<p>适用于锁持有时间短的场景，ReentrantLock 的 tryLock 方法就用到了自旋锁。
<img decoding="async" loading="lazy" alt="ReentrantLock自旋" src="/doc/assets/images/ReentrantLock自旋-890b0ff3925f458e40886160113b741a.png" width="1258" height="896" class="img_ev3q">
自旋锁的优点是可以避免线程切换带来的开销，缺点是如果锁被占用时间过长，会导致线程空转，浪费 CPU 资源。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class SpinLock {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private AtomicBoolean lock = new AtomicBoolean(false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void lock() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (!lock.compareAndSet(false, true)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 自旋等待，不断尝试获取锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void unlock() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lock.set(false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SpinLock spinLock = new SpinLock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Runnable task = () -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            spinLock.lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(Thread.currentThread().getName() + &quot; 获取到锁&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                spinLock.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread t1 = new Thread(task);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread t2 = new Thread(task);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t1.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t2.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>默认情况下，自旋锁会一直等待，直到获取到锁为止。在实际开发中，需要设置自旋次数或者超时时间。如果超过阈值，线程可以放弃锁或者进入阻塞状态。
互斥和同步在时间上有要求吗？
有。
互斥的核心是保证同一时刻只有一个线程能访问共享资源。
同步强调的是线程之间的执行顺序，特别是在多个线程需要依赖于彼此的执行结果时。
例如，在 CountDownLatch 中，主线程会等待多个子线程的任务完成。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class SyncExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        CountDownLatch latch = new CountDownLatch(3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建3个子线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; 3; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new Thread(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Thread.sleep(1000); // 模拟任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    System.out.println(&quot;打完王者了.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    latch.countDown(); // 每个线程任务完成后计数器减1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }).start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;等打完三把王者就去睡觉...&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        latch.await(); // 主线程等待子线程完成</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;好，王者玩完了，可以睡了&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>所有子线程完成后，主线程才会继续执行。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="聊聊悲观锁和乐观锁补充">🌟聊聊悲观锁和乐观锁？（补充）<a href="#聊聊悲观锁和乐观锁补充" class="hash-link" aria-label="Direct link to 🌟聊聊悲观锁和乐观锁？（补充）" title="Direct link to 🌟聊聊悲观锁和乐观锁？（补充）">​</a></h3>
<p>好的。
悲观锁认为每次访问共享资源时都会发生冲突，所在在操作前一定要先加锁，防止其他线程修改数据。
乐观锁认为冲突不会总是发生，所以在操作前不加锁，而是在更新数据时检查是否有其他线程修改了数据。如果发现数据被修改了，就会重试。
乐观锁发现有线程过来修改数据，怎么办？
可以重新读取数据，然后再尝试更新，直到成功为止或达到最大重试次数。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class CasRetryExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static AtomicInteger counter = new AtomicInteger(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final int MAX_RETRIES = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean success = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int retries = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (retries &lt; MAX_RETRIES) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int currentValue = counter.get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            boolean updated = counter.compareAndSet(currentValue, currentValue + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (updated) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;更新成功，当前值: &quot; + counter.get());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                success = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                retries++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;更新失败，进行第 &quot; + retries + &quot; 次重试&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!success) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;达到最大重试次数，操作失败&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="并发工具类">并发工具类<a href="#并发工具类" class="hash-link" aria-label="Direct link to 并发工具类" title="Direct link to 并发工具类">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="countdownlatch-了解吗">CountDownLatch 了解吗？<a href="#countdownlatch-了解吗" class="hash-link" aria-label="Direct link to CountDownLatch 了解吗？" title="Direct link to CountDownLatch 了解吗？">​</a></h3>
<p>推荐阅读：Semaphore、Exchanger、CountDownLatch、CyclicBarrier、Phaser，一网打尽
CountDownLatch 是 JUC 中的一个同步工具类，用于协调多个线程之间的同步，确保主线程在多个子线程完成任务后继续执行。
它的核心思想是通过一个倒计时计数器来控制多个线程的执行顺序。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class CountDownLatchExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int threadCount = 3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        CountDownLatch latch = new CountDownLatch(threadCount);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; threadCount; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new Thread(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Thread.sleep((long) (Math.random() * 1000)); // 模拟任务执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    System.out.println(Thread.currentThread().getName() + &quot; 执行完毕&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    latch.countDown(); // 线程完成后，计数器 -1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }).start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        latch.await(); // 主线程等待</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;所有子线程执行完毕，主线程继续执行&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>在使用的时候，我们需要先初始化一个 CountDownLatch 对象，指定一个计数器的初始值，表示需要等待的线程数量。
然后在每个子线程执行完任务后，调用 countDown() 方法，计数器减 1。
接着主线程调用 await() 方法进入阻塞状态，直到计数器为 0，也就是所有子线程都执行完任务后，主线程才会继续执行。
<img decoding="async" loading="lazy" alt="CountDownLatch等待" src="/doc/assets/images/CountDownLatch等待-9936ea072d73aeb691b272f37708bb55.png" width="1796" height="954" class="img_ev3q"></p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public static void main(String[] args) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    CountDownLatch countDownLatch = new CountDownLatch(5);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Thread daqiao = new Thread(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;大乔已就位！&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        countDownLatch.countDown();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Thread lanlingwang = new Thread(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;兰陵王已就位！&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        countDownLatch.countDown();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Thread anqila = new Thread(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;安其拉已就位！&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        countDownLatch.countDown();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Thread nezha = new Thread(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;哪吒已就位！&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        countDownLatch.countDown();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Thread kai = new Thread(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;铠已就位！&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        countDownLatch.countDown();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    daqiao.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    lanlingwang.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    anqila.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    nezha.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    kai.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    countDownLatch.await();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(&quot;全员就位，开始游戏！&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>五个玩家在倒计时结束后，一起出击。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private static void waitToFight(CountDownLatch countDownLatch, String name) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        countDownLatch.await(); // 在此等待信号再继续</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(name + &quot; 收到，发起进攻！&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread.currentThread().interrupt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(name + &quot; 被中断&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    CountDownLatch countDownLatch = new CountDownLatch(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Thread daqiao = new Thread(() -&gt; waitToFight(countDownLatch, &quot;大乔&quot;), &quot;Thread-大乔&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Thread lanlingwang = new Thread(() -&gt; waitToFight(countDownLatch, &quot;兰陵王&quot;), &quot;Thread-兰陵王&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Thread anqila = new Thread(() -&gt; waitToFight(countDownLatch, &quot;安琪拉&quot;), &quot;Thread-安琪拉&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Thread nezha = new Thread(() -&gt; waitToFight(countDownLatch, &quot;哪吒&quot;), &quot;Thread-哪吒&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Thread kai = new Thread(() -&gt; waitToFight(countDownLatch, &quot;凯&quot;), &quot;Thread-凯&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    daqiao.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    lanlingwang.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    anqila.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    nezha.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    kai.start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread.sleep(5000); // 模拟准备时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread.currentThread().interrupt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;主线程被中断&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(&quot;敌军还有 5 秒到达战场，全军出击！&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    countDownLatch.countDown(); // 发出信号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="场景题假如要查10万多条数据用线程池分成20个线程去执行怎么做到等所有的线程都查找完之后即最后一条结果查找结束了才输出结果">场景题：假如要查10万多条数据，用线程池分成20个线程去执行，怎么做到等所有的线程都查找完之后，即最后一条结果查找结束了，才输出结果？<a href="#场景题假如要查10万多条数据用线程池分成20个线程去执行怎么做到等所有的线程都查找完之后即最后一条结果查找结束了才输出结果" class="hash-link" aria-label="Direct link to 场景题：假如要查10万多条数据，用线程池分成20个线程去执行，怎么做到等所有的线程都查找完之后，即最后一条结果查找结束了，才输出结果？" title="Direct link to 场景题：假如要查10万多条数据，用线程池分成20个线程去执行，怎么做到等所有的线程都查找完之后，即最后一条结果查找结束了，才输出结果？">​</a></h3>
<p>很简单，可以使用 CountDownLatch 来实现。CountDownLatch 非常适合这个场景。
第一步，创建 CountDownLatch 对象，初始值设定为 20，表示 20 个线程需要完成任务。
第二步，创建线程池，每个线程执行查询操作，查询完毕后调用 countDown() 方法，计数器减 1。
第三步，主线程调用 await() 方法，等待所有线程执行完毕。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class DataQueryExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 模拟10万条数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int totalRecords = 100000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int threadCount = 20;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int batchSize = totalRecords / threadCount; // 每个线程处理的数据量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建线程池</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ExecutorService executor = Executors.newFixedThreadPool(threadCount);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        CountDownLatch latch = new CountDownLatch(threadCount);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 模拟查询结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ConcurrentLinkedQueue&lt;String&gt; results = new ConcurrentLinkedQueue&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; threadCount; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int start = i * batchSize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int end = (i == threadCount - 1) ? totalRecords : (start + batchSize);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            executor.execute(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 模拟查询操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    for (int j = start; j &lt; end; j++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        results.add(&quot;Data-&quot; + j);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    System.out.println(Thread.currentThread().getName() + &quot; 处理数据 &quot; + start + &quot; - &quot; + end);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    latch.countDown(); // 线程任务完成，计数器减1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 等待所有线程完成</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        latch.await();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        executor.shutdown();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 输出结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;所有线程执行完毕，查询结果总数：&quot; + results.size());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="cyclicbarrier-了解吗">CyclicBarrier 了解吗？<a href="#cyclicbarrier-了解吗" class="hash-link" aria-label="Direct link to CyclicBarrier 了解吗？" title="Direct link to CyclicBarrier 了解吗？">​</a></h3>
<p>CyclicBarrier 的字面意思是可循环使用的屏障，用于多个线程相互等待，直到所有线程都到达屏障后再同时执行。
<img decoding="async" loading="lazy" alt="CyclicBarrier流程" src="/doc/assets/images/CyclicBarrier流程-077e39524694f8bed12e210ff880264c.png" width="1321" height="536" class="img_ev3q"></p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class CyclicBarrierExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final int THREAD_COUNT = 3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final CyclicBarrier barrier = new CyclicBarrier(THREAD_COUNT);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; THREAD_COUNT; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new Thread(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    System.out.println(Thread.currentThread().getName() + &quot; 到达屏障&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    barrier.await(); // 线程阻塞，直到所有线程都到达</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    System.out.println(Thread.currentThread().getName() + &quot; 继续执行&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (InterruptedException | BrokenBarrierException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }).start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="cyclicbarrier-和-countdownlatch-有什么区别">CyclicBarrier 和 CountDownLatch 有什么区别？<a href="#cyclicbarrier-和-countdownlatch-有什么区别" class="hash-link" aria-label="Direct link to CyclicBarrier 和 CountDownLatch 有什么区别？" title="Direct link to CyclicBarrier 和 CountDownLatch 有什么区别？">​</a></h3>
<p>CyclicBarrier 让所有线程相互等待，全部到达后再继续；CountDownLatch 让主线程等待所有子线程执行完再继续。
对比项 CyclicBarrier CountDownLatch
主要用途 让所有线程相互等待，全部到达后再继续 让主线程等待所有子线程执行完
可重用性 ✅ 可重复使用，每次屏障打开后自动重置 ❌ 不可重复使用，计数器归零后不能恢复
是否可执行回调 ✅ 可以，所有线程到达屏障后可执行 barrierAction ❌ 不能
线程等待情况 所有线程互相等待，一个线程未到达，其他线程都会阻塞 主线程等待所有子线程完成，子线程执行完后可继续运行
适用场景 线程相互依赖，需要同步执行 主线程等待子线程完成
示例场景 计算任务拆分，所有线程都到达后才能继续 主线程等多个任务初始化完成</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="semaphore-了解吗">Semaphore 了解吗？<a href="#semaphore-了解吗" class="hash-link" aria-label="Direct link to Semaphore 了解吗？" title="Direct link to Semaphore 了解吗？">​</a></h3>
<p>Semaphore——信号量，用于控制同时访问某个资源的线程数量，类似限流器，确保最多只有指定数量的线程能够访问某个资源，超过的必须等待。
<img decoding="async" loading="lazy" alt="信号量" src="/doc/assets/images/信号量-246d804f38e1ab828a282ad80e239288.png" width="1150" height="1306" class="img_ev3q">
拿停车场来举例。
停车场的车位是有限的，如果有空位，显示牌需要显示剩余的车位，车辆就可以驶入；否则就会显示数字 0，新来的车辆就得排队等待。
如果有车离开，显示牌重新显示闲置的车位数量，等待的车辆按序驶入停车场。
在使用 Semaphore 时，首先需要初始化一个 Semaphore 对象，指定许可证数量，表示最多允许多少个线程同时访问资源。
然后在每个线程访问资源前，调用 acquire() 方法获取许可证，如果没有可用许可证，则阻塞等待。
需要注意的是，访问完资源后，要调用 release() 方法释放许可证。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class SemaphoreExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final int THREAD_COUNT = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final Semaphore semaphore = new Semaphore(2); // 最多允许 2 个线程访问</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; THREAD_COUNT; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new Thread(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    semaphore.acquire(); // 获取许可（如果没有可用许可，则阻塞）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    System.out.println(Thread.currentThread().getName() + &quot; 访问资源...&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Thread.sleep(2000); // 模拟任务执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    semaphore.release(); // 释放许可</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }).start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>Semaphore 可以用于流量控制，比如数据库连接池、网络连接池等。
假如有这样一个需求，要读取几万个文件的数据，因为都是 IO 密集型任务，我们可以启动几十个线程并发地读取。
但是在读到内存后，需要存储到数据库，而数据库连接数是有限的，比如说只有 10 个，那我们就必须控制线程的数量，保证同时只有 10
个线程在使用数据库连接。
这个时候，就可以使用 Semaphore 来做流量控制：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class SemaphoreTest {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final int THREAD_COUNT = 30;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static Semaphore s = new Semaphore(10);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; THREAD_COUNT; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            threadPool.execute(new Runnable() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        s.acquire();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        System.out.println(&quot;save data&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        s.release();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        threadPool.shutdown();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="exchanger-了解吗">Exchanger 了解吗？<a href="#exchanger-了解吗" class="hash-link" aria-label="Direct link to Exchanger 了解吗？" title="Direct link to Exchanger 了解吗？">​</a></h3>
<p>Exchanger——交换者，用于在两个线程之间进行数据交换。
<img decoding="async" loading="lazy" alt="Exchanger" src="/doc/assets/images/Exchanger-8cc15ff3c17943400be727b86e4bed38.png" width="2260" height="782" class="img_ev3q">
支持双向数据交换，比如说线程 A 调用 exchange(dataA)，线程 B 调用 exchange(dataB)，它们会在同步点交换数据，即 A 得到 B 的数据，B
得到 A 的数据。
如果一个线程先调用 exchange()，它会阻塞等待，直到另一个线程也调用 exchange()。
使用 Exchanger 的时候，需要先创建一个 Exchanger 对象，然后在两个线程中调用 exchange() 方法，就可以进行数据交换了。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class ExchangerExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final Exchanger&lt;String&gt; exchanger = new Exchanger&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new Thread(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                String threadAData = &quot;数据 A&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;线程 A 交换前的数据：&quot; + threadAData);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                String received = exchanger.exchange(threadAData);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;线程 A 收到的数据：&quot; + received);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }).start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new Thread(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                String threadBData = &quot;数据 B&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;线程 B 交换前的数据：&quot; + threadBData);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                String received = exchanger.exchange(threadBData);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;线程 B 收到的数据：&quot; + received);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }).start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>Exchanger 可以用于遗传算法，也可以用于校对工作，比如我们将纸制银行流水通过人工的方式录入到电子银行时，为了避免错误，可以录入两遍，然后通过
Exchanger 来校对两次录入的结果。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class ExchangerTest {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final Exchanger&lt;String&gt; exgr = new Exchanger&lt;String&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static ExecutorService threadPool = Executors.newFixedThreadPool(2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        threadPool.execute(new Runnable() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    String A = &quot;银行流水A&quot;; // A录入银行流水数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    exgr.exchange(A);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        threadPool.execute(new Runnable() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    String B = &quot;银行流水B&quot;; // B录入银行流水数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    String A = exgr.exchange(&quot;B&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    System.out.println(&quot;A和B数据是否一致：&quot; + A.equals(B) + &quot;，A录入的是：&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            + A + &quot;，B录入是：&quot; + B);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        threadPool.shutdown();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="能说一下-concurrenthashmap-的实现吗补充">🌟能说一下 ConcurrentHashMap 的实现吗？（补充）<a href="#能说一下-concurrenthashmap-的实现吗补充" class="hash-link" aria-label="Direct link to 🌟能说一下 ConcurrentHashMap 的实现吗？（补充）" title="Direct link to 🌟能说一下 ConcurrentHashMap 的实现吗？（补充）">​</a></h3>
<p>好的。ConcurrentHashMap 是 HashMap 的线程安全版本。
JDK 7 采用的是分段锁，整个 Map 会被分为若干段，每个段都可以独立加锁。不同的线程可以同时操作不同的段，从而实现并发
<img decoding="async" loading="lazy" alt="JAVA7的ConcurrentHashMap安全实现" src="/doc/assets/images/JAVA7的ConcurrentHashMap安全实现-16d43cf6d3bc0830271b849e99ea8f4b.png" width="1512" height="1053" class="img_ev3q">
JDK 8 使用了一种更加细粒度的锁——桶锁，再配合 CAS + synchronized 代码块控制并发写入，以最大程度减少锁的竞争。
<img decoding="async" loading="lazy" alt="JAVA8的ConcurrentHashMap安全实现" src="/doc/assets/images/JAVA8的ConcurrentHashMap安全实现-02fb5bc6f5e4126630ef5db8771ffc5a.png" width="1512" height="1165" class="img_ev3q">
对于读操作，ConcurrentHashMap 使用了 volatile 变量来保证内存可见性。
对于写操作，ConcurrentHashMap 优先使用 CAS 尝试插入，如果成功就直接返回；否则使用 synchronized 代码块进行加锁处理。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说一下-jdk-7-中-concurrenthashmap-的实现原理">说一下 JDK 7 中 ConcurrentHashMap 的实现原理？<a href="#说一下-jdk-7-中-concurrenthashmap-的实现原理" class="hash-link" aria-label="Direct link to 说一下 JDK 7 中 ConcurrentHashMap 的实现原理？" title="Direct link to 说一下 JDK 7 中 ConcurrentHashMap 的实现原理？">​</a></h3>
<p>好的。
JDK 7 的 ConcurrentHashMap 采用的是分段锁，整个 Map 会被分为若干段，每个段都可以独立加锁，每个段类似一个 Hashtable。
<img decoding="async" loading="lazy" alt="ConcurrentHashMap分段锁" src="/doc/assets/images/ConcurrentHashMap分段锁-307733badc8eb239df85b0abe6f4d1bc.png" width="1057" height="376" class="img_ev3q">
每个段维护一个键值对数组 <code>HashEntry&lt;K, V&gt;[] table，HashEntry</code> 是一个单项链表。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static final class HashEntry&lt;K, V&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final int hash;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final K key;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    volatile V value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final HashEntry&lt;K, V&gt; next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>段继承了 ReentrantLock，所以每个段都是一个可重入锁，不同的线程可以同时操作不同的段，从而实现并发。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static final class Segment&lt;K, V&gt; extends ReentrantLock {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    transient volatile HashEntry&lt;K, V&gt;[] table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    transient int count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说一下-jdk-7-中-concurrenthashmap-的-put-流程">说一下 JDK 7 中 ConcurrentHashMap 的 put 流程？<a href="#说一下-jdk-7-中-concurrenthashmap-的-put-流程" class="hash-link" aria-label="Direct link to 说一下 JDK 7 中 ConcurrentHashMap 的 put 流程？" title="Direct link to 说一下 JDK 7 中 ConcurrentHashMap 的 put 流程？">​</a></h3>
<p>put 流程和 HashMap 非常类似，只不过是先定位到具体的段，再通过 ReentrantLock 去操作而已。一共可以分为 4 个步骤：
第一步，计算 key 的 hash，定位到段，段如果是空就先初始化；
第二步，使用 ReentrantLock 进行加锁，如果加锁失败就自旋，自旋超过次数就阻塞，保证一定能获取到锁；
第三步，遍历段中的键值对 HashEntry，key 相同直接替换，key 不存在就插入。
第四步，释放锁。
<img decoding="async" loading="lazy" alt="JAVA7-ConcurrentHashMap的put流程" src="/doc/assets/images/JAVA7-ConcurrentHashMap的put流程-d960bd9af7bb4af8cd1d80c2f791cb5d.png" width="1045" height="1667" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说一下-jdk-7-中-concurrenthashmap-的-get-流程">说一下 JDK 7 中 ConcurrentHashMap 的 get 流程？<a href="#说一下-jdk-7-中-concurrenthashmap-的-get-流程" class="hash-link" aria-label="Direct link to 说一下 JDK 7 中 ConcurrentHashMap 的 get 流程？" title="Direct link to 说一下 JDK 7 中 ConcurrentHashMap 的 get 流程？">​</a></h3>
<p>get 就更简单了，先计算 key 的 hash 找到段，再遍历段中的键值对，找到就直接返回 value。
get 不用加锁，因为是 value 是 volatile 的，所以线程读取 value 时不会出现可见性问题。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说一下-jdk-8-中-concurrenthashmap-的实现原理">说一下 JDK 8 中 ConcurrentHashMap 的实现原理？<a href="#说一下-jdk-8-中-concurrenthashmap-的实现原理" class="hash-link" aria-label="Direct link to 说一下 JDK 8 中 ConcurrentHashMap 的实现原理？" title="Direct link to 说一下 JDK 8 中 ConcurrentHashMap 的实现原理？">​</a></h3>
<p>JDK 8 中的 ConcurrentHashMap 取消了分段锁，采用 CAS + synchronized 来实现更细粒度的桶锁，并且使用红黑树来优化链表以提高哈希冲突时的查询效率，性能比
JDK 7 有了很大的提升。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说一下-jdk-8-中-concurrenthashmap-的-put-流程">说一下 JDK 8 中 ConcurrentHashMap 的 put 流程？<a href="#说一下-jdk-8-中-concurrenthashmap-的-put-流程" class="hash-link" aria-label="Direct link to 说一下 JDK 8 中 ConcurrentHashMap 的 put 流程？" title="Direct link to 说一下 JDK 8 中 ConcurrentHashMap 的 put 流程？">​</a></h3>
<p><img decoding="async" loading="lazy" alt="JAVA8-ConcurrentHashMap的put流程" src="/doc/assets/images/JAVA8-ConcurrentHashMap的put流程-3791fac23d09e6961184bdb01e2afa08.png" width="784" height="734" class="img_ev3q">
第一步，计算 key 的 hash，以确定桶在数组中的位置。如果数组为空，采用 CAS 的方式初始化，以确保只有一个线程在初始化数组。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private void put(value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   // 计算 hash</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   int hash = spread(key.hashCode());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   // 初始化数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   if (tab == null || (n = tab.length) == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      tab = initTable();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   // 计算桶的位置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   int i = (n - 1) &amp; hash;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>第二步，如果桶为空，直接 CAS 插入节点。如果 CAS 操作失败，会退化为 synchronized 代码块来插入节点。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private void put(value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   // CAS 插入节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   if (tabAt(tab, i) == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (casTabAt(tab, i, null, new Node&lt;K, V&gt;(hash, key, value, null)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   // 否则，使用 synchronized 代码块插入节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      synchronized (f) {  // **只锁当前桶**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         if (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 tabAt(tab, i) == f) { // 确保未被其他线程修改</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (f.hash &gt;= 0) { // 链表处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               for (Node&lt;K, V&gt; e = f;; ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  K ek;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (key != null &amp;&amp; key.equals(ek)))) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     e.val = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  e = e.next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else if (f instanceof TreeBin) { // **红黑树处理**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               ((TreeBin&lt;K, V&gt;) f).</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       putTreeVal(hash, key, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>插入的过程中会判断桶的哈希是否小于 0（f.hash &gt;= 0），小于 0 说明是红黑树，大于等于 0 说明是链表。
这里补充一点：在 ConcurrentHashMap 的实现中，红黑树节点 TreeBin 的 hash 值固定为 -2。
<img decoding="async" loading="lazy" alt="ConcurrentHashMap节点转红黑树" src="/doc/assets/images/ConcurrentHashMap节点转红黑树-cc65e960ef2dd4c1d4af6fde43aa76eb.png" width="1102" height="320" class="img_ev3q">
第三步，如果链表长度超过 8，转换为红黑树。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">if(binCount &gt;=TREEIFY_THRESHOLD)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    treeifyBin(tab, i);</span><br></span></code></pre></div></div>
<p>第四步，在插入新节点后，会调用 addCount() 方法检查是否需要扩容。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">addCount(1L,binCount);</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说一下-jdk-8-中-concurrenthashmap-的-get-流程">说一下 JDK 8 中 ConcurrentHashMap 的 get 流程？<a href="#说一下-jdk-8-中-concurrenthashmap-的-get-流程" class="hash-link" aria-label="Direct link to 说一下 JDK 8 中 ConcurrentHashMap 的 get 流程？" title="Direct link to 说一下 JDK 8 中 ConcurrentHashMap 的 get 流程？">​</a></h3>
<p>get 也是通过 key 的 hash 进行定位，如果该位置节点的哈希匹配且键相等，则直接返回值。</p>
<p><img decoding="async" loading="lazy" alt="ConcurrentHashMap的get流程" src="/doc/assets/images/ConcurrentHashMap的get流程-3d727c3cc5ff6e067026f23f9b032f91.png" width="1274" height="854" class="img_ev3q">
如果节点的哈希为负数，说明是个特殊节点，比如说如树节点或者正在迁移的节点，就调用find方法查找。
否则遍历链表查找匹配的键。如果都没找到，返回 null。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说一下-hashmap-和-concurrenthashmap-的区别">说一下 HashMap 和 ConcurrentHashMap 的区别？<a href="#说一下-hashmap-和-concurrenthashmap-的区别" class="hash-link" aria-label="Direct link to 说一下 HashMap 和 ConcurrentHashMap 的区别？" title="Direct link to 说一下 HashMap 和 ConcurrentHashMap 的区别？">​</a></h3>
<p>HashMap 是非线程安全的，多线程环境下应该使用 ConcurrentHashMap。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="你项目中怎么使用-concurrenthashmap-的">你项目中怎么使用 ConcurrentHashMap 的？<a href="#你项目中怎么使用-concurrenthashmap-的" class="hash-link" aria-label="Direct link to 你项目中怎么使用 ConcurrentHashMap 的？" title="Direct link to 你项目中怎么使用 ConcurrentHashMap 的？">​</a></h3>
<p>在技术派实战项目中，很多地方都用到了 ConcurrentHashMap，比如说在异步工具类 AsyncUtil 中，就使用了 ConcurrentHashMap
来存储任务的名称和它们的运行时间，以便观察和分析任务的执行情况。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说一下-concurrenthashmap-对-hashmap-的改进">说一下 ConcurrentHashMap 对 HashMap 的改进？<a href="#说一下-concurrenthashmap-对-hashmap-的改进" class="hash-link" aria-label="Direct link to 说一下 ConcurrentHashMap 对 HashMap 的改进？" title="Direct link to 说一下 ConcurrentHashMap 对 HashMap 的改进？">​</a></h3>
<p>首先是 hash 的计算方法上，ConcurrentHashMap 的 spread 方法接收一个已经计算好的 hashCode，然后将这个哈希码的高 16
位与自身进行异或运算。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static final int spread(int h) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>比 HashMap 的 hash 计算多了一个 &amp; HASH_BITS 的操作。这里的 HASH_BITS 是一个常数，值为 0x7fffffff，它确保结果是一个非负整数。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static final int hash(Object key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int h;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>另外，ConcurrentHashMap 对节点 Node 做了进一步的封装，比如说用 Forwarding Node 来表示正在进行扩容的节点。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static final class ForwardingNode&lt;K, V&gt; extends Node&lt;K, V&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final Node&lt;K, V&gt;[] nextTable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ForwardingNode(Node&lt;K, V&gt;[] tab) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super(MOVED, null, null, null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.nextTable = tab;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>最后就是 put 方法，通过 CAS + synchronized 代码块来进行并发写入。
<img decoding="async" loading="lazy" alt="ConcurrentHashMap的put源码" src="/doc/assets/images/ConcurrentHashMap的put源码-e462be284f1c49224d8ab16cf4bb1c5a.png" width="1372" height="1328" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么-concurrenthashmap-在-jdk-17-中要用-reentrantlock而在-jdk-18-要用-synchronized">为什么 ConcurrentHashMap 在 JDK 1.7 中要用 ReentrantLock，而在 JDK 1.8 要用 synchronized<a href="#为什么-concurrenthashmap-在-jdk-17-中要用-reentrantlock而在-jdk-18-要用-synchronized" class="hash-link" aria-label="Direct link to 为什么 ConcurrentHashMap 在 JDK 1.7 中要用 ReentrantLock，而在 JDK 1.8 要用 synchronized" title="Direct link to 为什么 ConcurrentHashMap 在 JDK 1.7 中要用 ReentrantLock，而在 JDK 1.8 要用 synchronized">​</a></h3>
<p>JDK 1.7 中的 ConcurrentHashMap 使用了分段锁机制，每个 Segment 都继承了 ReentrantLock，这样可以保证每个 Segment 都可以独立地加锁。
而在 JDK 1.8 中，ConcurrentHashMap 取消了 Segment 分段锁，采用了更加精细化的锁——桶锁，以及 CAS 无锁算法，每个桶都可以独立地加锁，只有</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="concurrenthashmap-怎么保证可见性补充">ConcurrentHashMap 怎么保证可见性？（补充）<a href="#concurrenthashmap-怎么保证可见性补充" class="hash-link" aria-label="Direct link to ConcurrentHashMap 怎么保证可见性？（补充）" title="Direct link to ConcurrentHashMap 怎么保证可见性？（补充）">​</a></h3>
<p>ConcurrentHashMap 中的 Node 节点中，value 和 next 都是 volatile 的，这样就可以保证对 value 或 next 的更新会被其他线程立即看到。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static class Node&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final int hash;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final K key;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    volatile V value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    volatile Node&lt;K, V&gt; next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么-concurrenthashmap-比-hashtable-效率高补充">为什么 ConcurrentHashMap 比 Hashtable 效率高（补充）<a href="#为什么-concurrenthashmap-比-hashtable-效率高补充" class="hash-link" aria-label="Direct link to 为什么 ConcurrentHashMap 比 Hashtable 效率高（补充）" title="Direct link to 为什么 ConcurrentHashMap 比 Hashtable 效率高（补充）">​</a></h3>
<p>Hashtable 在任何时刻只允许一个线程访问整个 Map，是通过对整个 Map 加锁来实现线程安全的。比如 get 和 put 方法，是直接在方法上加的
synchronized 关键字。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public synchronized V put(K key, V value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (value == null) throw new NullPointerException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int hash = key.hashCode();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int index = (hash &amp; 0x7FFFFFFF) % table.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return oldValue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>而 ConcurrentHashMap 在 JDK 8 中是采用 CAS + synchronized 实现的，仅在必要时加锁。
比如说 put 的时候优先使用 CAS 尝试插入，如果失败再使用 synchronized 代码块加锁。
get 的时候是完全无锁的，因为 value 是 volatile 变量 修饰的，保证了内存可见性。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public V get(Object key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int hash = spread(key.hashCode());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Node&lt;K, V&gt;[] tab = table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int index = (tab.length - 1) &amp; hash;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Node&lt;K, V&gt; e = tabAt(tab, index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (e != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        do {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (e.hash == hash &amp;&amp; (e.key == key || (key != null &amp;&amp; key.equals(e.key)))) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return e.value;  // 读取 volatile 变量，保证可见性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } while ((e = e.next) != null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="能说一下-copyonwritearraylist-的实现原理吗补充">能说一下 CopyOnWriteArrayList 的实现原理吗？（补充）<a href="#能说一下-copyonwritearraylist-的实现原理吗补充" class="hash-link" aria-label="Direct link to 能说一下 CopyOnWriteArrayList 的实现原理吗？（补充）" title="Direct link to 能说一下 CopyOnWriteArrayList 的实现原理吗？（补充）">​</a></h3>
<p>CopyOnWriteArrayList 是 ArrayList 的线程安全版本，适用于读多写少的场景。它的核心思想是写操作时创建一个新数组，修改后再替换原数组，这样就能够确保读操作无锁，从而提高并发性能。
<img decoding="async" loading="lazy" alt="CopyOnWriteArrayList原理" src="/doc/assets/images/CopyOnWriteArrayList原理-86e747b2e1ee42b8cd0234b68a9b7ac8.png" width="377" height="445" class="img_ev3q">
内部使用 volatile 变量来修饰数组 array，以读操作的内存可见性。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private transient volatile Object[] array;</span><br></span></code></pre></div></div>
<p>写操作的时候使用 ReentrantLock 来保证线程安全。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public boolean add(E e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final ReentrantLock lock = this.lock;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 加锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    lock.lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object[] elements = getArray();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int len = elements.length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建一个新数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object[] newElements = Arrays.copyOf(elements, len + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        newElements[len] = e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 替换原数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        setArray(newElements);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 释放锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lock.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>缺点就是写操作的时候会复制一个新数组，如果数组很大，写操作的性能会受到影响。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="能说一下-blockingqueue-吗补充">能说一下 BlockingQueue 吗？（补充）<a href="#能说一下-blockingqueue-吗补充" class="hash-link" aria-label="Direct link to 能说一下 BlockingQueue 吗？（补充）" title="Direct link to 能说一下 BlockingQueue 吗？（补充）">​</a></h3>
<p>BlockingQueue 是 JUC 包下的一个线程安全队列，支持阻塞式的“生产者-消费者”模型。
当队列容器已满，生产者线程会被阻塞，直到消费者线程取走元素后为止；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。
BlockingQueue 的实现类有很多，比如说 ArrayBlockingQueue、PriorityBlockingQueue 等。
实现类 数据结构 是否有界 特点</p>
<table><thead><tr><th style="text-align:left">实现类</th><th style="text-align:left">数据结构</th><th style="text-align:left">是否有界</th><th style="text-align:left">特点</th></tr></thead><tbody><tr><td style="text-align:left"><strong>ArrayBlockingQueue</strong></td><td style="text-align:left">数组</td><td style="text-align:left">✅ 有界</td><td style="text-align:left">基于数组，固定容量，FIFO（先进先出）</td></tr><tr><td style="text-align:left"><strong>LinkedBlockingQueue</strong></td><td style="text-align:left">链表</td><td style="text-align:left">✅ 可有界</td><td style="text-align:left">基于链表，默认容量为 <code>Integer.MAX_VALUE</code>，吞吐量通常更高</td></tr><tr><td style="text-align:left"><strong>PriorityBlockingQueue</strong></td><td style="text-align:left">堆（优先队列）</td><td style="text-align:left">❌ 无界</td><td style="text-align:left">元素按优先级排序，非 FIFO</td></tr><tr><td style="text-align:left"><strong>DelayQueue</strong></td><td style="text-align:left">优先队列（基于 <code>Delayed</code> 接口）</td><td style="text-align:left">❌ 无界</td><td style="text-align:left">元素只有在到期后才能被取出</td></tr><tr><td style="text-align:left"><strong>SynchronousQueue</strong></td><td style="text-align:left">无缓冲</td><td style="text-align:left">✅ 容量为 0</td><td style="text-align:left">必须一对一交换数据，适用于高吞吐的任务提交场景</td></tr><tr><td style="text-align:left"><strong>LinkedTransferQueue</strong></td><td style="text-align:left">链表</td><td style="text-align:left">❌ 无界</td><td style="text-align:left">支持 <code>tryTransfer()</code> 等方法，可尝试将数据立即交给消费者</td></tr></tbody></table>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="阻塞队列是如何实现的">阻塞队列是如何实现的？<a href="#阻塞队列是如何实现的" class="hash-link" aria-label="Direct link to 阻塞队列是如何实现的？" title="Direct link to 阻塞队列是如何实现的？">​</a></h3>
<p>阻塞队列使用 ReentrantLock + Condition 来确保并发安全。
以 ArrayBlockingQueue 为例，它内部维护了一个数组，使用两个指针分别指向队头和队尾。
put 的时候先用 ReentrantLock 加锁，然后判断队列是否已满，如果已满就阻塞等待，否则插入元素。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">final ReentrantLock lock;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private final Condition notEmpty;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private final Condition notFull;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void put(E e) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    final ReentrantLock lock = this.lock;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    lock.lockInterruptibly(); // 🔹 加锁，确保线程安全</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (count == items.length) { // 🔹 队列满，阻塞</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            notFull.await();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        enqueue(e); // 🔹 插入元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lock.unlock(); // 🔹 释放锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="线程池">线程池<a href="#线程池" class="hash-link" aria-label="Direct link to 线程池" title="Direct link to 线程池">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是线程池">🌟什么是线程池？<a href="#什么是线程池" class="hash-link" aria-label="Direct link to 🌟什么是线程池？" title="Direct link to 🌟什么是线程池？">​</a></h3>
<p>线程池是用来管理和复用线程的工具，它可以减少线程的创建和销毁开销。
在 Java 中，ThreadPoolExecutor 是线程池的核心实现，它通过核心线程数、最大线程数、任务队列和拒绝策略来控制线程的创建和执行。
举个例子：就像你开了一家餐厅，线程池就相当于固定数量的服务员，顾客（任务）来了就安排空闲的服务员（线程）处理，避免了频繁招人和解雇的成本。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="你在项目中有用到线程池吗">你在项目中有用到线程池吗？<a href="#你在项目中有用到线程池吗" class="hash-link" aria-label="Direct link to 你在项目中有用到线程池吗？" title="Direct link to 你在项目中有用到线程池吗？">​</a></h3>
<p>推荐阅读：线程池在美团业务中的应用
有，用到过很多次。
比如说在技术派实战项目当中， 我们就封装了一个异步工具类 AsyncUtil，内置了可配置的线程池，基于 ThreadPoolExecutor，适用于 IO
密集型任务。
其中 corePoolSize 为 CPU 核心数的两倍，因为技术派中的大多数任务都是 IO 密集型的，maxPoolSize 设置为
50，是一个比较理想的值，尤其是在本地环境中；阻塞队列为 SynchronousQueue，意味着任务被创建后可以直接提交给等待的线程处理。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说一下线程池的工作流程">🌟说一下线程池的工作流程？<a href="#说一下线程池的工作流程" class="hash-link" aria-label="Direct link to 🌟说一下线程池的工作流程？" title="Direct link to 🌟说一下线程池的工作流程？">​</a></h3>
<p>可以简单总结为：
任务提交 → 核心线程执行 → 任务队列缓存 → 非核心线程执行 → 拒绝策略处理。
第一步，线程池通过 submit() 提交任务。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private void test() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ExecutorService threadPool = Executors.newFixedThreadPool(5);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   threadPool.submit(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      System.out.println(Thread.currentThread().getName() + &quot;\t&quot; + &quot;办理业务&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>第二步，线程池会先创建核心线程来执行任务。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    if(workerCountOf(c) &lt;corePoolSize){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(addWorker(command, true)){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre></div></div>
<p>第三步，如果核心线程都在忙，任务会被放入任务队列中。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">if(!addWorker(command, false))</span><br></span></code></pre></div></div>
<p>第四步，如果任务队列已满，且当前线程数量小于最大线程数，线程池会创建新的线程来处理任务。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">if(!addWorker(command, false))</span><br></span></code></pre></div></div>
<p>第五步，如果线程池中的线程数量已经达到最大线程数，且任务队列已满，线程池会执行拒绝策略。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">handler.rejectedExecution(command, this);</span><br></span></code></pre></div></div>
<p>另外一版回答。</p>
<p>第一步，创建线程池。
第二步，调用线程池的 execute()方法，准备执行任务。
如果正在运行的线程数量小于 corePoolSize，那么线程池会创建一个新的线程来执行这个任务；
如果正在运行的线程数量大于或等于 corePoolSize，那么线程池会将这个任务放入等待队列；
如果等待队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么线程池会创建新的线程来执行这个任务；
如果等待队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会执行拒绝策略。
<img decoding="async" loading="lazy" alt="线程池执行流程" src="/doc/assets/images/线程池执行流程-032bb1a523d0c5b400801c0260fe4924.png" width="715" height="466" class="img_ev3q">
第三步，线程执行完毕后，线程并不会立即销毁，而是继续保持在池中等待下一个任务。
第四步，当线程空闲时间超出指定时间，且当前线程数量大于核心线程数时，线程会被回收。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="56线程池的主要参数有哪些">🌟56.线程池的主要参数有哪些？<a href="#56线程池的主要参数有哪些" class="hash-link" aria-label="Direct link to 🌟56.线程池的主要参数有哪些？" title="Direct link to 🌟56.线程池的主要参数有哪些？">​</a></h3>
<p>线程池有 7 个参数，需要重点关注的有核心线程数、最大线程数、等待队列、拒绝策略。
<img decoding="async" loading="lazy" alt="线程池参数" src="/doc/assets/images/线程池参数-d81bffdae099c3cdf0bcd2b4d10f1eca.png" width="782" height="613" class="img_ev3q"></p>
<ol>
<li>corePoolSize：核心线程数，长期存活，执行任务的主力。</li>
<li>maximumPoolSize：线程池允许的最大线程数。</li>
<li>workQueue：任务队列，存储等待执行的任务。</li>
<li>handler：拒绝策略，任务超载时的处理方式。也就是线程数达到 maximumPoolSiz，任务队列也满了的时候，就会触发拒绝策略。</li>
<li>threadFactory：线程工厂，用于创建线程，可自定义线程名。</li>
<li>keepAliveTime：非核心线程的存活时间，空闲时间超过该值就销毁。</li>
<li>unit：keepAliveTime 参数的时间单位：
TimeUnit.DAYS; 天
TimeUnit.HOURS; 小时
TimeUnit.MINUTES; 分钟
TimeUnit.SECONDS; 秒
TimeUnit.MILLISECONDS; 毫秒
TimeUnit.MICROSECONDS; 微秒
TimeUnit.NANOSECONDS; 纳秒</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="能简单说一下参数之间的关系吗">能简单说一下参数之间的关系吗？<a href="#能简单说一下参数之间的关系吗" class="hash-link" aria-label="Direct link to 能简单说一下参数之间的关系吗？" title="Direct link to 能简单说一下参数之间的关系吗？">​</a></h3>
<p>一句话：任务优先使用核心线程执行，满了进入等待队列，队列满了启用非核心线程备用，线程池达到最大线程数量后触发拒绝策略，非核心线程的空闲时间超过存活时间就被回收。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="核心线程数不够会怎么进行处理">核心线程数不够会怎么进行处理？<a href="#核心线程数不够会怎么进行处理" class="hash-link" aria-label="Direct link to 核心线程数不够会怎么进行处理？" title="Direct link to 核心线程数不够会怎么进行处理？">​</a></h3>
<p>当提交的任务数超过了 corePoolSize，但是小于 maximumPoolSize 时，线程池会创建新的线程来处理任务。
当提交的任务数超过了 maximumPoolSize 时，线程池会根据拒绝策略来处理任务。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="举个例子说一下这些参数的变化">举个例子说一下这些参数的变化？<a href="#举个例子说一下这些参数的变化" class="hash-link" aria-label="Direct link to 举个例子说一下这些参数的变化？" title="Direct link to 举个例子说一下这些参数的变化？">​</a></h3>
<p>假设一个场景，线程池的配置如下：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">corePoolSize =5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">maximumPoolSize =10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">keepAliveTime =60</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">秒</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">workQueue = LinkedBlockingQueue（容量为100）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">handler =ThreadPoolExecutor.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">AbortPolicy()</span><br></span></code></pre></div></div>
<p>场景一：当系统启动后，有 10 个任务提交到线程池。
前 5 个任务会立即执行，因为核心线程数足够容纳它们。
随后的 5 个任务会被放入等待队列。</p>
<p>场景二：如果此时再有 100 个任务提交到线程池。
工作队列已满，线程池会创建额外的线程来执行这些任务，直到线程总数达到 10。
如果任务继续增加，超过了工作队列+最大线程数的限制，新来的任务会被 AbortPolicy 拒绝，抛出 RejectedExecutionException 异常。</p>
<p>场景三：如果任务突然减少：
核心线程会一直运行，而超出核心线程数的线程，会在 60 秒后回收。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="线程池的拒绝策略有哪些">🌟线程池的拒绝策略有哪些？<a href="#线程池的拒绝策略有哪些" class="hash-link" aria-label="Direct link to 🌟线程池的拒绝策略有哪些？" title="Direct link to 🌟线程池的拒绝策略有哪些？">​</a></h3>
<p>有四种：
AbortPolicy：默认的拒绝策略，会抛 RejectedExecutionException 异常。
CallerRunsPolicy：让提交任务的线程自己来执行这个任务，也就是调用 execute 方法的线程。
DiscardOldestPolicy：等待队列会丢弃队列中最老的一个任务，也就是队列中等待最久的任务，然后尝试重新提交被拒绝的任务。
DiscardPolicy：丢弃被拒绝的任务，不做任何处理也不抛出异常。
<img decoding="async" loading="lazy" alt="1757508211789" src="/doc/assets/images/1757508211789-c68ec93ddf035de1f1319f52f9f0a216.png" width="649" height="600" class="img_ev3q">
分别对应着小二去银行办理业务被经理“薄纱”的四个场景：“我们系统瘫痪了”、“谁叫你来办的你找谁去”、“看你比较急，去队里加个塞”、“今天没办法，不行你看改一天”。</p>
<p>当线程池无法接受新的任务时，也就是线程数达到 maximumPoolSize，任务队列也满了的时候，就会触发拒绝策略。</p>
<p>如果默认策略不能满足需求，可以通过实现 RejectedExecutionHandler 接口来定义自己的淘汰策略。例如：记录被拒绝任务的日志。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class CustomRejectedHandler {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 自定义拒绝策略</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        RejectedExecutionHandler rejectedHandler = (r, executor) -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;Task &quot; + r.toString() + &quot; rejected. Queue size: &quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    + executor.getQueue().size());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 自定义线程池</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ThreadPoolExecutor executor = new ThreadPoolExecutor(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                2,                      // 核心线程数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                4,                      // 最大线程数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                10,                     // 空闲线程存活时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                TimeUnit.SECONDS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new ArrayBlockingQueue&lt;&gt;(2),  // 阻塞队列容量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Executors.defaultThreadFactory(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                rejectedHandler          // 自定义拒绝策略</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; 10; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            final int taskNumber = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            executor.execute(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;Executing task &quot; + taskNumber);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Thread.sleep(1000); // 模拟任务耗时</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        executor.shutdown();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="线程池有哪几种阻塞队列">线程池有哪几种阻塞队列？<a href="#线程池有哪几种阻塞队列" class="hash-link" aria-label="Direct link to 线程池有哪几种阻塞队列？" title="Direct link to 线程池有哪几种阻塞队列？">​</a></h3>
<p>常用的有五种，有界队列 ArrayBlockingQueue；无界队列 LinkedBlockingQueue；优先级队列 PriorityBlockingQueue；延迟队列
DelayQueue；同步队列 SynchronousQueue。
<img decoding="async" loading="lazy" alt="1757508244127" src="/doc/assets/images/1757508244127-34f50b57f14324aa041b934ef8f765f9.png" width="986" height="474" class="img_ev3q">
①、ArrayBlockingQueue：一个有界的先进先出的阻塞队列，底层是一个数组，适合固定大小的线程池。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ArrayBlockingQueue&lt;Integer&gt; blockingQueue = new ArrayBlockingQueue&lt;Integer&gt;(10, true);</span><br></span></code></pre></div></div>
<p>②、LinkedBlockingQueue：底层是链表，如果不指定大小，默认大小是 Integer.MAX_VALUE，几乎相当于一个无界队列。
技术派实战项目中，就使用了 LinkedBlockingQueue 来配置 RabbitMQ 的消息队列。
③、PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。任务按照其自然顺序或 Comparator 来排序。</p>
<p>适用于需要按照给定优先级处理任务的场景，比如优先处理紧急任务。</p>
<p>④、DelayQueue：类似于 PriorityBlockingQueue，由二叉堆实现的无界优先级阻塞队列。</p>
<p>Executors 中的 newScheduledThreadPool() 就使用了 DelayQueue 来实现延迟执行。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public ScheduledThreadPoolExecutor(int corePoolSize) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new DelayedWorkQueue());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>⑤、SynchronousQueue：每个插入操作必须等待另一个线程的移除操作，同样，任何一个移除操作都必须等待另一个线程的插入操作。</p>
<p>Executors.newCachedThreadPool() 就使用了 SynchronousQueue，这个线程池会根据需要创建新线程，如果有空闲线程则会重复使用，线程空闲
60 秒后会被回收。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public static ExecutorService newCachedThreadPool() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            60L, TimeUnit.SECONDS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new SynchronousQueue&lt;Runnable&gt;());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}   </span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="线程池提交-execute-和-submit-有什么区别">线程池提交 execute 和 submit 有什么区别？<a href="#线程池提交-execute-和-submit-有什么区别" class="hash-link" aria-label="Direct link to 线程池提交 execute 和 submit 有什么区别？" title="Direct link to 线程池提交 execute 和 submit 有什么区别？">​</a></h3>
<p>execute 方法没有返回值，适用于不关心结果和异常的简单任务。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">threadsPool.execute(new Runnable() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override public void run () {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;execute() 方法提交的任务&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">});</span><br></span></code></pre></div></div>
<p>submit 有返回值，适用于需要获取结果或处理异常的场景。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Future&lt;Object&gt; future = executor.submit(harReturnValuetask);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">try{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Object s = future.get(); }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        catch(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">InterruptedException e |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ExecutionException e){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 处理无法执行任务异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }finally{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 关闭线程池 executor.shutdown();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="线程池怎么关闭知道吗">线程池怎么关闭知道吗？<a href="#线程池怎么关闭知道吗" class="hash-link" aria-label="Direct link to 线程池怎么关闭知道吗？" title="Direct link to 线程池怎么关闭知道吗？">​</a></h3>
<p>可以调用线程池的shutdown或shutdownNow方法来关闭线程池。</p>
<p>shutdown 不会立即停止线程池，而是等待所有任务执行完毕后再关闭线程池。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ExecutorService executor = Executors.newFixedThreadPool(3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">executor.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">execute(() -&gt;System.out.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println(&quot;Task 1&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        executor.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">execute(() -&gt;System.out.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println(&quot;Task 2&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        executor.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">shutdown(); // 不会立刻关闭，而是等待所有任务执行完毕</span><br></span></code></pre></div></div>
<p>shutdownNow 会尝试通过一系列动作来停止线程池，包括停止接收外部提交的任务、忽略队列里等待的任务、尝试将正在跑的任务
interrupt 中断。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ExecutorService executor = Executors.newFixedThreadPool(3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">executor.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">execute(() -&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sleep(5000); // 模拟长时间运行任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println(&quot;Task executed&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }catch(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">InterruptedException e){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println(&quot;任务被中断&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;Runnable&gt; unexecutedTasks = executor.shutdownNow(); // 立即关闭线程池</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println(&quot;未执行的任务数: &quot;+unexecutedTasks.size());</span><br></span></code></pre></div></div>
<p>需要注意的是，shutdownNow 不会真正终止正在运行的任务，只是给任务线程发送 interrupt 信号，任务是否能真正终止取决于线程是否响应
InterruptedException。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="线程池的线程数应该怎么配置">线程池的线程数应该怎么配置？<a href="#线程池的线程数应该怎么配置" class="hash-link" aria-label="Direct link to 线程池的线程数应该怎么配置？" title="Direct link to 线程池的线程数应该怎么配置？">​</a></h3>
<p>首先，我会分析线程池中执行的任务类型是 CPU 密集型还是 IO 密集型？</p>
<p>①、对于 CPU 密集型任务，我的目标是尽量减少线程上下文切换，以优化 CPU 使用率。一般来说，核心线程数设置为处理器的核心数或核心数加一是较理想的选择。</p>
<p>+1 是为了以备不时之需，如果某线程因等待系统资源而阻塞时，可以有多余的线程顶上去，不至于影响整体性能。</p>
<p>②、对于 IO 密集型任务，由于线程经常处于等待状态，等待 IO 操作完成，所以可以设置更多的线程来提高并发，比如说 CPU 核心数的两倍。
最后，我会根据业务需求和系统资源来调整线程池的其他参数，比如最大线程数、任务队列容量、非核心线程的空闲存活时间等。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ThreadPoolExecutor executor = new ThreadPoolExecutor(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cores, // 核心线程数设置为CPU核心数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cores * 2, // 最大线程数为核心数的两倍</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        60L, TimeUnit.SECONDS, // 非核心线程的空闲存活时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new LinkedBlockingQueue&lt;&gt;(100) // 任务队列容量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">);</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何知道你设置的线程数多了还是少了">如何知道你设置的线程数多了还是少了？<a href="#如何知道你设置的线程数多了还是少了" class="hash-link" aria-label="Direct link to 如何知道你设置的线程数多了还是少了？" title="Direct link to 如何知道你设置的线程数多了还是少了？">​</a></h3>
<p>可以通过监控和调试来判断线程数是多还是少。</p>
<p>比如说通过 top 命令观察 CPU 的使用率，如果 CPU 使用率较低，可能是线程数过少；如果 CPU 使用率接近 100%，但吞吐量未提升，可能是线程数过多。</p>
<p>然后再通过 VisualVM 或 Arthas 分析线程运行情况，查看线程的状态、等待时间、运行时间等信息。</p>
<p>也可以使用 jstack 命令查看线程堆栈信息，查看线程是否处于阻塞状态。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">jstack&lt;Java 进程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ID&gt;|grep -A 20&quot;BLOCKED&quot; // 查看阻塞线程</span><br></span></code></pre></div></div>
<p>如果有大量的 BLOCKED 线程，说明线程数可能过多，竞争比较激烈。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="有哪几种常见的线程池">有哪几种常见的线程池？<a href="#有哪几种常见的线程池" class="hash-link" aria-label="Direct link to 有哪几种常见的线程池？" title="Direct link to 有哪几种常见的线程池？">​</a></h3>
<p>主要有四种：</p>
<p>固定大小的线程池 Executors.newFixedThreadPool(int nThreads);，适合用于任务数量确定，且对线程数有明确要求的场景。例如，IO
密集型任务、数据库连接池等。</p>
<p>缓存线程池 Executors.newCachedThreadPool();，适用于短时间内任务量波动较大的场景。例如，短时间内有大量的文件处理任务或网络请求。</p>
<p>定时任务线程池 Executors.newScheduledThreadPool(int corePoolSize);，适用于需要定时执行任务的场景。例如，定时发送邮件、定时备份数据等。</p>
<p>单线程线程池 Executors.newSingleThreadExecutor();，适用于需要按顺序执行任务的场景。例如，日志记录、文件处理等。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="能说一下四种常见线程池的原理吗">能说一下四种常见线程池的原理吗？<a href="#能说一下四种常见线程池的原理吗" class="hash-link" aria-label="Direct link to 能说一下四种常见线程池的原理吗？" title="Direct link to 能说一下四种常见线程池的原理吗？">​</a></h3>
<p>不管是 FixedThreadPool、CachedThreadPool，还是 SingleThreadExecutor 和 ScheduledThreadPoolExecutor，它们本质上都是
ThreadPoolExecutor 的不同配置。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说固定大小线程池的原理">说说固定大小线程池的原理？<a href="#说说固定大小线程池的原理" class="hash-link" aria-label="Direct link to 说说固定大小线程池的原理？" title="Direct link to 说说固定大小线程池的原理？">​</a></h3>
<p>线程池大小是固定的，corePoolSize == maximumPoolSize，默认使用 LinkedBlockingQueue 作为阻塞队列，适用于任务量稳定的场景，如数据库连接池、RPC
处理等。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">new ThreadPoolExecutor(4,4,0L,TimeUnit.MILLISECONDS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       new LinkedBlockingQueue&lt;&gt;());</span><br></span></code></pre></div></div>
<p>新任务提交时，如果线程池有空闲线程，直接执行；如果没有，任务进入 LinkedBlockingQueue 等待。缺点是任务队列默认无界，可能导致任务堆积，甚至
OOM。
<img decoding="async" loading="lazy" alt="1757508709796" src="/doc/assets/images/1757508709796-7388288c92f001818f99309c3525544c.png" width="991" height="524" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说缓存线程池的原理">说说缓存线程池的原理？<a href="#说说缓存线程池的原理" class="hash-link" aria-label="Direct link to 说说缓存线程池的原理？" title="Direct link to 说说缓存线程池的原理？">​</a></h3>
<p>线程池大小不固定，corePoolSize = 0，maximumPoolSize = Integer.MAX_VALUE。空闲线程超过 60 秒会被销毁，使用 SynchronousQueue
作为阻塞队列，适用于短时间内有大量任务的场景。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">new ThreadPoolExecutor(0,Integer.MAX_VALUE, 60L,TimeUnit.SECONDS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       new SynchronousQueue&lt;&gt;());</span><br></span></code></pre></div></div>
<p>提交任务时，如果线程池没有空闲线程，直接新建线程执行任务；如果有，复用线程执行任务。线程空闲 60
秒后销毁，减少资源占用。缺点是线程数没有上限，在高并发情况下可能导致 OOM。</p>
<p><img decoding="async" loading="lazy" alt="1757508753691" src="/doc/assets/images/1757508753691-a47811b9878adec1f4a53dd02c183870.png" width="921" height="687" class="img_ev3q">
线程池只有 1 个线程，保证任务按提交顺序执行，使用 LinkedBlockingQueue 作为阻塞队列，适用于需要按顺序执行任务的场景。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">new ThreadPoolExecutor(1,1,0L,TimeUnit.MILLISECONDS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       new LinkedBlockingQueue&lt;&gt;());</span><br></span></code></pre></div></div>
<p>始终只创建 1 个线程，新任务必须等待前一个任务完成后才能执行，其他任务都被放入 LinkedBlockingQueue 排队执行。缺点是无法并行处理任务。</p>
<p><img decoding="async" loading="lazy" alt="1757508789454" src="/doc/assets/images/1757508789454-b43c6a929b23b58864dde4486b04bfa1.png" width="916" height="430" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说定时任务线程池的原理">说说定时任务线程池的原理？<a href="#说说定时任务线程池的原理" class="hash-link" aria-label="Direct link to 说说定时任务线程池的原理？" title="Direct link to 说说定时任务线程池的原理？">​</a></h3>
<p>定时任务线程池的大小可配置，支持定时 &amp; 周期性任务执行，使用 DelayedWorkQueue 作为阻塞队列，适用于周期性执行任务的场景。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public ScheduledThreadPoolExecutor(int corePoolSize) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new DelayedWorkQueue());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>执行定时任务时，schedule() 方法可以将任务延迟一定时间后执行一次；scheduleAtFixedRate()
方法可以将任务延迟一定时间后以固定频率执行；scheduleWithFixedDelay() 方法可以将任务延迟一定时间后以固定延迟执行。
<img decoding="async" loading="lazy" alt="1757508821932" src="/doc/assets/images/1757508821932-f6bd6cff84557a2b3f47733b36037afb.png" width="984" height="535" class="img_ev3q">
缺点是，如果任务执行时间 &gt; 设定时间间隔，scheduleAtFixedRate 可能会导致任务堆积。</p>
<p><img decoding="async" loading="lazy" alt="1757508903269" src="/doc/assets/images/1757508903269-1819a226d59956ab088e05a5042396ac.png" width="926" height="488" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="使用无界队列的线程池会出现什么问题">使用无界队列的线程池会出现什么问题？<a href="#使用无界队列的线程池会出现什么问题" class="hash-link" aria-label="Direct link to 使用无界队列的线程池会出现什么问题？" title="Direct link to 使用无界队列的线程池会出现什么问题？">​</a></h3>
<p>如果线程获取一个任务后，任务的执行时间比较长，会导致队列的任务越积越多，导致内存使用不断飙升，最终出现 OOM</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="线程池异常怎么处理知道吗">线程池异常怎么处理知道吗？<a href="#线程池异常怎么处理知道吗" class="hash-link" aria-label="Direct link to 线程池异常怎么处理知道吗？" title="Direct link to 线程池异常怎么处理知道吗？">​</a></h3>
<p>常见的处理方式有，使用 try-catch 捕获、使用 Future 获取异常、自定义ThreadPoolExecutor 重写 afterExecute 方法、使用
UncaughtExceptionHandler 捕获异常。</p>
<p><img decoding="async" loading="lazy" alt="1757508933258" src="/doc/assets/images/1757508933258-d4028aea6836367b1750b549a131cc6d.png" width="711" height="502" class="img_ev3q"></p>
<p>①、try-catch 是最简单的方法。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">executor.execute(() -&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println(&quot;任务开始&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int result = 1 / 0; // 除零异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }catch(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Exception e){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.err.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println(&quot;捕获异常：&quot;+e.getMessage());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span></code></pre></div></div>
<p>②、使用 Future 获取异常。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Future&lt;Object&gt; future = executor.submit(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(&quot;任务开始&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int result = 1 / 0; // 除零异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">try{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        future.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}catch(InterruptedException |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ExecutionException e){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.err.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println(&quot;捕获异常：&quot;+e.getMessage());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span></code></pre></div></div>
<p>③、自定义 ThreadPoolExecutor 重写 afterExecute 方法。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ThreadPoolExecutor executor = new ThreadPoolExecutor(2, 2, 0L, TimeUnit.MILLISECONDS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new LinkedBlockingQueue&lt;Runnable&gt;()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected void afterExecute(Runnable r, Throwable t) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super.afterExecute(r, t);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (t != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.err.println(&quot;捕获异常：&quot; + t.getMessage());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">executor.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">execute(() -&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println(&quot;任务开始&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int result = 1 / 0; // 除零异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">});</span><br></span></code></pre></div></div>
<p>④、使用 UncaughtExceptionHandler 捕获异常。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ThreadPoolExecutor executor = new ThreadPoolExecutor(2, 2, 0L, TimeUnit.MILLISECONDS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new LinkedBlockingQueue&lt;Runnable&gt;());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">executor.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        executor.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">setThreadFactory(new ThreadFactory() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Thread newThread (Runnable r){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread thread = new Thread(r);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thread.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void uncaughtException(Thread t, Throwable e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.err.println(&quot;捕获异常：&quot; + e.getMessage());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return thread;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        executor.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">execute(() -&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println(&quot;任务开始&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int result = 1 / 0; // 除零异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">});</span><br></span></code></pre></div></div>
<p>如果项目使用 execute()，不关心任务返回值，建议使用 UncaughtExceptionHandler：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">thread.setUncaughtExceptionHandler((t, e) -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.err.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println(&quot;线程 &quot;+t.getName() +&quot; 捕获到异常：&quot;+e.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">getMessage()));</span><br></span></code></pre></div></div>
<p>如果项目使用 submit()，关心任务返回值，建议使用 Future：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Future&lt;?&gt; future = executor.submit(task);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">try{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        future.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}catch(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ExecutionException e){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.err.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">println(&quot;捕获异常：&quot;+e.getCause());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span></code></pre></div></div>
<p>如果想要全局捕获所有任务异常，建议重写 afterExecute 方法：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class MyThreadPoolExecutor extends ThreadPoolExecutor {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected void afterExecute(Runnable r, Throwable t) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (t == null &amp;&amp; r instanceof Future&lt;?&gt;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ((Future&lt;?&gt;) r).get();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.err.println(&quot;任务异常：&quot; + e.getCause());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="能说一下线程池有几种状态吗">能说一下线程池有几种状态吗？<a href="#能说一下线程池有几种状态吗" class="hash-link" aria-label="Direct link to 能说一下线程池有几种状态吗？" title="Direct link to 能说一下线程池有几种状态吗？">​</a></h3>
<p>有 5 种状态，它们的转换遵循严格的状态流转规则，不同状态控制着线程池的任务调度和关闭行为。</p>
<p>状态由 RUNNING → SHUTDOWN → STOP → TIDYING → TERMINATED 依次流转。
<img decoding="async" loading="lazy" alt="1757509064237" src="/doc/assets/images/1757509064237-999235f73a5043712550b2dfc88a8887.png" width="871" height="254" class="img_ev3q">
RUNNING 状态的线程池可以接收新任务，并处理阻塞队列中的任务；SHUTDOWN 状态的线程池不会接收新任务，但会处理阻塞队列中的任务；STOP
状态的线程池不会接收新任务，也不会处理阻塞队列中的任务，并且会尝试中断正在执行的任务；TIDYING 状态表示所有任务已经终止；TERMINATED
状态表示线程池完全关闭，所有线程销毁。</p>
<p>状态 状态码 是否接收新任务 是否执行队列中的任务 是否中断正在执行的任务
RUNNING 111 ✅ 是 ✅ 是 ❌ 否
SHUTDOWN 000 ❌ 否 ✅ 是 ❌ 否
STOP 001 ❌ 否 ❌ 否 ✅ 是
TIDYING 010 ❌ 否 ❌ 否 ❌ 否
TERMINATED 011 ❌ 否 ❌ 否 ❌ 否</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="线程池如何实现参数的动态修改">线程池如何实现参数的动态修改？<a href="#线程池如何实现参数的动态修改" class="hash-link" aria-label="Direct link to 线程池如何实现参数的动态修改？" title="Direct link to 线程池如何实现参数的动态修改？">​</a></h3>
<p>线程池提供的 setter 方法就可以在运行时动态修改参数，比如说 setCorePoolSize 可以用来修改核心线程数、setMaximumPoolSize
可以用来修改最大线程数。</p>
<p>需要注意的是，调用 setCorePoolSize() 时如果新的核心线程数比原来的大，线程池会创建新的线程；如果更小，线程池不会立即销毁多余的线程，除非有空闲线程超过
keepAliveTime。</p>
<p>当然了，还可以利用 Nacos 配置中心，或者实现自定义的线程池，监听参数变化去动态调整参数。</p>
<p><img decoding="async" loading="lazy" alt="1757509103277" src="/doc/assets/images/1757509103277-beca0db2bb21e1f20f6bbe314de83df7.png" width="931" height="510" class="img_ev3q">
首先我会根据任务类型设置核心线程数参数，比如 IO 密集型任务会设置为 CPU 核心数*2 的经验值。</p>
<p>其次我会结合线程池动态调整的能力，在流量波动时通过 setCorePoolSize 平滑扩容，或者直接使用 DynamicTp 实现线程池参数的自动化调整。</p>
<p>最后，我会通过内置的监控指标建立容量预警机制。比如通过 JMX 监控线程池的运行状态，设置阈值，当线程池的任务队列长度超过阈值时，触发告警。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="线程池在使用的时候需要注意什么补充">线程池在使用的时候需要注意什么？（补充）<a href="#线程池在使用的时候需要注意什么补充" class="hash-link" aria-label="Direct link to 线程池在使用的时候需要注意什么？（补充）" title="Direct link to 线程池在使用的时候需要注意什么？（补充）">​</a></h3>
<p>我认为有 3 个比较重要的关注点：</p>
<p>第一个，选择合适的线程池大小。过小的线程池可能会导致任务一直在排队；过大的线程池可能会导致大家都在竞争 CPU 资源，增加上下文切换的开销</p>
<p>第二个，选择合适的任务队列。使用有界队列可以避免资源耗尽的风险，但是可能会导致任务被拒绝；使用无界队列虽然可以避免任务被拒绝，但是可能会导致内存耗尽</p>
<p>比如在使用 LinkedBlockingQueue 的时候，可以传入参数来限制队列中任务的数量，这样就不会出现 OOM。</p>
<p>第三个，尽量使用自定义的线程池，而不是使用 Executors 创建的线程池。</p>
<p>因为 newFixedThreadPool 线程池由于使用了 LinkedBlockingQueue，队列的容量默认无限大，任务过多时会导致内存溢出；newCachedThreadPool
线程池由于核心线程数无限大，当任务过多的时候会导致创建大量的线程，导致服务器负载过高宕机。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="你能设计实现一个线程池吗">🌟你能设计实现一个线程池吗？<a href="#你能设计实现一个线程池吗" class="hash-link" aria-label="Direct link to 🌟你能设计实现一个线程池吗？" title="Direct link to 🌟你能设计实现一个线程池吗？">​</a></h3>
<p>推荐阅读：三分恶线程池原理
线程池的主要目的是为了避免频繁地创建和销毁线程。
<img decoding="async" loading="lazy" alt="1757509169258" src="/doc/assets/images/1757509169258-7ed1b77b4168a1ea43270ce899fc8c8a.png" width="802" height="374" class="img_ev3q">
我会把线程池看作一个工厂，里面有一群“工人”，也就是线程了，专门用来做任务。</p>
<p>当任务来了，需要先判断有没有空闲的工人，如果有就把任务交给他们；如果没有，就把任务暂存到一个任务队列里，等工人忙完了再去处理。</p>
<p>如果队列满了，还没有空闲的工人，就要考虑扩容，让预备的工人过来干活，但不能超过预定的最大值，防止工厂被挤爆。</p>
<p>如果连扩容也没法解决，就需要一个拒绝策略，可能直接拒绝任务或者报个错。</p>
<p>核心线程池类（可参考）：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class CustomThreadPoolExecutor {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final int corePoolSize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final int maximumPoolSize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final long keepAliveTime;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final TimeUnit unit;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final BlockingQueue&lt;Runnable&gt; workQueue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final RejectedExecutionHandler handler;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private volatile boolean isShutdown = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int currentPoolSize = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 构造方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public CustomThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.corePoolSize = corePoolSize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.maximumPoolSize = maximumPoolSize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.keepAliveTime = keepAliveTime;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.unit = unit;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.workQueue = workQueue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.handler = handler;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 提交任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void execute(Runnable task) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (isShutdown) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new IllegalStateException(&quot;ThreadPool is shutdown&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        synchronized (this) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 如果当前线程数小于核心线程数，直接创建新线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (currentPoolSize &lt; corePoolSize) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new Worker(task).start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                currentPoolSize++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 尝试将任务添加到队列中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!workQueue.offer(task)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (currentPoolSize &lt; maximumPoolSize) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    new Worker(task).start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    currentPoolSize++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 调用拒绝策略</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    handler.rejectedExecution(task, null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 关闭线程池</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void shutdown() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        isShutdown = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 工作线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private class Worker extends Thread {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private Runnable task;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Worker(Runnable task) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.task = task;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (task != null || (task = getTask()) != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    task.run();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    task = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 从队列中获取任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private Runnable getTask() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return workQueue.poll(keepAliveTime, unit);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>拒绝策略：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 拒绝策略</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class CustomRejectedExecutionHandler {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // AbortPolicy 抛出异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static class AbortPolicy implements RejectedExecutionHandler {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new RuntimeException(&quot;Task &quot; + r.toString() + &quot; rejected from &quot; + e.toString());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // DiscardPolicy 什么都不做</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static class DiscardPolicy implements RejectedExecutionHandler {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Do nothing</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // DiscardOldestPolicy 丢弃队列中最旧的任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static class CallerRunsPolicy implements RejectedExecutionHandler {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!e.isShutdown()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                r.run();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>使用示例：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class ThreadPoolTest {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建线程池</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        CustomThreadPoolExecutor executor = new CustomThreadPoolExecutor(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                2, 4, 10, TimeUnit.SECONDS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new LinkedBlockingQueue&lt;&gt;(2),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new CustomRejectedExecutionHandler.AbortPolicy());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 提交任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; 10; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            final int index = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            executor.execute(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                System.out.println(&quot;Task &quot; + index + &quot; is running&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Thread.sleep(2000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 关闭线程池</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        executor.shutdown();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="手写一个数据库连接池可以吗">手写一个数据库连接池，可以吗？<a href="#手写一个数据库连接池可以吗" class="hash-link" aria-label="Direct link to 手写一个数据库连接池，可以吗？" title="Direct link to 手写一个数据库连接池，可以吗？">​</a></h3>
<p>可以的，我的思路是这样的：数据库连接池主要是为了避免每次操作数据库时都去创建连接，因为那样很浪费资源。所以我打算在初始化时预先创建好固定数量的连接，然后把它们放到一个线程安全的容器里，后续有请求的时候就从队列里拿，使用完后再归还到队列中。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class SimpleConnectionPool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 配置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String jdbcUrl;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String username;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String password;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int maxConnections;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private BlockingQueue&lt;Connection&gt; connectionPool;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 构造方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public SimpleConnectionPool(String jdbcUrl, String username, String password, int maxConnections) throws SQLException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.jdbcUrl = jdbcUrl;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.username = username;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.password = password;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.maxConnections = maxConnections;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.connectionPool = new LinkedBlockingQueue&lt;&gt;(maxConnections);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 初始化连接池</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; maxConnections; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            connectionPool.add(createNewConnection());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 创建新连接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Connection createNewConnection() throws SQLException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return DriverManager.getConnection(jdbcUrl, username, password);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 获取连接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Connection getConnection(long timeout, TimeUnit unit) throws InterruptedException, SQLException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Connection connection = connectionPool.poll(timeout, unit); // 等待指定时间获取连接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (connection == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new SQLException(&quot;Timeout: Unable to acquire a connection.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return connection;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 归还连接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void releaseConnection(Connection connection) throws SQLException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (connection != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (connection.isClosed()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 如果连接已关闭，创建一个新连接补充到池中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                connectionPool.add(createNewConnection());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 将连接归还到池中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                connectionPool.offer(connection);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 关闭所有连接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void closeAllConnections() throws SQLException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (Connection connection : connectionPool) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!connection.isClosed()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                connection.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 测试用例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            SimpleConnectionPool pool = new SimpleConnectionPool(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    &quot;jdbc:mysql://localhost:3306/pai_coding&quot;, &quot;root&quot;, &quot;&quot;, 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 获取连接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Connection conn = pool.getConnection(5, TimeUnit.SECONDS);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 使用连接（示例查询）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;Connection acquired: &quot; + conn);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Thread.sleep(2000); // 模拟查询</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 归还连接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pool.releaseConnection(conn);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;Connection returned.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 关闭所有连接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pool.closeAllConnections();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="线程池执行中断电了应该怎么处理">线程池执行中断电了应该怎么处理？<a href="#线程池执行中断电了应该怎么处理" class="hash-link" aria-label="Direct link to 线程池执行中断电了应该怎么处理？" title="Direct link to 线程池执行中断电了应该怎么处理？">​</a></h3>
<p>线程池本身只能在内存中进行任务调度，并不会持久化，一旦断电，线程池里的所有任务和状态都会丢失。</p>
<p>我会考虑以下几个方面：</p>
<p>第一，持久化任务。可以将任务持久化到数据库或者消息队列中，等电恢复后再重新执行。</p>
<p>第二，任务幂等性，需要保证任务是幂等的，也就是无论执行多少次，结果都一致。</p>
<p>第三，恢复策略。当系统重启时，应该有一个恢复流程：检测上次是否有未完成的任务，将这些任务重新加载到线程池中执行，确保断电前的工作能够恢复。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="并发容器和框架">并发容器和框架<a href="#并发容器和框架" class="hash-link" aria-label="Direct link to 并发容器和框架" title="Direct link to 并发容器和框架">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="forkjoin-框架了解吗">Fork/Join 框架了解吗？<a href="#forkjoin-框架了解吗" class="hash-link" aria-label="Direct link to Fork/Join 框架了解吗？" title="Direct link to Fork/Join 框架了解吗？">​</a></h3>
<p>关于 Fork/Join 框架，我了解一些，它是 Java 7 引入的一个并行框架，主要用于分治算法的并行执行。这个框架通过将大的任务递归地分解成小任务，然后并行执行，最后再合并结果，以达到最高效率处理大量数据的目的。
<img decoding="async" loading="lazy" alt="1757509270782" src="/doc/assets/images/1757509270782-2dd1319072ae7d0020960edd844cbdc5.png" width="923" height="764" class="img_ev3q">
Fork/Join 框架的核心理念是分而治之，将大任务拆分为多个小任务并行处理，最后再将这些小任务的结果汇总。</p>
<p>就像是一个树形结构，根节点是一个大的任务，叶子节点是最小的子任务，每个任务都可能会被分裂成更小的子任务，直到达到某个临界点，任务再逐个执行。</p>
<p>具体来说，Fork/Join 包括两个主要的类：</p>
<p>ForkJoinPool，一个特殊的线程池，底层使用了工作窃取算法，也就是当一个线程执行完自己的任务后，它可以窃取其他线程的任务，避免线程闲置。
<img decoding="async" loading="lazy" alt="1757509287711" src="/doc/assets/images/1757509287711-548efc6b77257517b1a924c37e36169b.png" width="753" height="386" class="img_ev3q">
RecursiveTask 和 RecursiveAction，分别用于有返回值和无返回值的任务，这两个类都继承自 ForkJoinTask。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class ForkJoinExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[] arr = new int[100];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; 100; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            arr[i] = i + 1; // 填充数据 1 到 100</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建 ForkJoinPool，默认使用可用的处理器核心数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ForkJoinPool pool = new ForkJoinPool();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建 ForkJoin 任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SumTask task = new SumTask(arr, 0, arr.length);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 执行任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Integer result = pool.invoke(task);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;数组的和是: &quot; + result);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 自定义任务，继承 RecursiveTask</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static class SumTask extends RecursiveTask&lt;Integer&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private int[] arr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private int start;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private int end;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public SumTask(int[] arr, int start, int end) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.arr = arr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.start = start;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.end = end;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        protected Integer compute() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (end - start &lt;= 10) {  // 如果任务足够小，就直接计算</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int sum = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (int i = start; i &lt; end; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    sum += arr[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return sum;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 否则拆分任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int mid = (start + end) / 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                SumTask left = new SumTask(arr, start, mid);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                SumTask right = new SumTask(arr, mid, end);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 分别执行子任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                left.fork();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                right.fork();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 合并结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int leftResult = left.join();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                int rightResult = right.join();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return leftResult + rightResult;  // 汇总结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/java/java_concurrent.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/doc/docs/java/java_collection_review"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">java_collection_review</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/doc/docs/java/java_review"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">java_review</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#基础" class="table-of-contents__link toc-highlight">基础</a><ul><li><a href="#你是如何理解线程安全的" class="table-of-contents__link toc-highlight">你是如何理解线程安全的？</a></li><li><a href="#说说进程和线程的区别" class="table-of-contents__link toc-highlight">🌟说说进程和线程的区别？</a></li><li><a href="#如何理解协程" class="table-of-contents__link toc-highlight">如何理解协程？</a></li><li><a href="#线程间是如何进行通信的" class="table-of-contents__link toc-highlight">线程间是如何进行通信的？</a></li><li><a href="#说说线程有几种创建方式" class="table-of-contents__link toc-highlight">🌟说说线程有几种创建方式？</a></li><li><a href="#一个-8g-内存的系统最多能创建多少个线程" class="table-of-contents__link toc-highlight">一个 8G 内存的系统最多能创建多少个线程?</a></li><li><a href="#启动一个-java-程序你能说说里面有哪些线程吗" class="table-of-contents__link toc-highlight">启动一个 Java 程序，你能说说里面有哪些线程吗？</a></li><li><a href="#调用-start-方法时会执行-run-方法那怎么不直接调用-run方法" class="table-of-contents__link toc-highlight">🌟调用 start 方法时会执行 run 方法，那怎么不直接调用 run方法？</a></li><li><a href="#线程有哪些常用的调度方法" class="table-of-contents__link toc-highlight">线程有哪些常用的调度方法？</a></li><li><a href="#说说wait方法和notify方法" class="table-of-contents__link toc-highlight">说说wait方法和notify方法？</a></li><li><a href="#说说-sleep-方法" class="table-of-contents__link toc-highlight">说说 sleep 方法？</a></li><li><a href="#说说yield方法" class="table-of-contents__link toc-highlight">说说yield方法？</a></li><li><a href="#说说interrupt方法" class="table-of-contents__link toc-highlight">说说interrupt方法？</a></li><li><a href="#说说-stop-方法" class="table-of-contents__link toc-highlight">说说 stop 方法？</a></li><li><a href="#线程有几种状态" class="table-of-contents__link toc-highlight">🌟线程有几种状态？</a></li><li><a href="#如何强制终止线程" class="table-of-contents__link toc-highlight">如何强制终止线程？</a></li><li><a href="#什么是线程上下文切换" class="table-of-contents__link toc-highlight">什么是线程上下文切换？</a></li><li><a href="#线程可以被多核调度吗" class="table-of-contents__link toc-highlight">线程可以被多核调度吗？</a></li><li><a href="#守护线程了解吗" class="table-of-contents__link toc-highlight">守护线程了解吗？</a></li><li><a href="#守护线程和用户线程有什么区别呢" class="table-of-contents__link toc-highlight">守护线程和用户线程有什么区别呢？</a></li><li><a href="#线程间有哪些通信方式" class="table-of-contents__link toc-highlight">线程间有哪些通信方式？</a></li><li><a href="#简单说说-volatile-和-synchronized-的使用方式" class="table-of-contents__link toc-highlight">简单说说 volatile 和 synchronized 的使用方式？</a></li><li><a href="#wait-和-notify-方法的使用方式了解吗" class="table-of-contents__link toc-highlight">wait() 和 notify() 方法的使用方式了解吗？</a></li><li><a href="#exchanger-的使用方式了解吗" class="table-of-contents__link toc-highlight">Exchanger 的使用方式了解吗？</a></li><li><a href="#completablefuture-的使用方式了解吗" class="table-of-contents__link toc-highlight">CompletableFuture 的使用方式了解吗？</a></li><li><a href="#请说说-sleep-和-wait-的区别补充" class="table-of-contents__link toc-highlight">🌟请说说 sleep 和 wait 的区别？（补充）</a></li><li><a href="#怎么保证线程安全补充" class="table-of-contents__link toc-highlight">🌟怎么保证线程安全？（补充）</a></li><li><a href="#场景有一个-key-对应的-value-是一个json-结构json-当中有好几个子任务这些子任务如果对-key-进行修改的话会不会存在线程安全的问题" class="table-of-contents__link toc-highlight">场景:有一个 key 对应的 value 是一个json 结构，json 当中有好几个子任务，这些子任务如果对 key 进行修改的话，会不会存在线程安全的问题？</a></li><li><a href="#说一个线程安全的使用场景" class="table-of-contents__link toc-highlight">说一个线程安全的使用场景？</a></li><li><a href="#能说一下-hashtable-的底层数据结构吗" class="table-of-contents__link toc-highlight">能说一下 Hashtable 的底层数据结构吗？</a></li></ul></li><li><a href="#threadlocal" class="table-of-contents__link toc-highlight">ThreadLocal</a><ul><li><a href="#threadlocal-是什么" class="table-of-contents__link toc-highlight">🌟ThreadLocal 是什么？</a></li><li><a href="#threadlocal-有哪些优点" class="table-of-contents__link toc-highlight">ThreadLocal 有哪些优点？</a></li><li><a href="#你在工作中用到过-threadlocal-吗" class="table-of-contents__link toc-highlight">你在工作中用到过 ThreadLocal 吗？</a></li><li><a href="#threadlocal-怎么实现的呢" class="table-of-contents__link toc-highlight">🌟ThreadLocal 怎么实现的呢？</a></li><li><a href="#什么是弱引用什么是强引用" class="table-of-contents__link toc-highlight">什么是弱引用，什么是强引用？</a></li><li><a href="#threadlocal-内存泄露是怎么回事" class="table-of-contents__link toc-highlight">🌟ThreadLocal 内存泄露是怎么回事？</a></li><li><a href="#那为什么-key-要设计成弱引用" class="table-of-contents__link toc-highlight">那为什么 key 要设计成弱引用？</a></li><li><a href="#你了解哪些-threadlocal-的改进方案" class="table-of-contents__link toc-highlight">你了解哪些 ThreadLocal 的改进方案？</a></li><li><a href="#threadlocalmap-的源码看过吗" class="table-of-contents__link toc-highlight">ThreadLocalMap 的源码看过吗？</a></li><li><a href="#threadlocalmap-怎么解决-hash-冲突的" class="table-of-contents__link toc-highlight">ThreadLocalMap 怎么解决 Hash 冲突的？</a></li><li><a href="#开放地址法了解吗" class="table-of-contents__link toc-highlight">开放地址法了解吗？</a></li><li><a href="#threadlocalmap-扩容机制了解吗" class="table-of-contents__link toc-highlight">ThreadLocalMap 扩容机制了解吗？</a></li><li><a href="#父线程能用-threadlocal-给子线程传值吗" class="table-of-contents__link toc-highlight">父线程能用 ThreadLocal 给子线程传值吗？</a></li></ul></li><li><a href="#java-内存模型" class="table-of-contents__link toc-highlight">Java 内存模型</a><ul><li><a href="#说一下你对-java-内存模型的理解" class="table-of-contents__link toc-highlight">🌟说一下你对 Java 内存模型的理解？</a></li><li><a href="#为什么线程要用自己的内存" class="table-of-contents__link toc-highlight">为什么线程要用自己的内存？</a></li><li><a href="#i是原子操作吗" class="table-of-contents__link toc-highlight">i++是原子操作吗？</a></li><li><a href="#说说什么是指令重排" class="table-of-contents__link toc-highlight">说说什么是指令重排？</a></li><li><a href="#happens-before-了解吗" class="table-of-contents__link toc-highlight">happens-before 了解吗？</a></li><li><a href="#as-if-serial-了解吗" class="table-of-contents__link toc-highlight">as-if-serial 了解吗？</a></li><li><a href="#volatile-了解吗" class="table-of-contents__link toc-highlight">🌟volatile 了解吗？</a></li><li><a href="#volatile-怎么保证有序性的" class="table-of-contents__link toc-highlight">volatile 怎么保证有序性的？</a></li><li><a href="#volatile-和-synchronized-的区别" class="table-of-contents__link toc-highlight">volatile 和 synchronized 的区别？</a></li><li><a href="#volatile-加在基本类型和对象上的区别" class="table-of-contents__link toc-highlight">volatile 加在基本类型和对象上的区别？</a></li></ul></li><li><a href="#锁" class="table-of-contents__link toc-highlight">锁</a><ul><li><a href="#synchronized-用过吗" class="table-of-contents__link toc-highlight">synchronized 用过吗？</a></li><li><a href="#synchronized-的实现原理了解吗" class="table-of-contents__link toc-highlight">synchronized 的实现原理了解吗？</a></li><li><a href="#你对-monitor-了解多少" class="table-of-contents__link toc-highlight">你对 Monitor 了解多少？</a></li><li><a href="#synchronized-怎么保证可见性" class="table-of-contents__link toc-highlight">synchronized 怎么保证可见性？</a></li><li><a href="#synchronized-怎么保证有序性" class="table-of-contents__link toc-highlight">synchronized 怎么保证有序性？</a></li><li><a href="#synchronized-怎么实现可重入的呢" class="table-of-contents__link toc-highlight">synchronized 怎么实现可重入的呢？</a></li><li><a href="#synchronized-锁升级了解吗" class="table-of-contents__link toc-highlight">🌟synchronized 锁升级了解吗？</a></li><li><a href="#synchronized-和-reentrantlock-的区别了解吗" class="table-of-contents__link toc-highlight">🌟synchronized 和 ReentrantLock 的区别了解吗？</a></li><li><a href="#lock-了解吗" class="table-of-contents__link toc-highlight">Lock 了解吗？</a></li><li><a href="#reentrantlock-的-lock-方法实现逻辑了解吗" class="table-of-contents__link toc-highlight">ReentrantLock 的 lock() 方法实现逻辑了解吗？</a></li><li><a href="#aqs-了解多少" class="table-of-contents__link toc-highlight">AQS 了解多少？</a></li><li><a href="#aqs-的源码阅读过吗" class="table-of-contents__link toc-highlight">AQS 的源码阅读过吗？</a></li><li><a href="#说说-reentrantlock-的实现原理" class="table-of-contents__link toc-highlight">🌟说说 ReentrantLock 的实现原理？</a></li><li><a href="#reentrantlock-怎么创建公平锁" class="table-of-contents__link toc-highlight">ReentrantLock 怎么创建公平锁？</a></li><li><a href="#怎么创建一个非公平锁呢" class="table-of-contents__link toc-highlight">怎么创建一个非公平锁呢？</a></li><li><a href="#公平锁的实现逻辑了解吗" class="table-of-contents__link toc-highlight">公平锁的实现逻辑了解吗？</a></li><li><a href="#cas-了解多少" class="table-of-contents__link toc-highlight">🌟CAS 了解多少？</a></li><li><a href="#怎么保证-cas-的原子性" class="table-of-contents__link toc-highlight">怎么保证 CAS 的原子性？</a></li><li><a href="#什么是-aba-问题" class="table-of-contents__link toc-highlight">什么是 ABA 问题？</a></li><li><a href="#自旋开销大怎么解决" class="table-of-contents__link toc-highlight">自旋开销大怎么解决？</a></li><li><a href="#java-有哪些保证原子性的方法" class="table-of-contents__link toc-highlight">Java 有哪些保证原子性的方法？</a></li><li><a href="#原子操作类了解多少" class="table-of-contents__link toc-highlight">原子操作类了解多少？</a></li><li><a href="#atomicinteger-的源码读过吗" class="table-of-contents__link toc-highlight">AtomicInteger 的源码读过吗？</a></li><li><a href="#线程死锁了解吗" class="table-of-contents__link toc-highlight">线程死锁了解吗？</a></li><li><a href="#死锁发生的四个条件了解吗" class="table-of-contents__link toc-highlight">死锁发生的四个条件了解吗？</a></li><li><a href="#该如何避免死锁呢" class="table-of-contents__link toc-highlight">该如何避免死锁呢？</a></li><li><a href="#死锁问题怎么排查呢" class="table-of-contents__link toc-highlight">🌟死锁问题怎么排查呢？</a></li><li><a href="#聊聊线程同步和互斥补充" class="table-of-contents__link toc-highlight">聊聊线程同步和互斥？（补充）</a></li><li><a href="#如何实现同步和互斥" class="table-of-contents__link toc-highlight">如何实现同步和互斥？</a></li><li><a href="#锁要解决哪些问题" class="table-of-contents__link toc-highlight">锁要解决哪些问题？</a></li><li><a href="#说说自旋锁" class="table-of-contents__link toc-highlight">说说自旋锁？</a></li><li><a href="#聊聊悲观锁和乐观锁补充" class="table-of-contents__link toc-highlight">🌟聊聊悲观锁和乐观锁？（补充）</a></li></ul></li><li><a href="#并发工具类" class="table-of-contents__link toc-highlight">并发工具类</a><ul><li><a href="#countdownlatch-了解吗" class="table-of-contents__link toc-highlight">CountDownLatch 了解吗？</a></li><li><a href="#场景题假如要查10万多条数据用线程池分成20个线程去执行怎么做到等所有的线程都查找完之后即最后一条结果查找结束了才输出结果" class="table-of-contents__link toc-highlight">场景题：假如要查10万多条数据，用线程池分成20个线程去执行，怎么做到等所有的线程都查找完之后，即最后一条结果查找结束了，才输出结果？</a></li><li><a href="#cyclicbarrier-了解吗" class="table-of-contents__link toc-highlight">CyclicBarrier 了解吗？</a></li><li><a href="#cyclicbarrier-和-countdownlatch-有什么区别" class="table-of-contents__link toc-highlight">CyclicBarrier 和 CountDownLatch 有什么区别？</a></li><li><a href="#semaphore-了解吗" class="table-of-contents__link toc-highlight">Semaphore 了解吗？</a></li><li><a href="#exchanger-了解吗" class="table-of-contents__link toc-highlight">Exchanger 了解吗？</a></li><li><a href="#能说一下-concurrenthashmap-的实现吗补充" class="table-of-contents__link toc-highlight">🌟能说一下 ConcurrentHashMap 的实现吗？（补充）</a></li><li><a href="#说一下-jdk-7-中-concurrenthashmap-的实现原理" class="table-of-contents__link toc-highlight">说一下 JDK 7 中 ConcurrentHashMap 的实现原理？</a></li><li><a href="#说一下-jdk-7-中-concurrenthashmap-的-put-流程" class="table-of-contents__link toc-highlight">说一下 JDK 7 中 ConcurrentHashMap 的 put 流程？</a></li><li><a href="#说一下-jdk-7-中-concurrenthashmap-的-get-流程" class="table-of-contents__link toc-highlight">说一下 JDK 7 中 ConcurrentHashMap 的 get 流程？</a></li><li><a href="#说一下-jdk-8-中-concurrenthashmap-的实现原理" class="table-of-contents__link toc-highlight">说一下 JDK 8 中 ConcurrentHashMap 的实现原理？</a></li><li><a href="#说一下-jdk-8-中-concurrenthashmap-的-put-流程" class="table-of-contents__link toc-highlight">说一下 JDK 8 中 ConcurrentHashMap 的 put 流程？</a></li><li><a href="#说一下-jdk-8-中-concurrenthashmap-的-get-流程" class="table-of-contents__link toc-highlight">说一下 JDK 8 中 ConcurrentHashMap 的 get 流程？</a></li><li><a href="#说一下-hashmap-和-concurrenthashmap-的区别" class="table-of-contents__link toc-highlight">说一下 HashMap 和 ConcurrentHashMap 的区别？</a></li><li><a href="#你项目中怎么使用-concurrenthashmap-的" class="table-of-contents__link toc-highlight">你项目中怎么使用 ConcurrentHashMap 的？</a></li><li><a href="#说一下-concurrenthashmap-对-hashmap-的改进" class="table-of-contents__link toc-highlight">说一下 ConcurrentHashMap 对 HashMap 的改进？</a></li><li><a href="#为什么-concurrenthashmap-在-jdk-17-中要用-reentrantlock而在-jdk-18-要用-synchronized" class="table-of-contents__link toc-highlight">为什么 ConcurrentHashMap 在 JDK 1.7 中要用 ReentrantLock，而在 JDK 1.8 要用 synchronized</a></li><li><a href="#concurrenthashmap-怎么保证可见性补充" class="table-of-contents__link toc-highlight">ConcurrentHashMap 怎么保证可见性？（补充）</a></li><li><a href="#为什么-concurrenthashmap-比-hashtable-效率高补充" class="table-of-contents__link toc-highlight">为什么 ConcurrentHashMap 比 Hashtable 效率高（补充）</a></li><li><a href="#能说一下-copyonwritearraylist-的实现原理吗补充" class="table-of-contents__link toc-highlight">能说一下 CopyOnWriteArrayList 的实现原理吗？（补充）</a></li><li><a href="#能说一下-blockingqueue-吗补充" class="table-of-contents__link toc-highlight">能说一下 BlockingQueue 吗？（补充）</a></li><li><a href="#阻塞队列是如何实现的" class="table-of-contents__link toc-highlight">阻塞队列是如何实现的？</a></li></ul></li><li><a href="#线程池" class="table-of-contents__link toc-highlight">线程池</a><ul><li><a href="#什么是线程池" class="table-of-contents__link toc-highlight">🌟什么是线程池？</a></li><li><a href="#你在项目中有用到线程池吗" class="table-of-contents__link toc-highlight">你在项目中有用到线程池吗？</a></li><li><a href="#说一下线程池的工作流程" class="table-of-contents__link toc-highlight">🌟说一下线程池的工作流程？</a></li><li><a href="#56线程池的主要参数有哪些" class="table-of-contents__link toc-highlight">🌟56.线程池的主要参数有哪些？</a></li><li><a href="#能简单说一下参数之间的关系吗" class="table-of-contents__link toc-highlight">能简单说一下参数之间的关系吗？</a></li><li><a href="#核心线程数不够会怎么进行处理" class="table-of-contents__link toc-highlight">核心线程数不够会怎么进行处理？</a></li><li><a href="#举个例子说一下这些参数的变化" class="table-of-contents__link toc-highlight">举个例子说一下这些参数的变化？</a></li><li><a href="#线程池的拒绝策略有哪些" class="table-of-contents__link toc-highlight">🌟线程池的拒绝策略有哪些？</a></li><li><a href="#线程池有哪几种阻塞队列" class="table-of-contents__link toc-highlight">线程池有哪几种阻塞队列？</a></li><li><a href="#线程池提交-execute-和-submit-有什么区别" class="table-of-contents__link toc-highlight">线程池提交 execute 和 submit 有什么区别？</a></li><li><a href="#线程池怎么关闭知道吗" class="table-of-contents__link toc-highlight">线程池怎么关闭知道吗？</a></li><li><a href="#线程池的线程数应该怎么配置" class="table-of-contents__link toc-highlight">线程池的线程数应该怎么配置？</a></li><li><a href="#如何知道你设置的线程数多了还是少了" class="table-of-contents__link toc-highlight">如何知道你设置的线程数多了还是少了？</a></li><li><a href="#有哪几种常见的线程池" class="table-of-contents__link toc-highlight">有哪几种常见的线程池？</a></li><li><a href="#能说一下四种常见线程池的原理吗" class="table-of-contents__link toc-highlight">能说一下四种常见线程池的原理吗？</a></li><li><a href="#说说固定大小线程池的原理" class="table-of-contents__link toc-highlight">说说固定大小线程池的原理？</a></li><li><a href="#说说缓存线程池的原理" class="table-of-contents__link toc-highlight">说说缓存线程池的原理？</a></li><li><a href="#说说定时任务线程池的原理" class="table-of-contents__link toc-highlight">说说定时任务线程池的原理？</a></li><li><a href="#使用无界队列的线程池会出现什么问题" class="table-of-contents__link toc-highlight">使用无界队列的线程池会出现什么问题？</a></li><li><a href="#线程池异常怎么处理知道吗" class="table-of-contents__link toc-highlight">线程池异常怎么处理知道吗？</a></li><li><a href="#能说一下线程池有几种状态吗" class="table-of-contents__link toc-highlight">能说一下线程池有几种状态吗？</a></li><li><a href="#线程池如何实现参数的动态修改" class="table-of-contents__link toc-highlight">线程池如何实现参数的动态修改？</a></li><li><a href="#线程池在使用的时候需要注意什么补充" class="table-of-contents__link toc-highlight">线程池在使用的时候需要注意什么？（补充）</a></li><li><a href="#你能设计实现一个线程池吗" class="table-of-contents__link toc-highlight">🌟你能设计实现一个线程池吗？</a></li><li><a href="#手写一个数据库连接池可以吗" class="table-of-contents__link toc-highlight">手写一个数据库连接池，可以吗？</a></li><li><a href="#线程池执行中断电了应该怎么处理" class="table-of-contents__link toc-highlight">线程池执行中断电了应该怎么处理？</a></li></ul></li><li><a href="#并发容器和框架" class="table-of-contents__link toc-highlight">并发容器和框架</a><ul><li><a href="#forkjoin-框架了解吗" class="table-of-contents__link toc-highlight">Fork/Join 框架了解吗？</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/doc/docs/intro">Tutorial</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://x.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">X<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/doc/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>