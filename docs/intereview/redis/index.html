<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-REDIS/REDIS_REVIEW" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.8.1">
<title data-rh="true">REDIS_REVIEW | My Site</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://your-docusaurus-site.example.com/doc/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://your-docusaurus-site.example.com/doc/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://your-docusaurus-site.example.com/doc/docs/intereview/redis"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="REDIS_REVIEW | My Site"><meta data-rh="true" name="description" content="REDIS_REVIEW"><meta data-rh="true" property="og:description" content="REDIS_REVIEW"><link data-rh="true" rel="icon" href="/doc/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://your-docusaurus-site.example.com/doc/docs/intereview/redis"><link data-rh="true" rel="alternate" href="https://your-docusaurus-site.example.com/doc/docs/intereview/redis" hreflang="en"><link data-rh="true" rel="alternate" href="https://your-docusaurus-site.example.com/doc/docs/intereview/redis" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"REDIS_REVIEW","item":"https://your-docusaurus-site.example.com/doc/docs/intereview/redis"}]}</script><link rel="alternate" type="application/rss+xml" href="/doc/blog/rss.xml" title="My Site RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/doc/blog/atom.xml" title="My Site Atom Feed"><link rel="stylesheet" href="/doc/assets/css/styles.8d5b4fe0.css">
<script src="/doc/assets/js/runtime~main.7888916f.js" defer="defer"></script>
<script src="/doc/assets/js/main.2ba6fd96.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t="light";var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",e||t),document.documentElement.setAttribute("data-theme-choice",e||t)}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/doc/img/logo.svg"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/doc/"><div class="navbar__logo"><img src="/doc/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/doc/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">My Site</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/doc/docs/intro">Tutorial</a><a class="navbar__item navbar__link" href="/doc/blog">Blog</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="Switch between dark and light mode (currently system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/doc/docs/intro">Tutorial Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/doc/docs/category/tutorial---basics">Tutorial - Basics</a><button aria-label="Expand sidebar category &#x27;Tutorial - Basics&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/doc/docs/category/tutorial---extras">Tutorial - Extras</a><button aria-label="Expand sidebar category &#x27;Tutorial - Extras&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/doc/docs/JAVA/">java</a><button aria-label="Expand sidebar category &#x27;java&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/MQ">MQ</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/MYSQL/MYSQL-REVIEW">MYSQL</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/NGINX/NGINX-REVIEW">NGINX</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" href="/doc/docs/intereview/redis">REDIS</a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/doc/docs/intereview/redis">REDIS_REVIEW</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/SPRING/SPRING-REVIEW">SPRING</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/doc/docs/tmp">tmp</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/分布式/分布式-REVIEW">分布式</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/doc/docs/INTERVIEW/微服务/微服务-REVIEW">微服务</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/doc/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">REDIS</span></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">REDIS_REVIEW</span></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>REDIS_REVIEW</h1></header><h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说什么是-redis">🌟说说什么是 Redis?<a href="#说说什么是-redis" class="hash-link" aria-label="Direct link to 🌟说说什么是 Redis?" title="Direct link to 🌟说说什么是 Redis?">​</a></h3>
<p>它主要的特点是把数据放在内存当中，相比直接访问磁盘的关系型数据库，读写速度会快很多，基本上能达到微秒级的响应。
所以在一些对性能要求很高的场景，比如缓存热点数据、防止接口爆刷，都会用到 Redis。
不仅如此，Redis 还支持持久化，可以将内存中的数据异步落盘，以便服务宕机重启后能恢复数据</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis-和-mysql-的区别">Redis 和 MySQL 的区别？<a href="#redis-和-mysql-的区别" class="hash-link" aria-label="Direct link to Redis 和 MySQL 的区别？" title="Direct link to Redis 和 MySQL 的区别？">​</a></h3>
<p>Redis 属于非关系型数据库，数据是通过键值对的形式放在内存当中的；MySQL 属于关系型数据库，数据以行和列的形式存储在磁盘当中。
<img decoding="async" loading="lazy" alt="img.png" src="/doc/assets/images/img-408828fc0e9b1287483cf759bc585612.png" width="1178" height="786" class="img_ev3q">
实际开发中，会将 MySQL 作为主存储，Redis 作为缓存，通过先查 Redis，未命中再查 MySQL 并写回Redis 的方式来提高系统的整体性能</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="项目里哪里用到了-redis">项目里哪里用到了 Redis？<a href="#项目里哪里用到了-redis" class="hash-link" aria-label="Direct link to 项目里哪里用到了 Redis？" title="Direct link to 项目里哪里用到了 Redis？">​</a></h3>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="部署过-redis-吗">部署过 Redis 吗？<a href="#部署过-redis-吗" class="hash-link" aria-label="Direct link to 部署过 Redis 吗？" title="Direct link to 部署过 Redis 吗？">​</a></h3>
<p>我有在生产环境中部署单机版 Redis，从官网下载源码包解压后执行 make &amp;&amp; make install 编译安装。然后编辑 redis.conf 文件，开启远程访问、设置密码、限制内存、设置内存过期淘汰策略、开启 AOF 持久化等：</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis-的高可用方案有部署过吗">Redis 的高可用方案有部署过吗？<a href="#redis-的高可用方案有部署过吗" class="hash-link" aria-label="Direct link to Redis 的高可用方案有部署过吗？" title="Direct link to Redis 的高可用方案有部署过吗？">​</a></h3>
<p>有部署过哨兵机制，这是一个相对成熟的高可用解决方案，我们生产环境部署的是一主两从的 Redis 实例，再加上三个 Sentinel 节点监控它们。Sentinel 的配置相对简单，主要设置了故障转移的判定条件和超时阈值。
主节点配置:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">port 6379</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">appendonly yes</span><br></span></code></pre></div></div>
<p>从节点配置：</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">replicaof 192.168.1.10 6379</span><br></span></code></pre></div></div>
<p>哨兵节点配置：</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">sentinel monitor mymaster 192.168.1.10 6379 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sentinel down-after-milliseconds mymaster 5000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sentinel failover-timeout mymaster 60000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sentinel parallel-syncs mymaster 1</span><br></span></code></pre></div></div>
<p>当主节点发生故障时，Sentinel 能够自动检测并协商选出新的主节点，这个过程大概需要 10-15 秒。</p>
<p>另一个大型项目中，我们使用了 Redis Cluster 集群方案。该项目数据量大且增长快，需要水平扩展能力。我们部署了 6 个主节点，每个主节点配备一个从节点，形成了一个 3主3从 的初始集群。Redis Cluster 的设置比 Sentinel 复杂一些，需要正确配置集群节点间通信、分片映射等。</p>
<div class="language-redis codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-redis codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">redis-server redis-7000.conf</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">redis-server redis-7001.conf</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 使用 redis-cli 创建集群</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Redis 会自动将 key 哈希到 16384 个槽位</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 主节点均分槽位，从节点自动跟随</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">redis-cli --cluster create \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  --cluster-replicas 1</span><br></span></code></pre></div></div>
<p>Redis Cluster 最大的优势是数据自动分片，我们可以通过简单地增加节点来扩展集群容量。此外，它的故障转移也很快，通常在几秒内就能完成。</p>
<p>对于一些轻量级应用，我也使用过主从复制加手动故障转移的方案。主节点负责读写操作，从节点负责读操作。手动故障转移时，我们会先将从节点提升为主节点，然后重新配置其他从节点。</p>
<div class="language-redis codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-redis codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># 1. 取消从节点身份</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">redis-cli -h &lt;slave-ip&gt; slaveof no one</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 2. 将其他从节点指向新的主节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">redis-cli -h &lt;other-slave-ip&gt; slaveof &lt;new-master-ip&gt; &lt;port&gt;```</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis-可以用来干什么">.Redis 可以用来干什么？<a href="#redis-可以用来干什么" class="hash-link" aria-label="Direct link to .Redis 可以用来干什么？" title="Direct link to .Redis 可以用来干什么？">​</a></h3>
<p>Redis 可以用来做缓存，比如说把高频访问的文章详情、商品信息、用户信息放入 Redis 当中，并通过设置过期时间来保证数据一致性，这样就可以减轻数据库的访问压力。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis有哪些数据类型">Redis有哪些数据类型？<a href="#redis有哪些数据类型" class="hash-link" aria-label="Direct link to Redis有哪些数据类型？" title="Direct link to Redis有哪些数据类型？">​</a></h3>
<p>Redis 支持五种基本数据类型，分别是字符串、列表、哈希、集合和有序集合。
<img decoding="async" loading="lazy" alt="img_1.png" src="/doc/assets/images/img_1-3a5076a8234ff4ead75fb49ec95f3dc5.png" width="818" height="746" class="img_ev3q">
还有三种扩展数据类型，分别是用于位级操作的 Bitmap、用于基数估算的 HyperLogLog、支持存储和查询地理坐标的 GEO。</p>
<p>详细介绍下字符串？
字符串是最基本的数据类型，可以存储文本、数字或者二进制数据，最大容量是 512 MB。
<img decoding="async" loading="lazy" alt="img_2.png" src="/doc/assets/images/img_2-1d77f617164524b75e7a34377fb54b82.png" width="1636" height="620" class="img_ev3q">
适合缓存单个对象，比如验证码、token、计数器等。</p>
<p>详细介绍下列表？
列表是一个有序的元素集合，支持从头部或尾部插入/删除元素，常用于消息队列或任务列表。
<img decoding="async" loading="lazy" alt="img_3.png" src="/doc/assets/images/img_3-1d3d6f1f5f0017a9b9b868c9a3120d35.png" width="1710" height="718" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="详细介绍下哈希">详细介绍下哈希？<a href="#详细介绍下哈希" class="hash-link" aria-label="Direct link to 详细介绍下哈希？" title="Direct link to 详细介绍下哈希？">​</a></h3>
<p>哈希是一个键值对集合，适合存储对象，如商品信息、用户信息等。比如说 <code>value = {name: &#x27;沉默王二&#x27;, age: 18}</code>。
<img decoding="async" loading="lazy" alt="img_4.png" src="/doc/assets/images/img_4-98277c349e92bf40563d2367eee43f46.png" width="1160" height="908" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="详细介绍下集合">详细介绍下集合？<a href="#详细介绍下集合" class="hash-link" aria-label="Direct link to 详细介绍下集合？" title="Direct link to 详细介绍下集合？">​</a></h3>
<p>集合是无序且不重复的，支持交集、并集操作，查询效率能达到 O(1) 级别，主要用于去重、标签、共同好友等场景。
<img decoding="async" loading="lazy" alt="img_5.png" src="/doc/assets/images/img_5-8de7cd0e198698f9c3fc2860d8ff943d.png" width="1254" height="686" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="详细介绍下有序集合">详细介绍下有序集合？<a href="#详细介绍下有序集合" class="hash-link" aria-label="Direct link to 详细介绍下有序集合？" title="Direct link to 详细介绍下有序集合？">​</a></h3>
<p>有序集合的元素按分数进行排序，支持范围查询，适用于排行榜或优先级队列。
<img decoding="async" loading="lazy" alt="img_6.png" src="/doc/assets/images/img_6-46b5517a70b5d73d9399df752a333a8d.png" width="822" height="392" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="详细介绍下bitmap">详细介绍下Bitmap？<a href="#详细介绍下bitmap" class="hash-link" aria-label="Direct link to 详细介绍下Bitmap？" title="Direct link to 详细介绍下Bitmap？">​</a></h3>
<p>Bitmap 可以把一组二进制位紧凑地存储在一块连续内存中，每一位代表一个对象的状态，比如是否签到、是否活跃等。
<img decoding="async" loading="lazy" alt="img_7.png" src="/doc/assets/images/img_7-f5365c472a8ed5aad0029804e0725117.png" width="1098" height="503" class="img_ev3q">
比如用户 0 的已签到 1、用户 1 未签到 0、用户 2 已签到，Redis 就会把这些状态放进一个连续的二进制串 101，1 亿用户签到仅需 100,000,000 / 8 / 1024 ≈ 12MB 的空间，真的省到离谱。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="详细介绍下hyperloglog">详细介绍下HyperLogLog？<a href="#详细介绍下hyperloglog" class="hash-link" aria-label="Direct link to 详细介绍下HyperLogLog？" title="Direct link to 详细介绍下HyperLogLog？">​</a></h3>
<p>HyperLogLog 是一种用于基数统计的概率性数据结构，可以在仅有 12KB 的内存空间下，统计海量数据集中不重复元素的个数，误差率仅 0.81%。
<img decoding="async" loading="lazy" alt="img_8.png" src="/doc/assets/images/img_8-06f81c9049f7b8db0504de90a3a4f90b.png" width="571" height="225" class="img_ev3q">
底层基于 LogLog 算法改进，先把每个元素哈希成一个二进制串，然后取前 14 位进行分组，放到 16384 个桶中，记录每组最大的前导零数量，最后用一个近似公式推算出总体的基数。
？？？</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="详细介绍下geo">详细介绍下GEO？<a href="#详细介绍下geo" class="hash-link" aria-label="Direct link to 详细介绍下GEO？" title="Direct link to 详细介绍下GEO？">​</a></h3>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么使用-hash-类型而不使用-string-类型序列化存储">为什么使用 hash 类型而不使用 string 类型序列化存储？<a href="#为什么使用-hash-类型而不使用-string-类型序列化存储" class="hash-link" aria-label="Direct link to 为什么使用 hash 类型而不使用 string 类型序列化存储？" title="Direct link to 为什么使用 hash 类型而不使用 string 类型序列化存储？">​</a></h3>
<p>Hash 可以只读取或者修改某一个字段，而 String 需要一次性把整个对象取出来。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis-为什么快呢">🌟Redis 为什么快呢？<a href="#redis-为什么快呢" class="hash-link" aria-label="Direct link to 🌟Redis 为什么快呢？" title="Direct link to 🌟Redis 为什么快呢？">​</a></h3>
<p>第一，Redis 的所有数据都放在内存中，而内存的读写速度本身就比磁盘快几个数量级。
<img decoding="async" loading="lazy" alt="img_9.png" src="/doc/assets/images/img_9-b3d6326f02948a30cca92e0434c6f6c5.png" width="1456" height="682" class="img_ev3q">
第二，Redis 采用了基于 IO 多路复用技术的事件驱动模型来处理客户端请求和执行 Redis 命令。
<img decoding="async" loading="lazy" alt="img_10.png" src="/doc/assets/images/img_10-8ff5a9c1a53b335db8a786f53c39db72.png" width="2136" height="674" class="img_ev3q">
其中的 IO 多路复用技术可以在只有一个线程的情况下，同时监听成千上万个客户端连接，解决传统 IO 模型中每个连接都需要一个独立线程带来的性能开销。
<img decoding="async" loading="lazy" alt="img_11.png" src="/doc/assets/images/img_11-9f701eb0cb9af56575f9373844646f21.png" width="2417" height="985" class="img_ev3q">
IO 多路复用会持续监听请求，然后把准备好的请求压入到一个队列当中，并将其有序地传递给文件事件分派器，最后由事件处理器来执行对应的 accept、read 和 write 请求。
<img decoding="async" loading="lazy" alt="img_12.png" src="/doc/assets/images/img_12-69727432f7f60ce364ada9a86eb424eb.png" width="1272" height="1150" class="img_ev3q">
Redis 会根据操作系统选择最优的 IO 多路复用技术，比如 Linux 下使用 epoll，macOS 下使用 kqueue 等。</p>
<p>在 Redis 6.0 之前，包括连接建立、请求读取、响应发送，以及命令执行都是在主线程中顺序执行的，这样可以避免多线程环境下的锁竞争和上下文切换，因为 Redis 的绝大部分操作都是在内存中进行的，性能瓶颈主要是内存操作和网络通信，而不是 CPU。
<img decoding="async" loading="lazy" alt="img_13.png" src="/doc/assets/images/img_13-be0eaacf1ac14fcc5ce54f6686f7368d.png" width="1644" height="656" class="img_ev3q">
为了进一步解决网络 IO 的性能瓶颈，Redis 6.0 引入了多线程机制，把网络 IO 和命令执行分开，网络 IO 交给线程池来处理，而命令执行仍然在主线程中进行，这样就可以充分利用多核 CPU 的性能。
<img decoding="async" loading="lazy" alt="img_14.png" src="/doc/assets/images/img_14-58414f2a38e55c75b5c21e94c00a5f28.png" width="1638" height="858" class="img_ev3q">
主线程专注于命令执行，网络IO 由其他线程分担，在多核 CPU 环境下，Redis 的性能可以得到显著提升。
<img decoding="async" loading="lazy" alt="img_15.png" src="/doc/assets/images/img_15-edb739338a60e1faaf19192639a003f3.png" width="740" height="1115" class="img_ev3q">
总结：
<img decoding="async" loading="lazy" alt="img_16.png" src="/doc/assets/images/img_16-0a182559da4b95383b46e09541593540.png" width="1400" height="1036" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="能详细说一下io多路复用吗">能详细说一下IO多路复用吗？<a href="#能详细说一下io多路复用吗" class="hash-link" aria-label="Direct link to 能详细说一下IO多路复用吗？" title="Direct link to 能详细说一下IO多路复用吗？">​</a></h3>
<p>IO 多路复用是一种允许单个进程同时监视多个文件描述符的技术，使得程序能够高效处理多个并发连接而无需创建大量线程。
<img decoding="async" loading="lazy" alt="img_17.png" src="/doc/assets/images/img_17-83b9b806bf23820a3082b3c53e2d63db.png" width="948" height="618" class="img_ev3q">
IO 多路复用的核心思想是：让单个线程可以等待多个文件描述符就绪，然后对就绪的描述符进行操作。这样可以在不使用多线程或多进程的情况下处理并发连接。
<img decoding="async" loading="lazy" alt="img_18.png" src="/doc/assets/images/img_18-d1311cafd7c9abaed8e73c437fa7bf31.png" width="637" height="772" class="img_ev3q"></p>
<p>主要的实现机制包括 select、poll、epoll、kqueue 和 IOCP 等。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="请说说-selectpollepollkqueue-和-iocp-的区别"><a href="https://javabetter.cn/sidebar/sanfene/redis.html#%E8%AF%B7%E8%AF%B4%E8%AF%B4-select%E3%80%81poll%E3%80%81epoll%E3%80%81kqueue-%E5%92%8C-iocp-%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener noreferrer">请说说 select、poll、epoll、kqueue 和 IOCP 的区别？</a><a href="#请说说-selectpollepollkqueue-和-iocp-的区别" class="hash-link" aria-label="Direct link to 请说说-selectpollepollkqueue-和-iocp-的区别" title="Direct link to 请说说-selectpollepollkqueue-和-iocp-的区别">​</a></h3>
<p>select 的缺点是单个进程能监视的文件描述符数量有限，一般为 1024 个，且每次调用都需要将文件描述符集合从用户态复制到内核态，然后遍历找出就绪的描述符，性能较差。</p>
<div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">// select 的基本使用</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">select</span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> nfds</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> fd_set </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">readfds</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> fd_set </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">writefds</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           fd_set </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">exceptfds</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">timeval</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">timeout</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// 示例代码</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fd_set readfds</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">FD_ZERO</span><span class="token punctuation" style="color:#393A34">(</span><span class="token operator" style="color:#393A34">&amp;</span><span class="token plain">readfds</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain">                </span><span class="token comment" style="color:#999988;font-style:italic">// 清空集合</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">FD_SET</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">sockfd</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">&amp;</span><span class="token plain">readfds</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain">         </span><span class="token comment" style="color:#999988;font-style:italic">// 添加监听套接字</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">select</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">sockfd </span><span class="token operator" style="color:#393A34">+</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">&amp;</span><span class="token plain">readfds</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">NULL</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">NULL</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">NULL</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token function" style="color:#d73a49">FD_ISSET</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">sockfd</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">&amp;</span><span class="token plain">readfds</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">// 检查是否就绪</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">// 处理读事件</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre></div></div>
<p>poll 的优点是没有最大文件描述符数量的限制，但是每次调用仍然需要将文件描述符集合从用户态复制到内核态，依然需要遍历，性能仍然较差。</p>
<div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">// poll 的基本使用</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">poll</span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">pollfd</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">fds</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token class-name">nfds_t</span><span class="token plain"> nfds</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> timeout</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// 示例代码</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">pollfd</span><span class="token plain"> fds</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">MAX_EVENTS</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fds</span><span class="token punctuation" style="color:#393A34">[</span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">fd </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> sockfd</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fds</span><span class="token punctuation" style="color:#393A34">[</span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">events </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> POLLIN</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">// 监听读事件</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">poll</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">fds</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">-</span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">fds</span><span class="token punctuation" style="color:#393A34">[</span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">revents </span><span class="token operator" style="color:#393A34">&amp;</span><span class="token plain"> POLLIN</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">// 处理读事件</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre></div></div>
<p>epoll 是 Linux 特有的 IO 多路复用机制，支持大规模并发连接，使用事件驱动模型，性能更高。其工作原理是将文件描述符注册到内核中，然后通过事件通知机制来处理就绪的文件描述符，不需要轮询，也不需要数据拷贝，更没有数量限制，所以性能非常高。</p>
<div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">// epoll 的基本使用</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">epoll_create</span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> size</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">epoll_ctl</span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> epfd</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> op</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> fd</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">epoll_event</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">event</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">epoll_wait</span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> epfd</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">epoll_event</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">events</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> maxevents</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> timeout</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// 示例代码</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> epfd </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">epoll_create</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">epoll_event</span><span class="token plain"> ev</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> events</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">MAX_EVENTS</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ev</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">events </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> EPOLLIN</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ev</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">data</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">fd </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> sockfd</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">epoll_ctl</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">epfd</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> EPOLL_CTL_ADD</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> sockfd</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">&amp;</span><span class="token plain">ev</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">while</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> nfds </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">epoll_wait</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">epfd</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> events</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> MAX_EVENTS</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">-</span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">for</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> i </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> i </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain"> nfds</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> i</span><span class="token operator" style="color:#393A34">++</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">events</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">data</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">fd </span><span class="token operator" style="color:#393A34">==</span><span class="token plain"> sockfd</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><span class="token comment" style="color:#999988;font-style:italic">// 处理读事件</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre></div></div>
<p>kqueue 是 BSD/macOS 系统下的 IO 多路复用机制，类似于 epoll，支持大规模并发连接，使用事件驱动模型。
IOCP 是 Windows 系统下的 IO 多路复用机制，使用使用完成端口模型而非事件通知。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="举个例子说一下-io-多路复用">举个例子说一下 IO 多路复用？<a href="#举个例子说一下-io-多路复用" class="hash-link" aria-label="Direct link to 举个例子说一下 IO 多路复用？" title="Direct link to 举个例子说一下 IO 多路复用？">​</a></h3>
<p>比如说我是一名数学老师，上课时提出了一个问题：“今天谁来证明一下勾股定律？”</p>
<p>同学小王举手，我就让小王回答；小李举手，我就让小李回答；小张举手，我就让小张回答。</p>
<p>这种模式就是 IO 多路复用，我只需要在讲台上等，谁举手谁回答，不需要一个一个去问。
<img decoding="async" loading="lazy" alt="1756682551610" src="/doc/assets/images/1756682551610-1c3d220519afcc1db10d17bb710104e7.png" width="1127" height="616" class="img_ev3q">
Redis 就是使用 epoll 这样的 IO 多路复用机制，在单线程模型下实现高效的网络 IO，从而支持高并发的请求处理。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="举例子说一下阻塞-io和-io-多路复用的差别">举例子说一下阻塞 IO和 IO 多路复用的差别？<a href="#举例子说一下阻塞-io和-io-多路复用的差别" class="hash-link" aria-label="Direct link to 举例子说一下阻塞 IO和 IO 多路复用的差别？" title="Direct link to 举例子说一下阻塞 IO和 IO 多路复用的差别？">​</a></h3>
<p>假设我是一名老师，让学生解答一道题目。</p>
<p>我的第一种选择：按顺序逐个检查，先检查 A同学，然后是 B，之后是 C、D。。。这中间如果有一个学生卡住，全班都会被耽误。</p>
<p>这种就是阻塞 IO，不具有并发能力。
<img decoding="async" loading="lazy" alt="1756682584609" src="/doc/assets/images/1756682584609-c45bff9af0765e4735f807c32ff22356.png" width="760" height="1095" class="img_ev3q">
<img decoding="async" loading="lazy" alt="1756682598255" src="/doc/assets/images/1756682598255-c45bff9af0765e4735f807c32ff22356.png" width="760" height="1095" class="img_ev3q">
我的第二种选择，我站在讲台上等，谁举手我去检查谁。C、D 举手，我去检查 C、D 的答案，然后继续回到讲台上等。此时 E、A 又举手，然后去处理 E 和 A。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="selectpoll-和-epoll-的实现原理">select、poll 和 epoll 的实现原理？<a href="#selectpoll-和-epoll-的实现原理" class="hash-link" aria-label="Direct link to select、poll 和 epoll 的实现原理？" title="Direct link to select、poll 和 epoll 的实现原理？">​</a></h3>
<p>select 和 poll 都是通过把所有文件描述符传递给内核，由内核遍历判断哪些就绪。</p>
<p>select 将文件描述符 FD 通过 BitsMap 传入内核，轮询所有的 FD，通过调用 file-&gt;poll 函数查询是否有对应事件，没有就将 task 加入 FD 对应 file 的待唤醒队列，等待事件来临被唤醒。
<img decoding="async" loading="lazy" alt="1756682635040" src="/doc/assets/images/1756682635040-4b3d676fdd4a947700b2f3323a1fd194.png" width="2157" height="1243" class="img_ev3q">
poll 改进了连接数上限问题，不再用 BitsMap 来传入 FD，取而代之的是动态数组 pollfd，但本质上仍是线性遍历，性能没有提升太多。
<img decoding="async" loading="lazy" alt="1756682644061" src="/doc/assets/images/1756682644061-aef8bb1d00be24b3f3e77c633a3bc420.png" width="1503" height="780" class="img_ev3q">
select和poll的模式都是，一次将参数拷贝到内核空间，等有结果了再一次拷贝出去。</p>
<p>epoll 将监听的 FD 注册进内核的红黑树，由内核在事件触发时将就绪的 FD 放入 ready list。应用程序通过 epoll_wait 获取就绪的 FD，从而避免遍历所有连接的开销。
<img decoding="async" loading="lazy" alt="1756682656684" src="/doc/assets/images/1756682656684-6a4791f68cf3beba63643399bd736064.png" width="2125" height="1217" class="img_ev3q">
epoll 最大的优点是：支持事件驱动 + 边缘触发，ADD 时拷贝一次，epoll_wait 时利用 MMAP 和用户共享空间，直接拷贝数据到用户空间，因此在高并发场景下性能远高于 select 和 poll。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis为什么早期选择单线程">Redis为什么早期选择单线程？<a href="#redis为什么早期选择单线程" class="hash-link" aria-label="Direct link to Redis为什么早期选择单线程？" title="Direct link to Redis为什么早期选择单线程？">​</a></h3>
<p>第一，单线程模型不需要考虑复杂的锁机制，不存在多线程环境下的死锁、竞态条件等问题，开发起来更快，也更容易维护
<img decoding="async" loading="lazy" alt="1756682689243" src="/doc/assets/images/1756682689243-7f5d451d7da99035c7456dcc4114d233.png" width="2978" height="1228" class="img_ev3q"></p>
<p>第二，Redis 是IO 密集型而非 CPU 密集型，主要受内存和网络 IO 限制，而非 CPU 的计算能力，单线程可以避免线程上下文切换的开销。
哪怕我们在一个普通的 Linux 服务器上启动 Redis 服务，它也能在 1s 内处理 1000000 个用户请求。</p>
<p>第三，单线程可以保证命令执行的原子性，无需额外的同步机制。</p>
<p>Redis 虽然最初采用了单线程设计，但后续的版本中也在特定方面引入了多线程，比如说 Redis 4.0 就引异步多线程，用于清理脏数据、释放无用连接、删除大 Key 等。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis-60-使用多线程是怎么回事">Redis 6.0 使用多线程是怎么回事?<a href="#redis-60-使用多线程是怎么回事" class="hash-link" aria-label="Direct link to Redis 6.0 使用多线程是怎么回事?" title="Direct link to Redis 6.0 使用多线程是怎么回事?">​</a></h3>
<p>Redis 6.0 的多线程仅用于处理网络 IO，包括网络数据的读取、写入，以及请求解析。</p>
<p>而命令的执行依然是单线程，这种设计被称为“IO 线程化”，能够在高负载的情况下，最大限度地提升 Redis 的响应速度。</p>
<p>---- 这部分面试中可以不背，方便大家理解 start ----</p>
<p>这一变化主要是因为随着网络带宽和服务器性能的提升，Redis 的瓶颈从 CPU 逐渐转移到了网络 IO：</p>
<p>带宽从 10Gbps 提升到 100Gbps，甚至更高。
请求的并发数从几千到几万，甚至几十万。
单线程在高负载场景下处理网络 IO 出现了明显的性能瓶颈，Redis 的开发团队通过研究发现，在处理大数据包时，单线程 Redis 有超过 80% 的 CPU 时间花在网络 IO 上，而实际命令执行仅占 20% 左右。
<img decoding="async" loading="lazy" alt="1756682807254" src="/doc/assets/images/1756682807254-9b61478883df600be82897864b33db55.png" width="1162" height="888" class="img_ev3q"></p>
<p>Redis 6.0 的多线程 IO 模型主要包含三个核心步骤：
仍然由主线程负责接收客户端的连接请求。
主线程将连接请求分发给多个 IO 线程进行处理，主线程负责解析和执行命令。
命令执行完毕后，由多个 IO 线程将结果返回给客户端。</p>
<p>Redis 6.0 默认仍然使用单线程模式，但可以通过配置文件或命令行参数启用多线程模式。</p>
<p>建议将 IO 线程数设置为 CPU 核心数的一半，一般不建议超过 8 个。</p>
<p>经过多次测试，Redis 6.0 在处理 1-200 字节的小数据包时，性能提升 1.5-2 倍；在处理 1KB 以上的大数据包时提升约 3-5 倍。</p>
<p>----这部分面试中可以不背，方便大家理解 end ----</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说-redis-的常用命令补充">说说 Redis 的常用命令（补充）<a href="#说说-redis-的常用命令补充" class="hash-link" aria-label="Direct link to 说说 Redis 的常用命令（补充）" title="Direct link to 说说 Redis 的常用命令（补充）">​</a></h3>
<p>一句话回答（也不用全部都背，挑三个就行）：
Redis 支持多种数据结构，常用的命令也比较多，比如说操作字符串可以用 SET/GET/INCR，操作哈希可以用 HSET/HGET/HGETALL，操作列表可以用 LPUSH/LPOP/LRANGE，操作集合可以用 SADD/SISMEMBER，操作有序集合可以用 ZADD/ZRANGE/ZINCRBY等，通用命令有 EXPIRE/DEL/KEYS 等。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="详细说说-set-命令">详细说说 set 命令？<a href="#详细说说-set-命令" class="hash-link" aria-label="Direct link to 详细说说 set 命令？" title="Direct link to 详细说说 set 命令？">​</a></h3>
<p>SET 命令用于设置字符串的 key，支持过期时间和条件写入，常用于设置缓存、实现分布式锁、延长 Session 等场景。
默认情况下，SET 会覆盖键已有的值。</p>
<p>支持多种设置过期时间的方式，比如说 EX 设置秒级过期时间，PX 设置毫秒过期时间。</p>
<p>支持条件写入，使其可以实现原子性操作，比如说 NX 仅在键不存在时设置值，XX 仅在键存在时设置值。</p>
<p>缓存实现：</p>
<div class="language-reids codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-reids codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">SET user:profile:{userid} {JSON数据} EX 3600  # 存储用户资料，并设置1小时过期</span><br></span></code></pre></div></div>
<p>实现分布式锁：</p>
<div class="language-reids codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-reids codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">SET lock:resource_name {random_value} EX 10 NX  # 获取锁，10秒后自动释放</span><br></span></code></pre></div></div>
<p>存储 Session：</p>
<div class="language-reids codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-reids codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">SET session:{sessionid} {session_data} EX 1800  # 存储用户会话，30分钟过期</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sadd-命令的时间复杂度是多少">sadd 命令的时间复杂度是多少？<a href="#sadd-命令的时间复杂度是多少" class="hash-link" aria-label="Direct link to sadd 命令的时间复杂度是多少？" title="Direct link to sadd 命令的时间复杂度是多少？">​</a></h4>
<p>SADD 支持一次添加多个元素，返回值为实际添加成功的元素数量，时间复杂度为 O(N)。</p>
<div class="language-reids codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-reids codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">redis-cli SADD myset &quot;apple&quot; &quot;banana&quot; &quot;orange&quot;</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="incr命令了解吗">incr命令了解吗？<a href="#incr命令了解吗" class="hash-link" aria-label="Direct link to incr命令了解吗？" title="Direct link to incr命令了解吗？">​</a></h4>
<p>INCR 是一个原子命令，可以将指定键的值加 1，如果 key 不存在，会先将其设置为 0，再执行加 1 操作。
常用于网站访问量、文章点赞数等计数器的实现；结合过期时间实现限流器；生成分布式唯一 ID；库存扣减等。</p>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># 限制用户每分钟最多访问10次</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">FUNCTION limit_api_call(user_id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    current = INCR(&quot;rate:&quot;+user_id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    IF current == 1 THEN</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        EXPIRE(&quot;rate:&quot;+user_id, 60)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    END</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    IF current &gt; 10 THEN</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        RETURN false  # 超出限制</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ELSE</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        RETURN true   # 允许访问</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    END</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">END</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="单线程的redis-qps-能到多少补充">单线程的Redis QPS 能到多少？(补充)<a href="#单线程的redis-qps-能到多少补充" class="hash-link" aria-label="Direct link to 单线程的Redis QPS 能到多少？(补充)" title="Direct link to 单线程的Redis QPS 能到多少？(补充)">​</a></h3>
<p>一个普通服务器的 Redis 实例通常可以达到每秒十万左右的 QPS。
----这部分面试中可以不背，方便大家理解 start ----</p>
<p>Redis 的 QPS（每秒请求数）性能取决于多种因素，包括硬件配置、网络延迟、数据结构、命令类型等。</p>
<p>可以通过 redis-benchmark 命令进行基准测试：</p>
<p>redis-benchmark -h 127.0.0.1 -p 6379 -c 50 -n 10000</p>
<p>2023 年前，我用的是一台 macOS，4 GHz 四核 Intel Core i7，32 GB 1867 MHz DDR3，测试结果如下：
可以看得出，每秒能处理超过 10 万次请求。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="持久化">持久化<a href="#持久化" class="hash-link" aria-label="Direct link to 持久化" title="Direct link to 持久化">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis的持久化方式有哪些">🌟Redis的持久化方式有哪些？<a href="#redis的持久化方式有哪些" class="hash-link" aria-label="Direct link to 🌟Redis的持久化方式有哪些？" title="Direct link to 🌟Redis的持久化方式有哪些？">​</a></h3>
<p>主要有两种，RDB 和 AOF。RDB 通过创建时间点快照来实现持久化，AOF 通过记录每个写操作命令来实现持久化。
<img decoding="async" loading="lazy" alt="1756683157769" src="/doc/assets/images/1756683157769-751daf8ef902a83f186cdf7909da1b3a.png" width="609" height="400" class="img_ev3q">
这两种方式可以单独使用，也可以同时使用。这样就可以保证 Redis 服务器在重启后不丢失数据，通过 RDB 和 AOF 文件来恢复内存中原有的数据。</p>
<p><img decoding="async" loading="lazy" alt="1756683178222" src="/doc/assets/images/1756683178222-d8ff7e244f1ac0caee8bce470feb3a7e.png" width="923" height="1200" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="详细说一下-rdb">详细说一下 RDB？<a href="#详细说一下-rdb" class="hash-link" aria-label="Direct link to 详细说一下 RDB？" title="Direct link to 详细说一下 RDB？">​</a></h3>
<p>RDB 持久化机制可以在指定的时间间隔内将 Redis 某一时刻的数据保存到磁盘上的 RDB 文件中，当 Redis 重启时，可以通过加载这个 RDB 文件来恢复数据。
<img decoding="async" loading="lazy" alt="1756683200167" src="/doc/assets/images/1756683200167-849eeaff9b449ea43fd03d9da6550f9c.png" width="1456" height="1299" class="img_ev3q"></p>
<p>RDB 持久化可以通过 save 和 bgsave 命令手动触发，也可以通过配置文件中的 save 指令自动触发。
<img decoding="async" loading="lazy" alt="1756683233212" src="/doc/assets/images/1756683233212-eb08a0c805c946110f79a19eac88209a.png" width="517" height="362" class="img_ev3q">
save 命令会阻塞 Redis 进程，直到 RDB 文件创建完成。</p>
<p>bgsave 命令会在后台 fork 一个子进程来执行 RDB 持久化操作，主进程不会被阻塞。
<img decoding="async" loading="lazy" alt="1756683248047" src="/doc/assets/images/1756683248047-771462f4bb8c5431ae4601713b2539c1.png" width="687" height="455" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么情况下会自动触发-rdb-持久化">什么情况下会自动触发 RDB 持久化？<a href="#什么情况下会自动触发-rdb-持久化" class="hash-link" aria-label="Direct link to 什么情况下会自动触发 RDB 持久化？" title="Direct link to 什么情况下会自动触发 RDB 持久化？">​</a></h3>
<p>第一种，在 Redis 配置文件中设置 RDB 持久化参数 <code>save &lt;seconds&gt; &lt;changes&gt;</code>，表示在指定时间间隔内，如果有指定数量的键发生变化，就会自动触发 RDB 持久化。</p>
<p>第二种，主从复制时，当从节点第一次连接到主节点时，主节点会自动执行 bgsave 生成 RDB 文件，并将其发送给从节点。
<img decoding="async" loading="lazy" alt="1756684381469" src="/doc/assets/images/1756684381469-1a8ac8d65d549a14b8171a1fbc5df49a.png" width="828" height="842" class="img_ev3q">
第三种，如果没有开启 AOF，执行 shutdown 命令时，Redis 会自动保存一次 RDB 文件，以确保数据不会丢失</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="详细说一下-aof">详细说一下 AOF？<a href="#详细说一下-aof" class="hash-link" aria-label="Direct link to 详细说一下 AOF？" title="Direct link to 详细说一下 AOF？">​</a></h3>
<p>AOF 通过记录每个写操作命令，并将其追加到 AOF 文件来实现持久化，Redis 服务器宕机后可以通过重新执行这些命令来恢复数据。
<img decoding="async" loading="lazy" alt="1756684416650" src="/doc/assets/images/1756684416650-5241252e302a2ae014570b76ea0d8e26.png" width="1456" height="662" class="img_ev3q">
当 Redis 执行写操作时，会将写命令追加到 AOF 缓冲区；Redis 会根据同步策略将缓冲区的数据写入到 AOF 文件。
当 AOF 文件过大时，Redis 会自动进行 AOF 重写，剔除多余的命令，比如说多次对同一个 key 的 set 和 del，生成一个新的 AOF 文件；当 Redis 重启时，读取 AOF 文件中的命令并重新执行，以恢复数据。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="aof-的刷盘策略了解吗">AOF 的刷盘策略了解吗？<a href="#aof-的刷盘策略了解吗" class="hash-link" aria-label="Direct link to AOF 的刷盘策略了解吗？" title="Direct link to AOF 的刷盘策略了解吗？">​</a></h3>
<p>Redis 将 AOF 缓冲区的数据写入到 AOF 文件时，涉及两个系统调用：write 将数据写入到操作系统的缓冲区，fsync 将 OS 缓冲区的数据刷新到磁盘。</p>
<p>这里的刷盘涉及到三种策略：always、everysec 和 no。</p>
<p><img decoding="async" loading="lazy" alt="1756684447804" src="/doc/assets/images/1756684447804-a35a80fafe885e9c94ac2093e5633fbb.png" width="1200" height="1095" class="img_ev3q"></p>
<p>always：每次写命令执行完，立即调用 fsync 同步到磁盘，这样可以保证数据不丢失，但性能较差。
everysec：每秒调用一次 fsync，将多条命令一次性同步到磁盘，性能较好，数据丢失的时间窗口为 1 秒。
no：不主动调用 fsync，由操作系统决定，性能最好，但数据丢失的时间窗口不确定，依赖于操作系统的缓存策略，可能会丢失大量数据。
可以通过配置文件中的 appendfsync 参数进行设置。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说aof的重写机制">说说AOF的重写机制？<a href="#说说aof的重写机制" class="hash-link" aria-label="Direct link to 说说AOF的重写机制？" title="Direct link to 说说AOF的重写机制？">​</a></h3>
<p>由于 AOF 文件会随着写操作的增加而不断增长，为了解决这个问题， Redis 提供了重写机制来对 AOF 文件进行压缩和优化。
<img decoding="async" loading="lazy" alt="1756684639798" src="/doc/assets/images/1756684639798-978dc76e388670e164c74e574f08ec6c.png" width="3970" height="1080" class="img_ev3q"></p>
<p>AOF 重写可以通过两种方式触发，第一种是手动执行 BGREWRITEAOF 命令，适用于需要立即减小AOF文件大小的场景。
第二种是在 Redis 配置文件中设置自动重写参数，比如说 auto-aof-rewrite-percentage 和 auto-aof-rewrite-min-size，表示当 AOF 文件大小超过指定值时，自动触发重写。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">auto-aof-rewrite-percentage 100  # 默认值100，表示当前AOF文件大小相比上次重写后大小增长了多少百分比时触发重写</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">auto-aof-rewrite-min-size 64mb  # 默认值64MB，表示AOF文件至少要达到这个大小才会考虑重写</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="aof-重写的具体过程是怎样的">AOF 重写的具体过程是怎样的？<a href="#aof-重写的具体过程是怎样的" class="hash-link" aria-label="Direct link to AOF 重写的具体过程是怎样的？" title="Direct link to AOF 重写的具体过程是怎样的？">​</a></h3>
<p>Redis 在收到重写指令后，会创建一个子进程，并 fork 一份与父进程完全相同的数据副本，然后遍历内存中的所有键值对，生成重建它们所需的最少命令。
<img decoding="async" loading="lazy" alt="1756684702329" src="/doc/assets/images/1756684702329-a9a1d0a3baf8743347a15c799f87bda2.png" width="1158" height="642" class="img_ev3q">
比如说多个 RPUSH 命令可以合并为一个带有多个参数的 RPUSH；</p>
<p>比如说一个键被设置后又被删除，这个键的所有操作都不会被写入新 AOF。</p>
<p>比如说使用 SADD key member1 member2 member3 代替多个单独的 SADD key memberX。</p>
<p>子进程在执行 AOF 重写的同时，主进程可以继续处理来自客户端的命令。</p>
<p>为了保证数据一致性，Redis 使用了 AOF 重写缓冲区机制，主进程在执行写操作时，会将命令同时写入旧的 AOF 文件和重写缓冲区。</p>
<p>等子进程完成重写后，会向主进程发送一个信号，主进程收到后将重写缓冲区中的命令追加到新的 AOF 文件中，然后调用操作系统的 rename，将旧的 AOF 文件替换为新的 AOF 文件。</p>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">主进程（fork）  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├─→ 子进程（生成新的 AOF 文件）  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │       │  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │       ├─→ 内存快照  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │       ├─→ 写入临时 AOF 文件  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │       ├─→ 通知主进程完成  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├─→ 主进程（追加缓冲区到新 AOF 文件）  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├─→ 替换旧 AOF 文件  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├─→ 重写完成</span><br></span></code></pre></div></div>
<p>AOF 重写期间，Redis 服务器会处于特殊状态：
aof_child_pid 不为 0，表示有子进程在执行 AOF 重写
aof_rewrite_buf_blocks 链表不为空，存储 AOF 重写缓冲区内容
如果在配置文件中设置 no-appendfsync-on-rewrite 为 yes，那么重写期间可能会暂停 AOF 文件的 fsync 操作。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="aof-文件存储的是什么类型的数据">AOF 文件存储的是什么类型的数据？<a href="#aof-文件存储的是什么类型的数据" class="hash-link" aria-label="Direct link to AOF 文件存储的是什么类型的数据？" title="Direct link to AOF 文件存储的是什么类型的数据？">​</a></h3>
<p>AOF 文件存储的是 Redis 服务器接收到的写命令数据，以 Redis 协议格式保存。</p>
<p>这种格式的特点是，每个命令以*开头，后跟参数的数量，每个参数前用$符号，后跟参数字节长度，然后是参数的实际内容。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="aof重写期间命令可能会写入两次会造成什么影响">AOF重写期间命令可能会写入两次，会造成什么影响？<a href="#aof重写期间命令可能会写入两次会造成什么影响" class="hash-link" aria-label="Direct link to AOF重写期间命令可能会写入两次，会造成什么影响？" title="Direct link to AOF重写期间命令可能会写入两次，会造成什么影响？">​</a></h3>
<p>AOF 重写期间命令会同时写入现有AOF文件和重写缓冲区，这种机制是有意设计的，并不会导致数据重复或不一致问题。
<img decoding="async" loading="lazy" alt="1756684860111" src="/doc/assets/images/1756684860111-394f63484c27d13e89ee49a27bbcd117.png" width="900" height="466" class="img_ev3q">
因为新旧文件是分离的，现有命令写入当前 AOF 文件，重写缓冲区的命令最终写入新的 AOF 文件，完成后，新文件通过原子性的 rename 操作替换旧文件。两个文件是完全分离的，不会导致同一个 AOF 文件中出现重复命令。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="rdb-和-aof-各自有什么优缺点">RDB 和 AOF 各自有什么优缺点？<a href="#rdb-和-aof-各自有什么优缺点" class="hash-link" aria-label="Direct link to RDB 和 AOF 各自有什么优缺点？" title="Direct link to RDB 和 AOF 各自有什么优缺点？">​</a></h3>
<p>RDB 通过 fork 子进程在特定时间点对内存数据进行全量备份，生成二进制格式的快照文件。其最大优势在于备份恢复效率高，文件紧凑，恢复速度快，适合大规模数据的备份和迁移场景。</p>
<p>缺点是可能丢失两次快照期间的所有数据变更。
<img decoding="async" loading="lazy" alt="1756684935119" src="/doc/assets/images/1756684935119-c9bc1f19c8a0fddd5032003a7e26b15d.png" width="1600" height="332" class="img_ev3q"></p>
<p>AOF 会记录每一条修改数据的写命令。这种日志追加的方式让 AOF 能够提供接近实时的数据备份，数据丢失风险可以控制在 1 秒内甚至完全避免。</p>
<p>缺点是文件体积较大，恢复速度慢。</p>
<p>来个表格对比一下：
waitx</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="rdb-和-aof-如何选择">RDB 和 AOF 如何选择？<a href="#rdb-和-aof-如何选择" class="hash-link" aria-label="Direct link to RDB 和 AOF 如何选择？" title="Direct link to RDB 和 AOF 如何选择？">​</a></h3>
<p>在选择 Redis 持久化方案时，我会从业务需求和技术特性两个维度来考虑。</p>
<p>如果是缓存场景，可以接受一定程度的数据丢失，我会倾向于选择 RDB 或者完全不使用持久化。RDB 的快照方式对性能影响小，而且恢复速度快，非常适合这类场景。
<img decoding="async" loading="lazy" alt="1756684999300" src="/doc/assets/images/1756684999300-f37aa99899374b258038238d07068adf.png" width="2750" height="1631" class="img_ev3q"></p>
<p>但如果是处理订单或者支付这样的核心业务，数据丢失将造成严重后果，那么 AOF 就成为必然选择。通过配置每秒同步一次，可以将潜在的数据丢失风险限制在可接受范围内。
<img decoding="async" loading="lazy" alt="1756685011005" src="/doc/assets/images/1756685011005-1bdb928205827ed687e43ffa9e99171f.png" width="2176" height="1582" class="img_ev3q"></p>
<p>在实际的项目当中，我更偏向于使用 RDB + AOF 的混合模式。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis如何恢复数据">Redis如何恢复数据？<a href="#redis如何恢复数据" class="hash-link" aria-label="Direct link to Redis如何恢复数据？" title="Direct link to Redis如何恢复数据？">​</a></h3>
<p>当 Redis 服务重启时，它会优先查找 AOF 文件，如果存在就通过重放其中的命令来恢复数据；如果不存在或未启用 AOF，则会尝试加载 RDB 文件，直接将二进制数据载入内存来恢复。
<img decoding="async" loading="lazy" alt="1756685033216" src="/doc/assets/images/1756685033216-7d6a1b2332a54d4697c07abb454fa4e4.png" width="772" height="512" class="img_ev3q">
如果 AOF 文件损坏的话，Redis 会尝试通过 redis-check-aof 工具来修复 AOF 文件，或者直接使用 --repair 参数来修复。
虽然 Redis 还提供了 redis-check-rdb 工具来检查 RDB 文件的完整性，但它并不支持修复 RDB 文件，只能用来验证文件的完整性。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis-40-的混合持久化了解吗">🌟Redis 4.0 的混合持久化了解吗？<a href="#redis-40-的混合持久化了解吗" class="hash-link" aria-label="Direct link to 🌟Redis 4.0 的混合持久化了解吗？" title="Direct link to 🌟Redis 4.0 的混合持久化了解吗？">​</a></h3>
<p>混合持久化结合了 RDB 和 AOF 两种方式的优点，解决了它们各自的不足。在 Redis 4.0 之前，我们要么面临 RDB 可能丢失数据的风险，要么承受 AOF 恢复慢的问题，很难两全其美。</p>
<p>混合持久化的工作原理非常巧妙：在 AOF 重写期间，先以 RDB 格式将内存中的数据快照保存到 AOF 文件的开头，再将重写期间的命令以 AOF 格式追加到文件末尾。
<img decoding="async" loading="lazy" alt="1756685081098" src="/doc/assets/images/1756685081098-8efce89ee39026fe0ab8958a47a8092d.png" width="664" height="327" class="img_ev3q">
这样，当需要恢复数据时，Redis 先加载 RDB 格式的数据来快速恢复大部分的数据，然后通过重放命令恢复最近的数据，这样就能在保证数据完整性的同时，提升恢复速度。
如何设置持久化模式？
启用混合持久化的方式非常简单，只需要在配置文件中设置 aof-use-rdb-preamble yes 就可以了。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="你在开发中是怎么配置-rdb-和-aof-的">你在开发中是怎么配置 RDB 和 AOF 的？<a href="#你在开发中是怎么配置-rdb-和-aof-的" class="hash-link" aria-label="Direct link to 你在开发中是怎么配置 RDB 和 AOF 的？" title="Direct link to 你在开发中是怎么配置 RDB 和 AOF 的？">​</a></h3>
<p>对于大多数生产环境，我倾向于使用混合持久化方式，结合 RDB 和 AOF 的优点。</p>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># 启用AOF</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">appendonly yes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 使用混合持久化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">aof-use-rdb-preamble yes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 每秒同步一次AOF，平衡性能和安全性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">appendfsync everysec</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># AOF重写触发条件：文件增长100%且至少达到64MB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">auto-aof-rewrite-percentage 100</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">auto-aof-rewrite-min-size 64mb</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># RDB备份策略</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">save 900 1    # 15分钟内有1个修改</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">save 300 10   # 5分钟内有10个修改</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">save 60 10000 # 1分钟内有10000个修改</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="对于单纯的缓存场景或者本地开发我会只启用-rdb关闭-aof">对于单纯的缓存场景，或者本地开发，我会只启用 RDB，关闭 AOF：<a href="#对于单纯的缓存场景或者本地开发我会只启用-rdb关闭-aof" class="hash-link" aria-label="Direct link to 对于单纯的缓存场景，或者本地开发，我会只启用 RDB，关闭 AOF：" title="Direct link to 对于单纯的缓存场景，或者本地开发，我会只启用 RDB，关闭 AOF：">​</a></h3>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># 禁用AOF</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">appendonly no</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 较宽松的RDB策略</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">save 3600 1    # 1小时内有1个修改</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">save 300 100   # 5分钟内有100个修改</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="而对于金融类等高一致性的系统我通常会在关键时间窗口动态将-appendfsync-设置为-always">而对于金融类等高一致性的系统，我通常会在关键时间窗口动态将 appendfsync 设置为 always：<a href="#而对于金融类等高一致性的系统我通常会在关键时间窗口动态将-appendfsync-设置为-always" class="hash-link" aria-label="Direct link to 而对于金融类等高一致性的系统，我通常会在关键时间窗口动态将 appendfsync 设置为 always：" title="Direct link to 而对于金融类等高一致性的系统，我通常会在关键时间窗口动态将 appendfsync 设置为 always：">​</a></h3>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># 启用AOF</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">appendonly yes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 使用混合持久化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">aof-use-rdb-preamble yes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 每个命令都同步（谨慎使用，性能影响大）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 通常我会在关键时间窗口动态修改为always</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">appendfsync always</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 更频繁的RDB快照</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">save 300 1     # 5分钟内有1个修改</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">save 60 100    # 1分钟内有100个修改</span><br></span></code></pre></div></div>
<p>另外，对于高并发场景，应该设置no-appendfsync-on-rewrite yes，避免 AOF 重写影响主进程性能；对于大型实例，也应该设置 rdb-save-incremental-fsync yes 来减少大型 RDB 保存对性能的影响。</p>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># AOF重写期间不fsync，AOF 重写期间，主进程不会对新写入的 AOF 缓冲区执行 fsync 操作（即不强制刷盘），而是等重写结束后再统一刷盘。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">no-appendfsync-on-rewrite yes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># RDB 快照保存时采用增量 fsync，即每写入一定量的数据就执行一次 fsync，将数据分批同步到磁盘。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rdb-save-incremental-fsync yes</span><br></span></code></pre></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="高可用">高可用<a href="#高可用" class="hash-link" aria-label="Direct link to 高可用" title="Direct link to 高可用">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="主从复制了解吗">主从复制了解吗？<a href="#主从复制了解吗" class="hash-link" aria-label="Direct link to 主从复制了解吗？" title="Direct link to 主从复制了解吗？">​</a></h3>
<p>主从复制允许从节点维护主节点的数据副本。在这种架构中，一个主节点可以连接多个从节点，从而形成一主多从的结构。主节点负责处理写操作，从节点自动同步主节点的数据变更，并处理读请求，从而实现读写分离。
<img decoding="async" loading="lazy" alt="img_19.png" src="/doc/assets/images/img_19-e2f741ef8d6ad8decaecdac12c564719.png" width="839" height="385" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="主从复制的主要作用是什么">主从复制的主要作用是什么?<a href="#主从复制的主要作用是什么" class="hash-link" aria-label="Direct link to 主从复制的主要作用是什么?" title="Direct link to 主从复制的主要作用是什么?">​</a></h3>
<p>第一，主节点负责处理写请求，从节点负责处理读请求，从而实现读写分离，减轻主节点压力的同时提升系统的并发能力。
<img decoding="async" loading="lazy" alt="img_20.png" src="/doc/assets/images/img_20-304a9d3c51c04026fb2596d6cfb4d8eb.png" width="3543" height="1791" class="img_ev3q">
第二，从节点可以作为主节点的数据备份，当主节点发生故障时，可以快速将从节点提升为新的主节点，从而保证系统的高可用性。
<img decoding="async" loading="lazy" alt="img_21.png" src="/doc/assets/images/img_21-3ae9673ec5f3a7c9772dd95ab807e900.png" width="1041" height="922" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么情况下会出现主从复制数据不一致">什么情况下会出现主从复制数据不一致？<a href="#什么情况下会出现主从复制数据不一致" class="hash-link" aria-label="Direct link to 什么情况下会出现主从复制数据不一致？" title="Direct link to 什么情况下会出现主从复制数据不一致？">​</a></h3>
<p>Redis 的主从复制是异步进行的，因此在主节点宕机、网络波动或复制延迟较高时会出现从节点数据不同步的情况。
<img decoding="async" loading="lazy" alt="img_22.png" src="/doc/assets/images/img_22-b34b88f38285300421eb2b91ed692a55.png" width="1580" height="1512" class="img_ev3q">
比如主节点写入数据后宕机，但从节点还未来得及复制，就会出现数据不一致。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">时间线：→</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">客户端  →  向主节点 SET user:1 二哥     →  主节点处理成功 ✅</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            ↓</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          正准备推送给从节点（异步复制）... 但还没推送完 ❌</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            ↓</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  —— 突然主节点宕机（机器死机、断网） 💥 ——</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            ↓</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          Sentinel 监测到故障，failover：将从节点提升为新主节点 🧠</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            ↓</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">客户端继续请求：GET user:1 ❓→ 从节点返回：空 ❌（数据没同步过来）</span><br></span></code></pre></div></div>
<p>另一个容易被忽视的因素是主节点内存压力。当主节点内存接近上限并启用了淘汰策略时，某些键可能被自动删除，而这些删除操作如果未能及时同步，就会造成从节点保留了主节点已经不存在的数据。
<img decoding="async" loading="lazy" alt="img_23.png" src="/doc/assets/images/img_23-466d4a231812eafad5de0afd3bd59639.png" width="1958" height="832" class="img_ev3q">
主从复制数据不一致的解决方案有哪些？
首先是网络层面的优化，理想情况下，主从节点应该部署在同一个网络区域内，避免跨区域的网络延迟。</p>
<p>其次是配置层面的调整，比如说适当增大复制积压缓冲区的大小和存活时间，以便从节点重连后进行增量同步而不是全量同步，以最大程度减少主从同步的延迟。</p>
<p>第三是引入监控和自动修复机制，定期检查主从节点的数据一致性。</p>
<p>比如说通过比较主从的 offset 差值判断从库是否落后。一旦超过设定阈值，就将从节点剔除，并重新进行全量同步。
<img decoding="async" loading="lazy" alt="img_24.png" src="/doc/assets/images/img_24-8968e9dde731f72d1b46e0dbfda5de1d.png" width="3000" height="2048" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis主从有几种常见的拓扑结构">Redis主从有几种常见的拓扑结构？<a href="#redis主从有几种常见的拓扑结构" class="hash-link" aria-label="Direct link to Redis主从有几种常见的拓扑结构？" title="Direct link to Redis主从有几种常见的拓扑结构？">​</a></h3>
<p>主要有三种。</p>
<p>最基础的是一主一从，这种模式适合小型项目。一个主节点负责写入，一个从节点负责读和数据备份。这种结构虽然简单，但维护成本低。
随着业务增长，读请求增多，可以考虑扩展为一主多从结构。主节点负责写入，多个从节点还可以分摊压力。
<img decoding="async" loading="lazy" alt="img_25.png" src="/doc/assets/images/img_25-c05a7e9242e0f3509d90750973560b83.png" width="619" height="322" class="img_ev3q">
在跨地域部署场景中，树状主从结构可以有效降低主节点负载和需要传送给从节点的数据量。通过引入复制中间层，从节点不仅可以复制主节点数据，同时可以作为其他从节点的主节点继续向下层复制。
<img decoding="async" loading="lazy" alt="img_26.png" src="/doc/assets/images/img_26-bc2885aa2f56cf204c16f760c7edc16c.png" width="549" height="446" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis的主从复制原理了解吗">Redis的主从复制原理了解吗？<a href="#redis的主从复制原理了解吗" class="hash-link" aria-label="Direct link to Redis的主从复制原理了解吗？" title="Direct link to Redis的主从复制原理了解吗？">​</a></h3>
<p>Redis 的主从复制是指通过异步复制将主节点的数据变更同步到从节点，从而实现数据备份和读写分离。这个过程大致可以分为三个阶段：建立连接、同步数据和传播命令。
<img decoding="async" loading="lazy" alt="img_27.png" src="/doc/assets/images/img_27-23b00c888bbd3865249f5992b1e6e81c.png" width="3765" height="1676" class="img_ev3q">
\在建立连接阶段，从节点通过执行 replicaof 命令连接到主节点。连接建立后，从节点向主节点发送 psync 命令，请求数据同步。这时主节点会为该从节点创建一个连接和复制缓冲区。
<img decoding="async" loading="lazy" alt="img_28.png" src="/doc/assets/images/img_28-e61778c20fe851b2aa9359d102768503.png" width="1242" height="894" class="img_ev3q">
同步数据阶段分为全量同步和增量同步。当从节点首次连接主节点时，会触发全量同步。
<img decoding="async" loading="lazy" alt="img_29.png" src="/doc/assets/images/img_29-d8d0807cff188f2cfd7c36585b2942d2.png" width="1484" height="1538" class="img_ev3q">
在这个过程中，主节点会 fork 一个子进程生成 RDB 文件，同时将文件生成期间收到的写命令缓存到复制缓冲区。然后将 RDB 文件发送给从节点，从节点清空自己的数据并加载这个 RDB 文件。等 RDB 传输完成后，主节点再将缓存的写命令发送给从节点执行，确保数据完全一致。
<img decoding="async" loading="lazy" alt="img_30.png" src="/doc/assets/images/img_30-a2ff8c769a968685d77f2ae2edec9f66.png" width="1156" height="589" class="img_ev3q">
主从完成全量同步后，主要依靠传播命令阶段来保持数据的增量同步。主节点会将每次执行的写命令实时发送给所有从节点
<img decoding="async" loading="lazy" alt="img_31.png" src="/doc/assets/images/img_31-6510473b71566cc5f6f49cc68d10a616.png" width="2462" height="1438" class="img_ev3q">
Redis 2.8 版本后，主节点会为每个从节点维护一个复制积压缓冲区，用于存储最近的写命令。
<img decoding="async" loading="lazy" alt="img_32.png" src="/doc/assets/images/img_32-d1956ea7e626cd3d58138968b39530aa.png" width="628" height="479" class="img_ev3q"></p>
<p>增量复制时，主节点会把要同步的写命令暂存一份到复制积压缓冲区。这样当从节点和主节点发生网络断连，从节点重新连接后，可以从复制积压缓冲区中复制尚未同步的写命令。
<img decoding="async" loading="lazy" alt="img_33.png" src="/doc/assets/images/img_33-45f79f037cc4e7f964644da555be148e.png" width="1016" height="810" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="详细说说全量同步和增量同步">详细说说全量同步和增量同步？<a href="#详细说说全量同步和增量同步" class="hash-link" aria-label="Direct link to 详细说说全量同步和增量同步？" title="Direct link to 详细说说全量同步和增量同步？">​</a></h3>
<p>全量同步会将主节点的完整数据集传输给从节点，通常发生在从节点首次连接主节点时。</p>
<p><img decoding="async" loading="lazy" alt="img_34.png" src="/doc/assets/images/img_34-7f45aa3a5cdccda94d9ab1c18276afab.png" width="769" height="787" class="img_ev3q">
此时，从节点发送 psync ? -1 命令请求同步。? 表示从节点没有主节点 ID，-1 表示没有偏移量。主节点收到后会回复 FULLRESYNC响应从节点。同时也会包含主库 runid 和复制偏移量 offset 两个参数。</p>
<p>然后 fork 一个子进程生成 RDB 文件，并将新的写命令存入复制缓冲区。</p>
<p>从库收到 RDB 文件后，清空旧数据并加载新的 RDB 文件。加载完成后，从节点会向主节点回复确认消息，主节点再将复制缓冲区中的数据发送给从节点，确保从节点的数据与主节点一致。</p>
<p>全量同步的代价很高，因为完整的 RDB 文件在生成时会占用大量的 CPU 和磁盘 IO；在网络传输时还会消耗掉不少带宽。</p>
<p>于是 Redis 在 2.8 版本后引入了增量同步的概念，目的是在断线重连后避免全量同步。</p>
<p>增量依赖三个关键要素：</p>
<p>①、复制偏移量：主从节点分别维护一个复制偏移量，记录传输的字节数。主节点每传输 N 个字节数据，自身的复制偏移量就会增加 N；从节点每收到 N 个字节数据，也会相应增加自己的偏移量。</p>
<p>②、主节点 ID：每个主节点都有一个唯一 ID，即复制 ID，用于标识主节点的数据版本。当主节点发生重启或者角色变化时，ID 会改变。</p>
<p>③、复制积压缓冲区：主节点维护的一个固定长度的先进先出队列，默认大小为 1M。主节点在向从节点发送命令的同时，也会将命令写入这个缓冲区。</p>
<p>当从节点与主节点断开重连后，会发送 psync runId offset 命令，带上之前记录的主节点 ID 和复制偏移量。
<img decoding="async" loading="lazy" alt="img_35.png" src="/doc/assets/images/img_35-2bec154ed9292068da9f4d4ea558a217.png" width="850" height="445" class="img_ev3q">
主节点收到这个命令后，会检查 runId 和 offset：</p>
<p>如果主节点 ID 与从节点提供的 runId 不匹配，说明主节点已经变化，必须进行全量同步。</p>
<p>如果 ID 匹配，主节点会查找从节点请求的偏移量之后的数据是否还在复制积压缓冲区。</p>
<p>如果在，只发送从该偏移量开始的增量数据，这就是增量同步；否则说明断线时间太长，积压缓冲区已经覆盖了这部分数据，需要全量同步。
<img decoding="async" loading="lazy" alt="img_36.png" src="/doc/assets/images/img_36-a4a193c66fe871632ccdbf32ab8cfbfa.png" width="1080" height="624" class="img_ev3q">
增量同步的优势显而易见：只传输断线期间的命令数据，大大减少了网络传输量和主从节点的负载，从节点也不需要清空重载数据，能更快地跟上主节点状态。</p>
<p>对于写入频繁或网络不稳定的环境，应该增大复制积压缓冲区的大小，确保短时间断线后能进行增量同步而不是全量同步。</p>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">repl-backlog-size 1mb  # 默认值 1MB，表示主节点的复制缓冲区大小</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">repl-backlog-ttl 3600  # 默认值 3600 秒，表示主节点的复制缓冲区存活时间</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="主从复制存在哪些问题呢">主从复制存在哪些问题呢？<a href="#主从复制存在哪些问题呢" class="hash-link" aria-label="Direct link to 主从复制存在哪些问题呢？" title="Direct link to 主从复制存在哪些问题呢？">​</a></h3>
<p>Redis 主从复制的最大挑战来自于它的异步特性，主节点处理完写命令后会立即响应客户端，而不会等待从节点确认，这就导致在某些情况下可能出现数据不一致。</p>
<p><img decoding="async" loading="lazy" alt="img_37.png" src="/doc/assets/images/img_37-8be30df62b1b542841fa118e191e472f.png" width="1344" height="512" class="img_ev3q">
另一个常见问题是全量同步对系统的冲击。全量同步会占用大量的 CPU 和 IO 资源，尤其是在大数据量的情况下，会导致主节点的性能下降。</p>
<p>脑裂问题了解吗？
在 Redis 的哨兵架构中，脑裂的典型表现为：主节点与哨兵、从节点之间的网络发生故障了，但与客户端的连接是正常的，就会出现两个“主节点”同时对外提供服务。</p>
<p>哨兵认为主节点已经下线了，于是会将一个从节点选举为新的主节点。但原主节点并不知情，仍然在继续处理客户端的请求。
<img decoding="async" loading="lazy" alt="img_38.png" src="/doc/assets/images/img_38-9a73a0bfaeab8dedc0b52c3765b3fc5f.png" width="1913" height="1197" class="img_ev3q">
等主节点网络恢复正常了，发现已经有新的主节点了，于是原主节点会自动降级为从节点。在降级过程中，它需要与新主节点进行全量同步，此时原主节点的数据会被清空。导致客户端在原主节点故障期间写入的数据全部丢失。</p>
<p><img decoding="async" loading="lazy" alt="img_39.png" src="/doc/assets/images/img_39-9d1d3c11b246a681228fedd2904b5a0f.png" width="2671" height="1872" class="img_ev3q">
<img decoding="async" loading="lazy" alt="img_40.png" src="/doc/assets/images/img_40-9d1d3c11b246a681228fedd2904b5a0f.png" width="2671" height="1872" class="img_ev3q">
为了防止这种数据丢失，Redis 提供了 min-slaves-to-write 和 min-slaves-max-lag 参数。</p>
<p>这两个参数可以设置最少需要多少个从节点在线，以及从节点的最大延迟时间。</p>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># 设置主节点能进行数据同步的最少从节点数量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">min-slaves-to-write 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 设置主从节点间进行数据同步时，从节点给主节点发送 ACK 消息的最大延迟（以秒为单位）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">min-slaves-max-lag 10</span><br></span></code></pre></div></div>
<p>设置这两个参数后，如果主节点连接不到指定数量的从节点，或者从节点响应超时，主节点会拒绝写入请求，从而避免脑裂期间的数据冲突。</p>
<p>具体来说，当网络分区发生，主节点与从节点、哨兵之间的连接断开，但主节点与客户端的连接正常时，由于主节点无法再连接到任何从节点，或者延迟超过了设定值，比如说配置了min-slaves-to-write 1，主节点就会自动拒绝所有写请求。</p>
<p>同时在网络的另一侧，哨兵会检测到主节点&quot;下线&quot;，选举一个从节点成为新的主节点。由于原主节点已经停止接受写入，所以不会产生新的数据变更，等网络恢复后，即使原主节点降级为从节点并进行全量同步，也不会丢失网络分区期间的写入数据，因为根本就没有新的写入发生。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis哨兵机制了解吗">Redis哨兵机制了解吗？<a href="#redis哨兵机制了解吗" class="hash-link" aria-label="Direct link to Redis哨兵机制了解吗？" title="Direct link to Redis哨兵机制了解吗？">​</a></h3>
<p>Redis 中的哨兵用于监控主从集群的运行状态，并在主节点故障时自动进行故障转移。</p>
<p><img decoding="async" loading="lazy" alt="1756732135823" src="/doc/assets/images/1756732135823-1acf8d20fc844c38942880cbb6477d14.png" width="740" height="381" class="img_ev3q">
核心功能包括监控、通知和自动故障转移。哨兵会定期检查主从节点是否按预期工作，当检测到主节点故障时，就在从节点中选举出一个新的主节点，并通知客户端连接到新的主节点。</p>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># 监控的主节点信息 + 多少个哨兵同意才算宕机</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sentinel monitor mymaster 127.0.0.1 6379 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 多久不响应就标记为“主观下线”</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sentinel down-after-milliseconds mymaster 5000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 故障转移超时时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sentinel failover-timeout mymaster 60000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 同时允许多少个从节点同步新主节点数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sentinel parallel-syncs mymaster 1</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis哨兵的工作原理知道吗">Redis哨兵的工作原理知道吗？<a href="#redis哨兵的工作原理知道吗" class="hash-link" aria-label="Direct link to Redis哨兵的工作原理知道吗？" title="Direct link to Redis哨兵的工作原理知道吗？">​</a></h3>
<p>哨兵的工作原理可以概括为 4 个关键步骤：定时监控、主观下线、领导者选举和故障转移。</p>
<p>首先，哨兵会定期向所有 Redis 节点发送 PING 命令来检测它们是否可达。如果在指定时间内没有收到回复，哨兵会将该节点标记为“主观下线”。
<img decoding="async" loading="lazy" alt="1756732172001" src="/doc/assets/images/1756732172001-be7e31eff36ad3a51e2174a3099d11eb.png" width="1088" height="736" class="img_ev3q">
当一个哨兵判断主节点主观下线后，会询问其他哨兵的意见，如果达到配置的法定人数，主节点会被标记为“客观下线”。
<img decoding="async" loading="lazy" alt="1756732184761" src="/doc/assets/images/1756732184761-3b448516a610ffaa8336bc2f45299807.png" width="565" height="511" class="img_ev3q">
然后开始故障转移，这个过程中，哨兵会先选举出一个领导者，领导者再从从节点中选择一个最适合的节点作为新的主节点，选择标准包括复制偏移量、优先级等因素。
<img decoding="async" loading="lazy" alt="1756732196024" src="/doc/assets/images/1756732196024-a9cad428d559bcfa1f358eae148c74aa.png" width="1220" height="388" class="img_ev3q">
确定新主节点后，哨兵会向其发送 SLAVEOF NO ONE 命令使其升级为主节点，然后向其他从节点发送 SLAVEOF 命令指向新主节点，最后通过发布/订阅机制通知客户端主节点已经发生变化。
<img decoding="async" loading="lazy" alt="1756732204911" src="/doc/assets/images/1756732204911-d86a1c395b40bc83ec181aac50ce499e.png" width="1035" height="1555" class="img_ev3q"></p>
<p>在实际部署中，为了保证哨兵机制的可靠性，通常建议至少部署三个哨兵节点，并且这些节点应分布在不同的物理机器上，降低单点故障风险。
<img decoding="async" loading="lazy" alt="1756732229854" src="/doc/assets/images/1756732229854-9b4a9bc5ec5c77f37637249a4c50d733.png" width="2799" height="1727" class="img_ev3q">
同时，法定人数的设置也非常关键，一般建议设置为哨兵数量的一半加一，既能确保在少数哨兵故障时系统仍能正常工作，又能避免网络分区导致的脑裂问题。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis领导者选举了解吗">Redis领导者选举了解吗？<a href="#redis领导者选举了解吗" class="hash-link" aria-label="Direct link to Redis领导者选举了解吗？" title="Direct link to Redis领导者选举了解吗？">​</a></h3>
<p>Redis 使用 Raft 算法实现领导者选举，目的是在主节点故障时，选出一个哨兵来负责执行故障转移操作。
<img decoding="async" loading="lazy" alt="1756732303608" src="/doc/assets/images/1756732303608-a8973a33047ebcd629ba7724249fff82.png" width="1490" height="640" class="img_ev3q">
选举过程是这样的：</p>
<p>①、当一个哨兵确认主节点客观下线后，会向其他哨兵节点发送请求，表明希望由自己来执行主从切换，并让所有其他哨兵进行投票。候选者会先给自己先投 1 票，然后等待其他哨兵节点的投票结果。</p>
<div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">// sentinel.c中的sentinelAskMasterStateToOtherSentinels函数</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">sentinelAskMasterStateToOtherSentinels</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">sentinelRedisInstance </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">master</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dictIterator </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">di</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dictEntry </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">de</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    di </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">dictGetIterator</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">master</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">sentinels</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">while</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">de </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">dictNext</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">di</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">!=</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">NULL</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sentinelRedisInstance </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">sentinel </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">dictGetVal</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">de</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> retval</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token comment" style="color:#999988;font-style:italic">// 只有在进入领导者选举阶段才发送投票请求</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">master</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">failover_state </span><span class="token operator" style="color:#393A34">==</span><span class="token plain"> SENTINEL_FAILOVER_STATE_SELECT_LEADER</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><span class="token comment" style="color:#999988;font-style:italic">// 发送特殊的is-master-down-by-addr命令请求投票</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            retval </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">redisAsyncCommand</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">sentinel</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">cc</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                sentinelReceiveVoteFromSentinel</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> sentinel</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><span class="token string" style="color:#e3116c">&quot;SENTINEL is-master-down-by-addr %s %d %llu %s&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                master</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">addr</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">ip</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> master</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">addr</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">port</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">unsigned</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">long</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">long</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain">master</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">failover_epoch</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><span class="token comment" style="color:#999988;font-style:italic">// 这里发送自己的runid请求投票</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><span class="token function" style="color:#d73a49">sentinelGetMyRunID</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">else</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><span class="token comment" style="color:#999988;font-style:italic">// 否则只询问主节点状态，不请求投票</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            retval </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">redisAsyncCommand</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">sentinel</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">cc</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                sentinelReceiveIsMasterDownReply</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> sentinel</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><span class="token string" style="color:#e3116c">&quot;SENTINEL is-master-down-by-addr %s %d %llu *&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                master</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">addr</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">ip</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> master</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">addr</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">port</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">unsigned</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">long</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">long</span><span class="token punctuation" style="color:#393A34">)</span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token function" style="color:#d73a49">dictReleaseIterator</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">di</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre></div></div>
<p>②、收到请求的哨兵节点进行判断，如果候选者的日志和自己的一样新，任期号也小于自己，且之前没有投票过，就会投同意票 Y。否则回复 N。</p>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// sentinel.c中的sentinelCommand函数部分(处理SENTINEL命令)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 处理is-master-down-by-addr命令</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;is-master-down-by-addr&quot;)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* SENTINEL IS-MASTER-DOWN-BY-ADDR &lt;ip&gt; &lt;port&gt; &lt;current-epoch&gt; &lt;runid&gt; */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sentinelRedisInstance *ri;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char *master_ip = c-&gt;argv[2]-&gt;ptr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int master_port = atoi(c-&gt;argv[3]-&gt;ptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long long req_epoch = strtoull(c-&gt;argv[4]-&gt;ptr,NULL,10);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char *req_runid = c-&gt;argv[5]-&gt;ptr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int isdown = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char *leader = &quot;*&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long long leader_epoch = -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ri = sentinelGetMasterByAddress(master_ip, master_port);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ri) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        isdown = ri-&gt;flags &amp; SRI_S_DOWN;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 判断是否是投票请求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (req_runid[0] != &#x27;*&#x27;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 检查是否已经在当前配置纪元中投过票</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (req_epoch &gt; sentinel.current_epoch) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 更新自己的配置纪元</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                sentinel.current_epoch = req_epoch;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 如果我们觉得主节点下线了，且在这个epoch还没投过票，则投票</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (isdown &amp;&amp; sentinel.current_epoch == req_epoch &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                sentinel.leader_epoch &lt; req_epoch)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 记录投票信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                sentinel.leader_epoch = req_epoch;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                sentinel.leader = sdsnew(req_runid);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                leader = req_runid;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                leader_epoch = req_epoch;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 返回投票结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    addReplyMultiBulkLen(c,3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    addReplyLongLong(c, isdown);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    addReplyBulkCString(c, leader);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    addReplyLongLong(c, leader_epoch);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>③、候选者收到投票后会统计自己的得票数，如果获得了集群中超过半数节点的投票，它就会当选为领导者。</p>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// sentinel.c中的sentinelReceiveVoteFromSentinel函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void sentinelReceiveVoteFromSentinel(redisAsyncContext *c, void *reply, void *privdata) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sentinelRedisInstance *sentinel = privdata;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sentinelRedisInstance *master = sentinel-&gt;master;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    redisReply *r = reply;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char *leader = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 处理回复</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (r-&gt;type == REDIS_REPLY_ARRAY &amp;&amp; r-&gt;elements == 3) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 解析回复中的leader信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (r-&gt;element[1]-&gt;type == REDIS_REPLY_STRING)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            leader = r-&gt;element[1]-&gt;str;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 检查是否投给了我们</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (leader &amp;&amp; strcmp(leader, sentinelGetMyRunID()) == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 记录获得一票</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            dictAdd(master-&gt;sentinels_voted, sdsnew(sentinel-&gt;runid), sentinel);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 检查是否获得多数票</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (master-&gt;failover_state == SENTINEL_FAILOVER_STATE_SELECT_LEADER) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int voters = dictSize(master-&gt;sentinels) + 1; // +1是因为包括自己</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int votes = dictSize(master-&gt;sentinels_voted) + 1; // 自己也算一票</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果获得多数票(大于一半)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (votes &gt;= voters/2+1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 成为领导者，开始执行故障转移</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sentinelEvent(LL_WARNING, &quot;+elected-leader&quot;, master, &quot;%@&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            master-&gt;failover_state = SENTINEL_FAILOVER_STATE_FAILOVER_IN_PROGRESS;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sentinelFailoverSelectSlave(master);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>④、如果没有哨兵在这一轮投票中获得超过半数的选票，这次选举就会失败，然后进行下一轮的选举。为了防止无限制的选举失败，每个哨兵都会有一个选举超时时间，且是随机的。</p>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// sentinel.c中的sentinelFailoverSelectLeader函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void sentinelFailoverSelectLeader(sentinelRedisInstance *master) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 检查选举是否超时</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mstime_t election_timeout = SENTINEL_ELECTION_TIMEOUT * 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (mstime() - master-&gt;failover_start_time &gt; election_timeout) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 选举超时，重置状态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sentinelEvent(LL_WARNING, &quot;-failover-abort-timeout&quot;, master, &quot;%@&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sentinelAbortFailover(master);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ... 其他选举逻辑 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果没有足够票数且未超时，则继续等待</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>这里 SENTINEL_ELECTION_TIMEOUT_MIN 通常为 0，SENTINEL_ELECTION_TIMEOUT_MAX 通常为 2000 毫秒。这样每个哨兵会在 0-2 秒的随机时间后开始选举，减少选举冲突。
[Raft算法详解](<a href="https://hoverzheng.github.io/post/technology-blog/blockchain/" target="_blank" rel="noopener noreferrer">https://hoverzheng.github.io/post/technology-blog/blockchain/</a>
raft%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A33--%E9%80%89%E4%B8%BB/)</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="新的主节点是怎样被挑选出来的">新的主节点是怎样被挑选出来的？<a href="#新的主节点是怎样被挑选出来的" class="hash-link" aria-label="Direct link to 新的主节点是怎样被挑选出来的？" title="Direct link to 新的主节点是怎样被挑选出来的？">​</a></h3>
<p>哨兵在挑选新的主节点时，非常精细化。
<img decoding="async" loading="lazy" alt="1756732536934" src="/doc/assets/images/1756732536934-9e7bad0a9ae77cc7c4e82c5e6caeaa03.png" width="496" height="546" class="img_ev3q">
首先，哨兵会对所有从节点进行一轮基础筛选，排除那些不满足基本条件的节点。比如说已下线的节点、网络连接不稳定的节点，以及优先级设为 0 明确不参与挑选的节点。</p>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 第一轮筛选：排除不满足基本条件的从节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for (int i = 0; i &lt; numslaves; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sentinelRedisInstance *slave = slaves[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 排除已下线的从节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (slave-&gt;flags &amp; (SRI_S_DOWN|SRI_O_DOWN)) continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 排除断开连接的从节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (slave-&gt;link-&gt;disconnected) continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 排除近期（5秒内）断过连的从节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (mstime() - slave-&gt;link-&gt;last_avail_time &gt; 5000) continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 排除未建立主从复制的节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (slave-&gt;slave_priority == 0) continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 找到第一个满足条件的从节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    selected = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>然后，哨兵会对剩下的从节点进行排序，选出最合适的主节点。</p>
<div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">// sentinel.c中的compareSlaves函数</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">compareSlaves</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">sentinelRedisInstance </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">a</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> sentinelRedisInstance </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">b</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">// 1. 首先比较用户设置的优先级，值越小优先级越高</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">a</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">slave_priority </span><span class="token operator" style="color:#393A34">!=</span><span class="token plain"> b</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">slave_priority</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">return</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">a</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">slave_priority </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain"> b</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">slave_priority</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">?</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">2</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">// 2. 如果优先级相同，比较复制偏移量，偏移量越大数据越新</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">a</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">slave_repl_offset </span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> b</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">slave_repl_offset</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">return</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">else</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">a</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">slave_repl_offset </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain"> b</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">slave_repl_offset</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">return</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">2</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">// 3. 如果复制偏移量也相同，比较运行ID的字典序</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">return</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token function" style="color:#d73a49">strcmp</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">a</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">runid</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> b</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">runid</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">?</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">2</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre></div></div>
<p>排序的标准有三个：</p>
<p>①、从节点优先级： slave-priority 的值越小优先级越高，优先级为 0 的从节点不会被选中。</p>
<p>②、复制偏移量： 偏移量越大意味着从节点的数据越新，复制的越完整。</p>
<p>③、运行 ID： 如果优先级和偏移量都相同，就比较运行 ID 的字典序，字典序小的优先。</p>
<p>选出新主节点后，哨兵会向其发送 SLAVEOF NO ONE 命令将其提升为主节点。</p>
<div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">// sentinel.c中的sentinelFailoverPromoteSlave函数</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">sentinelFailoverPromoteSlave</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">sentinelRedisInstance </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">master</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">// ... 选择最佳从节点的逻辑 ...</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">// 向选中的从节点发送SLAVEOF NO ONE命令，使其成为主节点</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    retval </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">redisAsyncCommand</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">slave</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">link</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">cc</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sentinelReceivePromotionResponseFromSlave</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> master</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token string" style="color:#e3116c">&quot;SLAVEOF NO ONE&quot;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">// 更新状态</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    master</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">promoted_slave </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> slave</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    slave</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">flags </span><span class="token operator" style="color:#393A34">|=</span><span class="token plain"> SRI_PROMOTED</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">// 记录日志</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token function" style="color:#d73a49">sentinelEvent</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">LL_WARNING</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;+promoted-slave&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> slave</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;%@&quot;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token function" style="color:#d73a49">sentinelEvent</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">LL_WARNING</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;+failover-state-wait-promotion&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> master</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;%@&quot;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre></div></div>
<p>之后，哨兵会等待新主节点的角色转换完成，通过发送 INFO 命令检查其角色是否已变为 master 来确认。确认成功后，会更新所有从节点的复制目标，指向新的主节点。</p>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">SLAVEOF new-master-ip new-master-port</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis集群了解吗">Redis集群了解吗？<a href="#redis集群了解吗" class="hash-link" aria-label="Direct link to Redis集群了解吗？" title="Direct link to Redis集群了解吗？">​</a></h3>
<p>主从复制实现了读写分离和数据备份，哨兵机制实现了主节点故障时自动进行故障转移。
<img decoding="async" loading="lazy" alt="1756732617284" src="/doc/assets/images/1756732617284-d4ed351c1b4d666517f6ce8055348ec5.png" width="591" height="352" class="img_ev3q">
集群架构是对前两种方案的进一步扩展和完善，通过数据分片解决 Redis 单机内存大小的限制，当用户基数从百万增长到千万级别时，我们只需简单地向集群中添加节点，就能轻松应对不断增长的数据量和访问压力。</p>
<p>比如说我们可以将单实例模式下的数据平均分为 5 份，然后启动 5 个 Redis 实例，每个实例保存 5G 的数据，从而实现集群化。
<img decoding="async" loading="lazy" alt="1756732629550" src="/doc/assets/images/1756732629550-e335c04701f1b7227181df6d8bb993b4.png" width="1105" height="590" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="请详细说一说redis-cluster补充">请详细说一说Redis Cluster？（补充）<a href="#请详细说一说redis-cluster补充" class="hash-link" aria-label="Direct link to 请详细说一说Redis Cluster？（补充）" title="Direct link to 请详细说一说Redis Cluster？（补充）">​</a></h3>
<p>Redis Cluster 是 Redis 官方提供的一种分布式集群解决方案。其核心理念是去中心化，采用 P2P 模式，没有中心节点的概念。每个节点都保存着数据和整个集群的状态，节点之间通过 gossip 协议交换信息。
<img decoding="async" loading="lazy" alt="1756732709947" src="/doc/assets/images/1756732709947-a36ea9bd4e81ea7ce01d4f6a26e34180.png" width="1400" height="850" class="img_ev3q">
在数据分片方面，Redis Cluster 使用哈希槽机制将整个集群划分为 16384 个单元。
<img decoding="async" loading="lazy" alt="1756732723156" src="/doc/assets/images/1756732723156-4bc0615dbd72070feac694dfdb850a44.png" width="1400" height="880" class="img_ev3q">
例如，如果我们有 4 个 Redis 实例，那么每个实例会负责 4000 多个哈希槽。
<img decoding="async" loading="lazy" alt="1756732734101" src="/doc/assets/images/1756732734101-02f7ad9e53a97a5a19f76b928eae3066.png" width="1400" height="407" class="img_ev3q">
在计算哈希槽编号时，Redis Cluster 会通过 CRC16 算法先计算出键的哈希值，再对这个哈希值进行取模运算，得到一个 0 到 16383 之间的整数。
slot = CRC16(key) mod 16384
这种方式可以将数据均匀地分布到各个节点上，避免数据倾斜的问题。
<img decoding="async" loading="lazy" alt="1756732751217" src="/doc/assets/images/1756732751217-89e77affadbd701ce04e08d839cd9bc6.png" width="985" height="477" class="img_ev3q">
当需要存储或查询一个键值对时，Redis Cluster 会先计算这个键的哈希槽编号，然后根据哈希槽编号找到对应的节点进行操作。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="集群中数据如何分区">集群中数据如何分区？<a href="#集群中数据如何分区" class="hash-link" aria-label="Direct link to 集群中数据如何分区？" title="Direct link to 集群中数据如何分区？">​</a></h3>
<p>常见的数据分区有三种：节点取余、一致性哈希和哈希槽。</p>
<p>节点取余分区简单明了，通过计算键的哈希值，然后对节点数量取余，结果就是目标节点的索引。
target_node = hash(key) % N  // N为节点数量
<img decoding="async" loading="lazy" alt="1756732778273" src="/doc/assets/images/1756732778273-288ffe432104ad0b0ac8f9876a5544a8.png" width="695" height="261" class="img_ev3q">
缺点是增加一个新节点后，节点数量从 N 变为 N+1，几乎所有的取余结果都会改变，导致大部分缓存失效。</p>
<p>为了解决节点变化导致的大规模数据迁移问题，一致性哈希分区出现了：它将整个哈希值空间想象成一个环，节点和数据都映射到这个环上。数据被分配到顺时针方向上遇到的第一个节点。
<img decoding="async" loading="lazy" alt="1756732787402" src="/doc/assets/images/1756732787402-3130e798d2cfa2a0c6e93c327b210b7c.png" width="586" height="556" class="img_ev3q">
这种设计的巧妙之处在于，当节点数量变化时，只有部分数据需要重新分配。比如说我们从 5 个节点扩容到 8 个节点，理论上只有约 3/8 的数据需要迁移，大大减轻了扩容时的系统压力。</p>
<p>但一致性哈希仍然有一个问题：数据分布不均匀。比如说在上面的例子中，节点 1 和节点 2 的数据量差不多，但节点 3 的数据量却远远小于它们。</p>
<p>Redis Cluster 的哈希槽分区在一致性哈希和节点取余的基础上，做了一些改进。
<img decoding="async" loading="lazy" alt="1756732822490" src="/doc/assets/images/1756732822490-1a5cbdb9beb731d420c7926ac085af96.png" width="1400" height="1128" class="img_ev3q">
它将整个哈希值空间划分为 16384 个槽位，每个节点负责一部分槽，数据通过 CRC16 算法计算后对 16384 取模，确定它属于哪个槽。
slot = CRC16(key) % 16384
<img decoding="async" loading="lazy" alt="1756732834750" src="/doc/assets/images/1756732834750-e36fc5b42b726d7c33cd16b9097b7170.png" width="1400" height="921" class="img_ev3q">
假设系统中有 4 个节点，为其分配了 16 个槽(0-15)；</p>
<p>槽 0-3 位于节点 node1；
槽 4-7 位于节点 node2；
槽 8-11 位于节点 node3；
槽 12-15 位于节点 node4。
如果此时删除 node2，只需要将槽 4-7 重新分配即可，例如将槽 4-5 分配给 node1，槽 6 分配给 node3，槽 7 分配给 node4，数据在节点上的分布仍然较为均衡。</p>
<p>如果此时增加 node5，也只需要将一部分槽分配给 node5 即可，比如说将槽 3、槽 7、槽 11、槽 15 迁移给 node5，节点上的其他槽位保留。</p>
<p>因为槽的个数刚好是 2 的 14 次方，和 HashMap 中数组的长度必须是 2 的幂次方有着异曲同工之妙。它能保证扩容后，大部分数据停留在扩容前的位置，只有少部分数据需要迁移到新的槽上。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="能说说-redis-集群的原理吗">能说说 Redis 集群的原理吗？<a href="#能说说-redis-集群的原理吗" class="hash-link" aria-label="Direct link to 能说说 Redis 集群的原理吗？" title="Direct link to 能说说 Redis 集群的原理吗？">​</a></h3>
<p>Redis 集群的搭建始于节点的添加和握手。每个节点通过设置 cluster-enabled yes 来开启集群模式。然后通过 CLUSTER MEET 进行握手，将对方添加到各自的节点列表中。
<img decoding="async" loading="lazy" alt="1756732868180" src="/doc/assets/images/1756732868180-b0ba2efea7578021e6d4fdacf0e28a4f.png" width="813" height="327" class="img_ev3q">
这个过程设计的非常精巧：节点 A 发送 MEET 消息，节点 B 回复 PONG 并发送 PING，节点 A 回复 PONG，于是双向的通信链路就建立完成了。
<img decoding="async" loading="lazy" alt="1756732873364" src="/doc/assets/images/1756732873364-4f66ec10006803ebea30a9b64affabc5.png" width="1096" height="1285" class="img_ev3q">
有趣的是，由于采用了 Gossip 协议，我们不需要让每对节点都执行握手。在一个多节点集群的部署中，仅需要让第一个节点与其他节点握手，其余节点就能通过信息传播自动发现并连接彼此。
<img decoding="async" loading="lazy" alt="1756732898204" src="/doc/assets/images/1756732898204-d901c3ba8455305b626347cd3739d7aa.png" width="2732" height="1960" class="img_ev3q">
握手完成后，可以通过 CLUSTER ADDSLOTS 命令为主节点分配哈希槽。当 16384 个槽全部分配完毕，集群正式进入就绪状态。
<img decoding="async" loading="lazy" alt="1756732947178" src="/doc/assets/images/1756732947178-19c860ce4733dd56c3ab1b1daa84d03d.png" width="756" height="504" class="img_ev3q">
故障检测和恢复是保障 Redis 集群高可用的关键。每秒钟，节点会向一定数量的随机节点发送 PING 消息，当发现某个节点长时间未响应 PING 消息，就会将其标记为主观下线。
<img decoding="async" loading="lazy" alt="1756732973033" src="/doc/assets/images/1756732973033-37a167ab68990abf87124aa04ce124d6.png" width="491" height="225" class="img_ev3q">
当半数以上的主节点都认为某节点主观下线时，这个节点就会被标记为“客观下线”。
<img decoding="async" loading="lazy" alt="1756732983171" src="/doc/assets/images/1756732983171-dcdf8c8d692244d454dc8957dcbe369a.png" width="793" height="512" class="img_ev3q">
如果下线的是主节点，它的从节点之一将被选举为新的主节点，接管原主节点负责的哈希槽。
<img decoding="async" loading="lazy" alt="1756732994762" src="/doc/assets/images/1756732994762-ce6457f71825925ad0245f111ad7936a.png" width="779" height="400" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="部署-redis-集群至少需要几个物理节点">部署 Redis 集群至少需要几个物理节点？<a href="#部署-redis-集群至少需要几个物理节点" class="hash-link" aria-label="Direct link to 部署 Redis 集群至少需要几个物理节点？" title="Direct link to 部署 Redis 集群至少需要几个物理节点？">​</a></h3>
<p>部署一个生产环境可用的 Redis 集群，从技术角度来说，至少需要 3 个物理节点。</p>
<p>这个最小节点数的设定并非 Redis 技术上的硬性要求，而是基于高可用原则的实践考量。</p>
<p>从实践角度看，最经典的 Redis 集群配置是 3 主 3 从，共 6 个 Redis 实例。考虑到需要 3 个主节点和 3 个从节点，并且每对主从不能在同一物理机上，那么至少需要 3 个物理节点，每个物理节点上运行 1 个主节点和另一个主节点的从节点。</p>
<p>物理节点1：主节点A + 从节点B&#x27;
物理节点2：主节点B + 从节点C&#x27;
物理节点3：主节点C + 从节点A&#x27;
这种交错部署方式可以确保任何一个物理节点故障时，最多只影响一个主节点和一个不同主节点的从节点。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说说redis集群的动态伸缩">说说Redis集群的动态伸缩？<a href="#说说redis集群的动态伸缩" class="hash-link" aria-label="Direct link to 说说Redis集群的动态伸缩？" title="Direct link to 说说Redis集群的动态伸缩？">​</a></h3>
<p>Redis 集群动态伸缩的核心机制是通过重新分配哈希槽实现的。
<img decoding="async" loading="lazy" alt="1756733028439" src="/doc/assets/images/1756733028439-e049da8cc24e0f2f559b5228cdc48282.png" width="794" height="479" class="img_ev3q">
当需要扩容时，首先通过 CLUSTER MEET 命令将新节点加入集群；然后使用 reshard 命令将部分哈希槽重新分配给新节点。
<img decoding="async" loading="lazy" alt="1756733033386" src="/doc/assets/images/1756733033386-e049da8cc24e0f2f559b5228cdc48282.png" width="794" height="479" class="img_ev3q">
缩容则是反向操作：先将要下线节点负责的所有槽迁移到其他节点，再通过 CLUSTER FORGET 命令将节点从集群中移除。</p>
<p>整个伸缩过程支持在线操作，无需停机，得益于 Redis 集群的 MOVED 和 ASK 重定向机制。当客户端访问的键不在当前节点时，会收到重定向响应，指引它连接到正确的节点</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="moved-和-ask-重定向的区别">MOVED 和 ASK 重定向的区别？<a href="#moved-和-ask-重定向的区别" class="hash-link" aria-label="Direct link to MOVED 和 ASK 重定向的区别？" title="Direct link to MOVED 和 ASK 重定向的区别？">​</a></h3>
<p>MOVED 重定向反映的是哈希槽的永久性变更。当客户端请求一个键，但键所在的槽不在当前节点时，节点会返回 MOVED 响应，告诉客户端这个槽现在归属于哪个节点。通常发生在集群完成重新分片后，槽的分配关系已经稳定。
<img decoding="async" loading="lazy" alt="1756733078424" src="/doc/assets/images/1756733078424-ea9e14532da2167e63644b1734e89618.png" width="849" height="689" class="img_ev3q">
比如说某个槽从节点 A 移动到节点 B 后，如果客户端仍向节点 A 请求该槽中的键，会收到 MOVED 响应，提示应该连接节点 B。</p>
<p>ASK 重定向出现在槽迁移过程中，表示请求的键可能已经从源节点迁移到了目标节点，但迁移尚未完成。
<img decoding="async" loading="lazy" alt="1756733087675" src="/doc/assets/images/1756733087675-0807793dd16eebdb3e3524ffccd62180.png" width="1250" height="716" class="img_ev3q"></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="缓存设计">缓存设计<a href="#缓存设计" class="hash-link" aria-label="Direct link to 缓存设计" title="Direct link to 缓存设计">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是缓存击穿">🌟什么是缓存击穿？<a href="#什么是缓存击穿" class="hash-link" aria-label="Direct link to 🌟什么是缓存击穿？" title="Direct link to 🌟什么是缓存击穿？">​</a></h3>
<p>缓存击穿是指某个热点数据缓存过期时，大量请求就会穿透缓存直接访问数据库，导致数据库瞬间承受的压力巨大。
<img decoding="async" loading="lazy" alt="1756733132513" src="/doc/assets/images/1756733132513-96957625269a91868c22f4b9c6bec4f4.png" width="1890" height="1498" class="img_ev3q">
解决缓存击穿有两种常用的策略：</p>
<p>第一种是加互斥锁。当缓存失效时，第一个访问的线程先获取锁并负责重建缓存，其他线程等待或重试。
<img decoding="async" loading="lazy" alt="1756733143093" src="/doc/assets/images/1756733143093-193d7c6e9a9f7f7631a17830cb807525.png" width="395" height="514" class="img_ev3q">
这种策略虽然会导致部分请求延迟，但实现起来相对简单。在技术派实战项目中，我们就使用了 Redisson 的分布式锁来确保只有一个服务实例能更新缓存。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">String cacheKey = &quot;product::&quot; + productId;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">RLock lock = redissonClient.getLock(&quot;lock::&quot; + productId);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (lock.tryLock(10, TimeUnit.SECONDS)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String result = cache.get(cacheKey);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (result == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            result = database.queryProductById(productId);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            cache.set(cacheKey, result, 60 * 1000); // 设置缓存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lock.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>第二种是永不过期策略。缓存项本身不设置过期时间，也就是永不过期，但在缓存值中维护一个逻辑过期时间。当缓存逻辑上过期时，返回旧值的同时，异步启动一个线程去更新缓存。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public String getData(String key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    CacheItem item = cache.get(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (item == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 缓存不存在，同步加载</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String data = db.query(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cache.set(key, new CacheItem(data, System.currentTimeMillis() + expireTime));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else if (item.isLogicalExpired()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 逻辑过期，异步刷新</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        asyncRefresh(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 返回旧数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return item.getData();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return item.getData();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 异步刷新缓存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private void asyncRefresh(final String key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    threadPool.execute(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 重新查询数据库</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String newData = db.query(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 更新缓存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cache.set(key, new CacheItem(newData, System.currentTimeMillis() + expireTime));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是缓存穿透">什么是缓存穿透？<a href="#什么是缓存穿透" class="hash-link" aria-label="Direct link to 什么是缓存穿透？" title="Direct link to 什么是缓存穿透？">​</a></h3>
<p>缓存穿透是指查询的数据在缓存中没有命中，因为数据压根不存在，所以请求会直接落到数据库上。如果这种查询非常频繁，就会给数据库造成很大的压力。
<img decoding="async" loading="lazy" alt="1756733231061" src="/doc/assets/images/1756733231061-583f2cc5e180701679ac42dae2f4a7b7.png" width="1882" height="1390" class="img_ev3q">
缓存击穿是因为单个热点数据缓存失效导致的，而缓存穿透是因为查询的数据不存在，原因可能是自身的业务代码有问题，或者是恶意攻击造成的，比如爬虫。</p>
<p>常用的解决方案有两种：第一种是布隆过滤器，它是一种空间效率很高的数据结构，可以用来判断一个元素是否在集合中。</p>
<p>我们可以将所有可能存在的数据哈希到布隆过滤器中，查询时先检查布隆过滤器，如果布隆过滤器认为该数据不存在，就直接返回空；否则再去查询缓存，这样就可以避免无效的缓存查询。
<img decoding="async" loading="lazy" alt="1756733241315" src="/doc/assets/images/1756733241315-6cd6680bb45b94d5d7e19c7fe26da01e.png" width="439" height="574" class="img_ev3q"></p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public String getData(String key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 缓存中不存在该key</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String cacheResult = cache.get(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (cacheResult != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return cacheResult;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 布隆过滤器判断key是否可能存在</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!bloomFilter.mightContain(key)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return null; // 一定不存在，直接返回</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 可能存在，查询数据库</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String dbResult = db.query(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 将结果放入缓存，包括空值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    cache.set(key, dbResult != null ? dbResult : &quot;&quot;, expireTime);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return dbResult;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>布隆过滤器存在误判，即可能会认为某个数据存在，但实际上并不存在。但绝不会漏判，即如果布隆过滤器认为某个数据不存在，那它一定不存在。因此它可以有效拦截不存在的数据查询，减轻数据库压力。</p>
<p>第二种是缓存空值。对于不存在的数据，我们将空值写入缓存，并设置一个合理的过期时间。这样下次相同的查询就能直接从缓存返回，而不再访问数据库。
<img decoding="async" loading="lazy" alt="1756733314451" src="/doc/assets/images/1756733314451-501bf7ef9044857955fdba365c539062.png" width="369" height="503" class="img_ev3q"></p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public String getData(String key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String cacheResult = cache.get(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 缓存命中，包括空值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (cacheResult != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 特殊值表示空结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (cacheResult.equals(&quot;&quot;)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return cacheResult;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 缓存未命中，查询数据库</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String dbResult = db.query(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 写入缓存，空值也缓存，但设置较短的过期时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int expireTime = dbResult == null ? EMPTY_EXPIRE_TIME : NORMAL_EXPIRE_TIME;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    cache.set(key, dbResult != null ? dbResult : &quot;&quot;, expireTime);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return dbResult;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>缓存空值的方法实现起来比较简单，但需要给空值设置一个合理的过期时间，以免数据库中新增了这些数据后，缓存仍然返回空值。</p>
<p>在实际的项目当中，还需要在接口层面做一些处理，比如说对参数进行校验，拦截明显不合理的请求；或者对疑似攻击的 IP 进行限流和封禁。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是缓存雪崩">什么是缓存雪崩？<a href="#什么是缓存雪崩" class="hash-link" aria-label="Direct link to 什么是缓存雪崩？" title="Direct link to 什么是缓存雪崩？">​</a></h3>
<p>缓存雪崩是指在某一时间段，大量缓存同时失效或者缓存服务突然宕机了，导致大量请求直接涌向数据库，导致数据库压力剧增，甚至引发系统崩溃的现象。
<img decoding="async" loading="lazy" alt="1756733376024" src="/doc/assets/images/1756733376024-b76eb5cd347f1e9cccc947875a22dc39.png" width="827" height="498" class="img_ev3q">
缓存击穿是单个热点数据失效导致的，缓存穿透是因为请求不存在的数据，而缓存雪崩是因为大范围的缓存失效。</p>
<p>缓存雪崩主要有三种成因和应对策略。</p>
<p>第一种，大量缓存同时过期，解决方法是添加随机过期时间。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public void setCache(String key, String value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 基础过期时间，例如30分钟</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int baseExpireSeconds = 1800;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 增加随机过期时间，范围0-300秒</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int randomSeconds = new Random().nextInt(300);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 最终过期时间为基础时间加随机时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    cache.set(key, value, baseExpireSeconds + randomSeconds);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>第二种，缓存服务崩溃，解决方法是使用高可用的缓存集群。</p>
<p>比如说使用 Redis Cluster 构建多节点集群，确保数据在多个节点上有备份，并且支持自动故障转移。
<img decoding="async" loading="lazy" alt="1756733457972" src="/doc/assets/images/1756733457972-a36ea9bd4e81ea7ce01d4f6a26e34180.png" width="1400" height="850" class="img_ev3q">
对于一些高频关键数据，可以配置本地缓存作为二级缓存，缓解 Redis 的压力。在技术派实战项目中，我们就采用了多级缓存的策略，其中就包括使用本地缓存 Caffeine 来作为二级缓存，当 Redis 出现问题时自动切换到本地缓存。
这个过程称为“缓存降级”，保证 Redis 发生故障时，系统能够继续提供服务。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">LoadingCache&lt;String, UserPermissions&gt; permissionsCache = Caffeine.newBuilder()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .maximumSize(1000)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .expireAfterWrite(10, TimeUnit.MINUTES)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .build(this::loadPermissionsFromRedis);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public UserPermissions loadPermissionsFromRedis(String userId) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return redisClient.getPermissions(userId);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (Exception ex) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Redis 异常处理，尝试从本地缓存获取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return permissionsCache.getIfPresent(userId);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>第三种，缓存服务正常但并发请求量超过了缓存服务的承载能力，这种情况下可以采用限流和降级措施。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public String getData(String key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 尝试从缓存获取数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return cache.get(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 缓存服务异常，触发熔断</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (circuitBreaker.shouldTrip()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 直接从数据库获取，并进入降级模式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            circuitBreaker.trip();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return getFromDbDirectly(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private String getFromDbDirectly(String key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 实施限流保护</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!rateLimit.tryAcquire()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 超过限流阈值，返回兜底数据或默认值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return getDefaultValue(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 限流通过，从数据库查询</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return db.query(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="能说说布隆过滤器吗">🌟能说说布隆过滤器吗？<a href="#能说说布隆过滤器吗" class="hash-link" aria-label="Direct link to 🌟能说说布隆过滤器吗？" title="Direct link to 🌟能说说布隆过滤器吗？">​</a></h3>
<p>布隆过滤器是一种空间效率极高的概率性数据结构，用于快速判断一个元素是否在一个集合中。它的特点是能够以极小的内存消耗，判断一个元素“一定不在集合中”或“可能在集合中”，常用来解决 Redis 缓存穿透的问题。
<img decoding="async" loading="lazy" alt="1756733661312" src="/doc/assets/images/1756733661312-38833e1adfbe6d6893ea1ba701aea9c4.png" width="1126" height="284" class="img_ev3q">
----这部分面试中可以不背start----</p>
<p>布隆过滤器的核心由一个很长的二进制向量和一系列哈希函数组成。</p>
<p>初始化的时候，创建一个长度为 m 的位数组，初始值全为 0，同时选择 k 个不同的哈希函数
当添加一个元素时，用 k 个哈希函数计算出 k 个哈希值，然后对 m 取模，得到 k 个位置，将这些位置的二进制位都设为 1
当需要判断一个元素是否在集合中时，同样用 k 个哈希函数计算出 k 个位置，如果这些位置的二进制位有任何一个为 0，该元素一定不在集合中；如果全部为 1，则该元素可能在集合中</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class BloomFilter&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private BitSet bitSet;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int bitSetSize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int numberOfHashFunctions;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public BloomFilter(double falsePositiveProbability, int expectedNumberOfElements) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 根据预期元素数量和期望的误判率，计算最优的位数组大小和哈希函数个数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.bitSetSize = calculateOptimalBitSetSize(expectedNumberOfElements, falsePositiveProbability);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.numberOfHashFunctions = calculateOptimalNumberOfHashFunctions(expectedNumberOfElements, bitSetSize);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.bitSet = new BitSet(bitSetSize);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void add(T element) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[] hashes = createHashes(element);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int hash : hashes) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            bitSet.set(Math.abs(hash % bitSetSize), true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean mightContain(T element) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[] hashes = createHashes(element);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int hash : hashes) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!bitSet.get(Math.abs(hash % bitSetSize))) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return false; // 如果任何一位为0，元素一定不存在</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return true; // 所有位都为1，元素可能存在</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 其他辅助方法，如计算哈希值，计算最优参数等</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>----这部分面试中可以不背end----</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="布隆过滤器存在误判吗">布隆过滤器存在误判吗？<a href="#布隆过滤器存在误判吗" class="hash-link" aria-label="Direct link to 布隆过滤器存在误判吗？" title="Direct link to 布隆过滤器存在误判吗？">​</a></h3>
<p>是的，布隆过滤器存在误判。它可能会错误地认为某个元素在集合中，而元素实际上并不在集合中。
<img decoding="async" loading="lazy" alt="1756733698709" src="/doc/assets/images/1756733698709-95c1226fc85f6eb3b5ccce334aca9bb3.png" width="1582" height="860" class="img_ev3q">
但如果布隆过滤器认为某个元素不存在于集合中，那么它一定不存在。</p>
<p>误判产生的原因是因为哈希冲突。在布隆过滤器中，多个不同的元素可能映射到相同的位置。随着向布隆过滤器中添加的元素越来越多，位数组中的 1 也越来越多，发生哈希冲突的概率随之增加，误判率也就随之上升。
<img decoding="async" loading="lazy" alt="1756733712631" src="/doc/assets/images/1756733712631-d9d83fc9acf763561bb0166cad66f056.png" width="800" height="456" class="img_ev3q">
误判率取决于以下 3 个因素：</p>
<p>位数组的大小（m）：m 决定了可以存储的标志位数量。如果位数组过小，那么哈希碰撞的几率就会增加，从而导致更高的误判率。
哈希函数的数量（k）：k 决定了每个元素在位数组中标记的位数。哈希函数越多，碰撞的概率也会相应变化。如果哈希函数太少，过滤器很快会变得不精确；如果太多，误判率也会升高，效率下降。
存入的元素数量（n）：n 越多，哈希碰撞的几率越大，从而导致更高的误判率。
要降低误判率，可以增加位数组的大小或者减少插入的元素数量。</p>
<p>要彻底解决布隆过滤器的误判问题，可以在布隆过滤器返回&quot;可能存在&quot;时，再通过数据库进行二次确认。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="布隆过滤器支持删除吗">布隆过滤器支持删除吗？<a href="#布隆过滤器支持删除吗" class="hash-link" aria-label="Direct link to 布隆过滤器支持删除吗？" title="Direct link to 布隆过滤器支持删除吗？">​</a></h3>
<p>布隆过滤器并不支持删除操作，这是它的一个重要限制。</p>
<p>当我们添加一个元素时，会将位数组中的 k 个位置设置为 1。由于多个不同元素可能共享相同的位，如果我们尝试删除一个元素，将其对应的 k 个位重置为 0，可能会错误地影响到其他元素的判断结果。</p>
<p>例如，元素 A 和元素 B 都将位置 5 设为 1，如果删除元素 A 时将位置 5 重置为 0，那么对元素 B 的查询就会产生错误的&quot;不存在&quot;结果，这违背了布隆过滤器的基本特性。</p>
<p>如果想要实现删除操作，可以使用计数布隆过滤器，它在每个位置上存储一个计数器而不是单一的位。这样可以通过减少计数器的值来实现删除操作，但会增加内存开销。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class CountingBloomFilter&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int[] counters;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int hashFunctions;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public CountingBloomFilter(int size, int hashFunctions) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.size = size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.hashFunctions = hashFunctions;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.counters = new int[size];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void add(T element) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[] positions = getHashPositions(element);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int position : positions) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            counters[position]++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void remove(T element) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[] positions = getHashPositions(element);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int position : positions) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (counters[position] &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                counters[position]--;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean mightContain(T element) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int[] positions = getHashPositions(element);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int position : positions) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (counters[position] == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int[] getHashPositions(T element) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 计算哈希位置的代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么不能用哈希表而是用布隆过滤器">为什么不能用哈希表而是用布隆过滤器？<a href="#为什么不能用哈希表而是用布隆过滤器" class="hash-link" aria-label="Direct link to 为什么不能用哈希表而是用布隆过滤器？" title="Direct link to 为什么不能用哈希表而是用布隆过滤器？">​</a></h3>
<p>布隆过滤器最突出的优势是内存效率。</p>
<p>假如我们要判断 10 亿个用户 ID 是否曾经访问过特定页面，使用哈希表至少需要 10G 内存（每个 ID 至少需要8字节），而使用布隆过滤器只需要 1.2G 内存。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何保证缓存和数据库的数据致性">🌟如何保证缓存和数据库的数据⼀致性？<a href="#如何保证缓存和数据库的数据致性" class="hash-link" aria-label="Direct link to 🌟如何保证缓存和数据库的数据⼀致性？" title="Direct link to 🌟如何保证缓存和数据库的数据⼀致性？">​</a></h3>
<p>在技术派实战项目中，对于文章标签这种允许短暂不一致的数据，我会采用 Cache Aside + TTL 过期机制来保证缓存和数据库的一致性。
<img decoding="async" loading="lazy" alt="1756733923796" src="/doc/assets/images/1756733923796-f8eb9ea70ad5b435dd4e257a2d431811.png" width="2350" height="1602" class="img_ev3q"></p>
<p>具体做法是读取时先查 Redis，未命中再查 MySQL，同时为缓存设置一个合理的过期时间；更新时先更新 MySQL，再删除 Redis。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 读取逻辑</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public UserInfo getUser(String userId) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 先查缓存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    UserInfo user = cache.get(&quot;user:&quot; + userId);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (user != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return user;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 缓存未命中，查数据库</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    user = database.selectUser(userId);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (user != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 放入缓存，设置合理的过期时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cache.set(&quot;user:&quot; + userId, user, 3600);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return user;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 更新逻辑</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void updateUser(UserInfo user) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 先更新数据库</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    database.updateUser(user);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 删除缓存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    cache.delete(&quot;user:&quot; + user.getId());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>这种方式简单有效，适用于读多写少的场景。TTL 过期时间也能够保证即使更新操作失败，未能及时删除缓存，过期时间也能确保数据最终一致。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="那再来说说为什么要删除缓存而不是更新缓存">那再来说说为什么要删除缓存而不是更新缓存？<a href="#那再来说说为什么要删除缓存而不是更新缓存" class="hash-link" aria-label="Direct link to 那再来说说为什么要删除缓存而不是更新缓存？" title="Direct link to 那再来说说为什么要删除缓存而不是更新缓存？">​</a></h3>
<p>最初设计缓存策略时，我也考虑过直接更新缓存，但通过实践发现，删除缓存是更优的选择。
<img decoding="async" loading="lazy" alt="1756734010565" src="/doc/assets/images/1756734010565-72b08f3974b4c12d5646f4079327bb24.png" width="997" height="417" class="img_ev3q">
最主要的原因是在并发环境下，假设我们有两个并发的更新操作，如果采用更新缓存的策略，就可能出现这样的时序问题：</p>
<p>操作 A 和操作 B 同时发生，A 先更新 MySQL 将值改为 10，B 后更新 MySQL 将值改为 11。但在缓存更新时，可能 B 先执行将缓存设为 11，然后 A 才执行将缓存设为10。这样就会造成 MySQL 是 11 但 Redis 是 10 的不一致状态。
而采用删除策略，无论 A 和 B 谁先删除缓存，后续的读取操作都会从 MySQL 获取最新值。</p>
<p>另外，相对而言，删除缓存的速度比更新缓存的速度快得多。
<img decoding="async" loading="lazy" alt="1756734022557" src="/doc/assets/images/1756734022557-fae5afba90af1ccd3da41865d0f0ca62.png" width="645" height="319" class="img_ev3q">
因为删除操作只是简单的 DEL 命令，而更新可能需要重新序列化整个对象再写入缓存。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="那再说说为什么要先更新数据库再删除缓存">那再说说为什么要先更新数据库，再删除缓存？<a href="#那再说说为什么要先更新数据库再删除缓存" class="hash-link" aria-label="Direct link to 那再说说为什么要先更新数据库，再删除缓存？" title="Direct link to 那再说说为什么要先更新数据库，再删除缓存？">​</a></h3>
<p>这个操作顺序的选择也是我在实际项目中踩过坑才深刻理解的。假设我们采用先删缓存再更新数据库的策略，在高并发场景下就可能出现这样的问题：</p>
<p>线程 A 要更新用户信息，先删除了缓存
线程 B 恰好此时要读取该用户信息，发现缓存为空，于是查询数据库，此时还是旧值
线程 B 将查到的旧值重新放入缓存
线程 A 完成数据库更新
结果就是数据库是新的值，但缓存中还是旧值。
而采用先更新数据库再删缓存的策略，即使出现类似的并发情况，最坏的情况也只是短暂地从缓存中读取到了旧值，但缓存删除后的请求会直接从数据库中获取最新值。</p>
<p>另外，如果先删缓存再更新数据库，当数据库更新失败时，缓存已经被删除了。这会导致短期内所有读请求都会穿透到数据库，对数据库造成额外的压力。</p>
<p><img decoding="async" loading="lazy" alt="1756734135741" src="/doc/assets/images/1756734135741-862e53ab692ff684efbdee03d69548c1.png" width="977" height="417" class="img_ev3q">
而采用先更新数据库再删缓存的策略，即使出现类似的并发情况，最坏的情况也只是短暂地从缓存中读取到了旧值，但缓存删除后的请求会直接从数据库中获取最新值。</p>
<p>另外，如果先删缓存再更新数据库，当数据库更新失败时，缓存已经被删除了。这会导致短期内所有读请求都会穿透到数据库，对数据库造成额外的压力。
<img decoding="async" loading="lazy" alt="1756734179018" src="/doc/assets/images/1756734179018-21cdbc523fee63f8d95608cff18e6add.png" width="1087" height="598" class="img_ev3q">
而先更新数据库再删缓存，如果数据库更新失败，缓存保持原状，系统仍然能继续正常提供服务。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public void updateUser(User user) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 先更新数据库</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        database.updateUser(user);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 再删除缓存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cache.delete(&quot;user:&quot; + user.getId());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (DatabaseException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 数据库更新失败，缓存保持原状，系统仍可正常提供服务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        log.error(&quot;Database update failed&quot;, e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (CacheException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 缓存删除失败，数据库已更新，数据会在TTL后自动一致</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        log.warn(&quot;Cache deletion failed, will be eventually consistent&quot;, e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 可以选择不抛异常，因为有TTL兜底</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="那假如对缓存数据库一致性要求很高该怎么办呢">那假如对缓存数据库一致性要求很高，该怎么办呢？<a href="#那假如对缓存数据库一致性要求很高该怎么办呢" class="hash-link" aria-label="Direct link to 那假如对缓存数据库一致性要求很高，该怎么办呢？" title="Direct link to 那假如对缓存数据库一致性要求很高，该怎么办呢？">​</a></h3>
<p>当业务对缓存与数据库的一致性要求很高时，比如支付系统、库存管理等场景，我会采用多种策略来保证强一致性。
<img decoding="async" loading="lazy" alt="1756734292238" src="/doc/assets/images/1756734292238-2fe8e513ece8a42ad2d88bc3b96b5247.png" width="1542" height="738" class="img_ev3q">
第一种，引入消息队列来保证缓存最终被删除，比如说在数据库更新的事务中插入一条本地消息记录，事务提交后异步发送给 MQ 进行缓存删除。
<img decoding="async" loading="lazy" alt="1756734304497" src="/doc/assets/images/1756734304497-554ed957f6d5d08a991f77e831c4672c.png" width="831" height="401" class="img_ev3q">
即使缓存删除失败，消息队列的重试机制也能保证最终一致性。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Transactional</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void updateUser(UserInfo user) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 在事务中更新数据库</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    database.updateUser(user);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 在同一事务中记录需要删除的缓存信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    LocalMessage message = new LocalMessage(&quot;CACHE_DELETE&quot;, &quot;user:&quot; + user.getId());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    database.insertLocalMessage(message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 显式发布事件，供监听器捕获</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    eventPublisher.publishEvent(new UserUpdateEvent(this, &quot;user:&quot; + user.getId()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 事务提交后发送MQ消息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void sendCacheDeleteMessage(UserUpdateEvent event) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    messageQueue.send(&quot;cache-delete-topic&quot;, event.getCacheKey());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>第二种，使用 Canal 监听 MySQL 的 binlog，在数据更新时，将数据变更记录到消息队列中，消费者消息监听到变更后去删除缓存。
<img decoding="async" loading="lazy" alt="1756734327573" src="/doc/assets/images/1756734327573-7df727cf270c01dafc98507887b6d80e.png" width="948" height="576" class="img_ev3q">
这种方案的优势是完全解耦了业务代码和缓存维护逻辑。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@CanalListener</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class CacheUpdateListener {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @EventHandler</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void handleUserUpdate(UserUpdateEvent event) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 从binlog事件中提取变更信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String userId = event.getUserId();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 发送缓存删除消息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        CacheDeleteMessage message = new CacheDeleteMessage();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        message.setCacheKey(&quot;user:&quot; + userId);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        messageQueue.send(&quot;cache-delete-topic&quot;, message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 消费者监听消息队列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@KafkaListener(topics = &quot;cache-delete-topic&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void handleCacheDeleteMessage(CacheDeleteMessage message) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 删除缓存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    cache.delete(message.getCacheKey());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>当然了，如果说业务比较简单，不需要上消息队列，可以通过延迟双删策略降低缓存和数据库不一致的时间窗口，在第一次删除缓存之后，过一段时间之后，再次尝试删除缓存。
<img decoding="async" loading="lazy" alt="1756734360873" src="/doc/assets/images/1756734360873-9e1bd34f4e1da1f7eb0db6254700f552.png" width="505" height="678" class="img_ev3q">
这种方式主要针对缓存不存在，但写入了脏数据的情况。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public void updateUser(UserInfo user) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 第一次删除缓存，减少不一致时间窗口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    cache.delete(&quot;user:&quot; + user.getId());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 更新数据库</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    database.updateUser(user);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 立即删除缓存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    cache.delete(&quot;user:&quot; + user.getId());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 延时删除，应对可能的并发读取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    CompletableFuture.runAsync(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Thread.sleep(1000); // 延时时间根据主从同步延迟调整</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            cache.delete(&quot;user:&quot; + user.getId());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (InterruptedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Thread.currentThread().interrupt();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>最后，无论采用哪种策略，最好为缓存设置一个合理的过期时间作为最后的保障。即使所有的主动删除机制都失败了，TTL 也能确保数据最终达到一致：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 根据数据的重要程度设置不同的TTL</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void setCache(String key, Object value, DataImportance importance) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int ttl;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    switch (importance) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        case HIGH:      // 关键数据，短TTL</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ttl = 300;  // 5分钟</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        case MEDIUM:    // 一般数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ttl = 1800; // 30分钟</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        case LOW:       // 不太重要的数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ttl = 3600; // 1小时</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    cache.setWithTTL(key, value, ttl);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何保证本地缓存和分布式缓存的一致">如何保证本地缓存和分布式缓存的一致？<a href="#如何保证本地缓存和分布式缓存的一致" class="hash-link" aria-label="Direct link to 如何保证本地缓存和分布式缓存的一致？" title="Direct link to 如何保证本地缓存和分布式缓存的一致？">​</a></h3>
<p>在技术派实战项目中，为了减轻 Redis 的负载压力，我又追加了一层本地缓存 Caffeine。</p>
<p>为了保证 Caffeine 和 Redis 缓存的一致性，我采用的策略是当数据更新时，通过 Redis 的 pub/sub 机制向所有应用实例发送缓存更新通知，收到通知后的实例立即更新或者删除本地缓存。
<img decoding="async" loading="lazy" alt="1756734441158" src="/doc/assets/images/1756734441158-2bbe596a51a513f5d56ff54be6df0410.png" width="999" height="788" class="img_ev3q"></p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Service</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class CacheService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final RedisTemplate redisTemplate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final CaffeineCache localCache;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void updateData(String key, Object value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 更新数据库</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        database.update(key, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 更新分布式缓存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        redisTemplate.opsForValue().set(key, value, 30, TimeUnit.MINUTES);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 发送缓存更新通知</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        CacheUpdateMessage message = new CacheUpdateMessage(key, &quot;UPDATE&quot;, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        redisTemplate.convertAndSend(&quot;cache-update-channel&quot;, message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @EventListener</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void handleCacheUpdate(CacheUpdateMessage message) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (&quot;UPDATE&quot;.equals(message.getAction())) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            localCache.put(message.getKey(), message.getValue());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else if (&quot;DELETE&quot;.equals(message.getAction())) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            localCache.invalidate(message.getKey());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>考虑到消息可能丢失，我还会引入版本号机制作为补充。每次从 Redis 获取数据时添加一个最新的版本号。从本地缓存获取数据前，先检查自己的版本号是否是最新的，如果发现版本落后，就主动从 Redis 中获取最新数据。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Component</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class VersionBasedCacheManager {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Autowired</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private StringRedisTemplate redisTemplate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 使用 Caffeine 构建本地缓存：最多 1000 项，写入后 10 分钟过期</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Cache&lt;String, VersionedData&gt; localCache = Caffeine.newBuilder()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .maximumSize(1000)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .expireAfterWrite(10, TimeUnit.MINUTES)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .build();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 获取缓存数据，优先使用本地缓存，必要时从 Redis 加载</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object get(String key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        VersionedData cached = localCache.getIfPresent(key); // 从本地缓存取出</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 从 Redis 获取版本号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String versionStr = redisTemplate.opsForValue().get(key + &quot;:version&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果 Redis 中没找到版本号，说明可能数据已失效，强制刷新</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (versionStr == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return loadAndCache(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long remoteVersion = Long.parseLong(versionStr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果本地没有缓存，或版本落后于 Redis，强制刷新</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (cached == null || cached.getVersion() &lt; remoteVersion) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return loadAndCache(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 命中本地缓存且版本最新，直接返回</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return cached.getData();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 从 Redis 加载数据和版本，并写入本地缓存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Object loadAndCache(String key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object data = redisTemplate.opsForValue().get(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String versionStr = redisTemplate.opsForValue().get(key + &quot;:version&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (data != null &amp;&amp; versionStr != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            long version = Long.parseLong(versionStr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            localCache.put(key, new VersionedData(data, version));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如果在项目中多个地方都要使用到二级缓存的逻辑如何设计这一块">如果在项目中多个地方都要使用到二级缓存的逻辑，如何设计这一块？<a href="#如果在项目中多个地方都要使用到二级缓存的逻辑如何设计这一块" class="hash-link" aria-label="Direct link to 如果在项目中多个地方都要使用到二级缓存的逻辑，如何设计这一块？" title="Direct link to 如果在项目中多个地方都要使用到二级缓存的逻辑，如何设计这一块？">​</a></h3>
<p>我的思路是将二级缓存抽象成一个统一的组件。设计一个 CacheManager 作为核心入口，提供 get、put、evict 等基本操作，执行先查本地缓存，再查分布式缓存，最后查数据库的完整流程。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class CacheManager {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final LocalCache localCache;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final RedisCache redisCache;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Database database;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public CacheManager(LocalCache localCache, RedisCache redisCache, Database database) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.localCache = localCache;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.redisCache = redisCache;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.database = database;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object get(String key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 先查本地缓存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object value = localCache.get(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (value != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 再查分布式缓存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        value = redisCache.get(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (value != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 更新本地缓存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            localCache.put(key, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 最后查数据库</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        value = database.get(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (value != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 更新分布式缓存和本地缓存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            redisCache.put(key, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            localCache.put(key, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="本地缓存和-redis-的区别了解吗">本地缓存和 Redis 的区别了解吗？<a href="#本地缓存和-redis-的区别了解吗" class="hash-link" aria-label="Direct link to 本地缓存和 Redis 的区别了解吗？" title="Direct link to 本地缓存和 Redis 的区别了解吗？">​</a></h3>
<p>Redis 可以部署在多个节点上，支持数据分片、主从复制和集群。而本地缓存只能在单个服务器上使用。</p>
<p>对于读取频率极高、数据相对稳定、允许短暂不一致的数据，我优先选择本地缓存。比如系统配置信息、用户权限数据、商品分类信息等。</p>
<p>而对于需要实时同步、数据变化频繁、多个服务需要共享的数据，我会选择 Redis。比如用户会话信息、购物车数据、实时统计信息等。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是热key">什么是热Key？<a href="#什么是热key" class="hash-link" aria-label="Direct link to 什么是热Key？" title="Direct link to 什么是热Key？">​</a></h3>
<p>所谓的热 Key，就是指在很短时间内被频繁访问的键。比如电商大促期间爆款商品的详情信息，流量明星爆瓜时的个人资料、热门话题等，都可能成为热Key。</p>
<p>由于 Redis 是单线程模型，大量请求集中到同一个键会导致该 Redis 节点的 CPU 使用率飙升，响应时间变长。</p>
<p>在 Redis 集群环境下，热Key 还会导致数据分布不均衡，某个节点承受的压力过大而其他节点相对空闲。
<img decoding="async" loading="lazy" alt="1756734563389" src="/doc/assets/images/1756734563389-58524cd1c6c95054fccec62196019fdb.png" width="827" height="500" class="img_ev3q">
更严重的情况是，当热Key 过期或被误删时，会引发缓存击穿问题。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="那怎么监控热key-呢">那怎么监控热Key 呢？<a href="#那怎么监控热key-呢" class="hash-link" aria-label="Direct link to 那怎么监控热Key 呢？" title="Direct link to 那怎么监控热Key 呢？">​</a></h3>
<p>临时的方案可以使用 redis-cli --hotkeys 命令来监控 Redis 中的热 Key。
或者在访问缓存时，在本地维护一个计数器，当某个键的访问次数在一分钟内超过设定阈值，就将其标记为热Key。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Component</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class HotKeyDetector {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final ConcurrentHashMap&lt;String, AtomicLong&gt; accessCounter = new ConcurrentHashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final int HOT_KEY_THRESHOLD = 1000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean isHotKey(String key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long count = accessCounter.computeIfAbsent(key, k -&gt; new AtomicLong(0))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                  .incrementAndGet();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return count &gt; HOT_KEY_THRESHOLD;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="那怎么处理热key-呢">那怎么处理热Key 呢？<a href="#那怎么处理热key-呢" class="hash-link" aria-label="Direct link to 那怎么处理热Key 呢？" title="Direct link to 那怎么处理热Key 呢？">​</a></h3>
<p>最有效的解决方法是增加本地缓存，将热 Key 缓存到本地内存中，这样请求就不需要访问 Redis 了。
<img decoding="async" loading="lazy" alt="1756734670474" src="/doc/assets/images/1756734670474-f11e33c27433f21e1d4872f633f7d918.png" width="677" height="401" class="img_ev3q">
对于一些特别热的 Key，可以将其拆分成多个子 Key，然后随机分布到不同的 Redis 节点上。比如将 hot_product:12345 拆分成 hot_product:12345:1、hot_product:12345:2 等多个副本，读取时随机选择其中一个。
<img decoding="async" loading="lazy" alt="1756734685435" src="/doc/assets/images/1756734685435-72963d4aaf70b96d164f9ff506898a4c.png" width="773" height="352" class="img_ev3q"></p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public String getHotData(String key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (isHotKey(key)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 随机选择一个副本</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int replica = ThreadLocalRandom.current().nextInt(HOT_KEY_REPLICAS);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return redis.get(key + &quot;:&quot; + replica);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return redis.get(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="怎么处理大-key-呢">怎么处理大 Key 呢？<a href="#怎么处理大-key-呢" class="hash-link" aria-label="Direct link to 怎么处理大 Key 呢？" title="Direct link to 怎么处理大 Key 呢？">​</a></h3>
<p>大Key 是指占用内存空间较大的缓存键，比如超过 10M 的键值对。常见的大Key 类型包括：包含大量元素的 List、Set、Hash 结构，存储大文件的 String 类型，以及包含复杂嵌套对象的 JSON 数据等。</p>
<p>在内存有限的情况下，可能导致 Redis 内存不足。另外，大Key 还会导致主从复制同步延迟，甚至引发网络拥塞。</p>
<p>可以通过 redis-cli --bigkeys 命令来监控 Redis 中的大 Key。</p>
<p>或者编写脚本进行全量扫描：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Component</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class BigKeyScanner {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final RedisTemplate redisTemplate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final int BIG_KEY_THRESHOLD = 1024 * 1024; // 1MB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public List&lt;BigKeyInfo&gt; scanBigKeys() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;BigKeyInfo&gt; bigKeys = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 使用SCAN命令遍历所有键</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ScanOptions options = ScanOptions.scanOptions().count(1000).build();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Cursor&lt;byte[]&gt; cursor = redisTemplate.executeWithStickyConnection(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            connection -&gt; connection.scan(options)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (cursor.hasNext()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String key = new String(cursor.next());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            long memory = getKeyMemoryUsage(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (memory &gt; BIG_KEY_THRESHOLD) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                bigKeys.add(new BigKeyInfo(key, memory, getKeyType(key)));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return bigKeys;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private long getKeyMemoryUsage(String key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 使用MEMORY USAGE命令获取键的内存占用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return redisTemplate.execute((RedisCallback&lt;Long&gt;) connection -&gt; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            connection.memoryUsage(key.getBytes())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>对于大 Key 问题，最根本的解决方案是拆分大 Key，将其拆分成多个小 Key 存储。比如将一个包含大量用户信息的 Hash 拆分成多个小 Hash。
<img decoding="async" loading="lazy" alt="1756734886639" src="/doc/assets/images/1756734886639-40dfabdb2a403e98c121614d348df432.png" width="738" height="467" class="img_ev3q"></p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public void splitBigKey(String bigKey) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Map&lt;String, String&gt; bigData = redisTemplate.opsForHash().entries(bigKey);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 将大 Key 拆分成多个小 Key</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (Map.Entry&lt;String, String&gt; entry : bigData.entrySet()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String smallKey = bigKey + &quot;:&quot; + entry.getKey();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        redisTemplate.opsForValue().set(smallKey, entry.getValue());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 删除原始大 Key</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    redisTemplate.delete(bigKey);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>另外，对于 JSON 数据，可以进行 Gzip 压缩后再存储，虽然会增加一些 CPU 开销，但在内存敏感的场景在是值得的。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public void setCompressedData(String key, Object data) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String json = objectMapper.writeValueAsString(data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        byte[] compressed = compress(json.getBytes());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        redisTemplate.opsForValue().set(key, compressed);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        log.error(&quot;Failed to compress data&quot;, e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private byte[] compress(byte[] data) throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ByteArrayOutputStream out = new ByteArrayOutputStream();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try (GZIPOutputStream gzip = new GZIPOutputStream(out)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        gzip.write(data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return out.toByteArray();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="缓存预热怎么做呢">缓存预热怎么做呢？<a href="#缓存预热怎么做呢" class="hash-link" aria-label="Direct link to 缓存预热怎么做呢？" title="Direct link to 缓存预热怎么做呢？">​</a></h3>
<p>缓存预热是指在系统启动或者特定时间点，提前将热点数据加载到缓存中，避免冷启动时大量请求直接打到数据库。
缓存预热的方法有多种，在技术派实战项目中，我会在项目启动时将热门文章提前加载到 Redis 中，在每天凌晨定时将最新的站点地图更新到 Redis中，以确保用户在第一次访问时就能获取到缓存数据，从而减轻数据库的压力。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 采用定时器方案，每天5:15分刷新站点地图，确保数据的一致性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Scheduled(cron = &quot;0 15 5 * * ?&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void autoRefreshCache() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    log.info(&quot;开始刷新sitemap.xml的url地址，避免出现数据不一致问题!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    refreshSitemap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    log.info(&quot;刷新完成！&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void refreshSitemap() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    initSiteMap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private synchronized void initSiteMap() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long lastId = 0L;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    RedisClient.del(SITE_MAP_CACHE_KEY);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;SimpleArticleDTO&gt; list = articleDao.getBaseMapper().listArticlesOrderById(lastId, SCAN_SIZE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 刷新站点地图信息，放到 Redis 当中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Map&lt;String, Long&gt; map = list.stream().collect(Collectors.toMap(s -&gt; String.valueOf(s.getId()), s -&gt; s.getCreateTime().getTime(), (a, b) -&gt; a));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        RedisClient.hMSet(SITE_MAP_CACHE_KEY, map);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (list.size() &lt; SCAN_SIZE) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        lastId = list.get(list.size() - 1).getId();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="无底洞问题听说过吗如何解决">无底洞问题听说过吗？如何解决？<a href="#无底洞问题听说过吗如何解决" class="hash-link" aria-label="Direct link to 无底洞问题听说过吗？如何解决？" title="Direct link to 无底洞问题听说过吗？如何解决？">​</a></h3>
<p>无底洞问题的核心在于，随着缓存节点数量的增加，虽然总的存储容量和理论吞吐量都在增长，但是单个请求的响应时间反而变长了。</p>
<p>这个问题的根本原因是网络通信开销的增加。当节点数量从几十个增长到几千个时，客户端需要与更多的节点进行通信。</p>
<p>其次就是数据分布的碎片化。随着节点增多，数据分散得更加细碎，原本可以在一个节点获取的相关数据，现在可能分散在多个节点上。</p>
<p>针对这个问题，可以采取以下几种解决方案：
第一，可以将同一节点的多个请求合并成一个批量请求，减少网络往返次数。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public Map&lt;String, Object&gt; batchGet(List&lt;String&gt; keys) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 按节点分组keys</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Map&lt;String, List&lt;String&gt;&gt; nodeKeysMap = groupKeysByNode(keys);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Map&lt;String, Object&gt; results = new ConcurrentHashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 并发访问各个节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    List&lt;CompletableFuture&lt;Void&gt;&gt; futures = nodeKeysMap.entrySet().stream()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .map(entry -&gt; CompletableFuture.runAsync(() -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String node = entry.getKey();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            List&lt;String&gt; nodeKeys = entry.getValue();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 批量获取该节点的数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Map&lt;String, Object&gt; nodeResults = getFromNode(node, nodeKeys);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            results.putAll(nodeResults);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .collect(Collectors.toList());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 等待所有请求完成</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return results;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>第二，可以使用一致性哈希算法来优化数据分布，减少数据迁移和重分布的开销。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class LocalityAwareSharding {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String getNodeForKey(String key, String category) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 相同类别的数据尽量分配到相同节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String shardKey = category + &quot;:&quot; + (key.hashCode() % SHARDS_PER_CATEGORY);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return consistentHash.getNode(shardKey);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 用户相关数据尽量在同一个节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String getUserDataNode(String userId) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return &quot;user_cluster_&quot; + (userId.hashCode() % USER_CLUSTERS);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="redis-运维">Redis 运维<a href="#redis-运维" class="hash-link" aria-label="Direct link to Redis 运维" title="Direct link to Redis 运维">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis-报内存不足怎么处理">Redis 报内存不足怎么处理？<a href="#redis-报内存不足怎么处理" class="hash-link" aria-label="Direct link to Redis 报内存不足怎么处理？" title="Direct link to Redis 报内存不足怎么处理？">​</a></h3>
<p>Redis 报内存不足时，通常是因为 Redis 占用的物理内存已经接近或者超过了配置的最大内存限制。这时可以采取以下几种步骤来处理：</p>
<p>第一，使用 INFO memory 命令查看 Redis 的内存使用情况，看看是否真的达到了最大内存限制。
redis-cli INFO memory
第二，如果服务器还有可用内存的话，修改 redis.conf 中的 maxmemory 参数，增加 Redis 的最大内存限制。比如将最大内存设置为 8GB：
maxmemory 8gb
第三，修改 maxmemory-policy 参数来调整内存淘汰策略。比如可以选择 allkeys-lru 策略，让 Redis 自动删除最近最少使用的键
maxmemory-policy allkeys-lru</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis-key过期策略有哪些">Redis key过期策略有哪些？<a href="#redis-key过期策略有哪些" class="hash-link" aria-label="Direct link to Redis key过期策略有哪些？" title="Direct link to Redis key过期策略有哪些？">​</a></h3>
<p>Redis 主要采用了两种过期删除策略来保证过期的 key 能够被及时删除，包括惰性删除和定期删除。
<img decoding="async" loading="lazy" alt="1756735321906" src="/doc/assets/images/1756735321906-6e69bf8decc279420c19117f5609b105.png" width="1548" height="570" class="img_ev3q">
惰性删除是最基本的策略，当客户端访问一个 key 时，Redis 会检查该 key 是否已过期，如果过期就会立即删除并返回 nil。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 模拟惰性删除的逻辑</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public Object get(String key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    RedisKey redisKey = getKeyFromMemory(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (redisKey != null &amp;&amp; isExpired(redisKey)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // key已过期，删除并返回null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        deleteKey(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return redisKey != null ? redisKey.getValue() : null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>这种策略的优点是不会有额外的 CPU 开销，只在访问 key 时才检查。但问题是如果一个过期的 key 永远不被访问，它就会一直占用内存。
<img decoding="async" loading="lazy" alt="1756735356144" src="/doc/assets/images/1756735356144-60abaa4311051f986b0bbd15342b589d.png" width="910" height="483" class="img_ev3q">
于是就有了定期删除策略，Redis 会定期随机选择一些设置了过期时间的 key 进行检查，删除其中已过期的 key。这个过程默认每秒执行 10 次，每次随机选择 20 个 key 进行检查。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis有哪些内存淘汰策略">🌟Redis有哪些内存淘汰策略？<a href="#redis有哪些内存淘汰策略" class="hash-link" aria-label="Direct link to 🌟Redis有哪些内存淘汰策略？" title="Direct link to 🌟Redis有哪些内存淘汰策略？">​</a></h3>
<p>当内存使用接近 maxmemory 限制时，Redis 会依据内存淘汰策略来决定删除哪些 key 以缓解内存压力。
<img decoding="async" loading="lazy" alt="1756735436275" src="/doc/assets/images/1756735436275-553131a25644fc9fd7a4dae204f549f5.png" width="3078" height="1266" class="img_ev3q">
常用的内存淘汰策略有八种，分别是默认的 noeviction，内存不足时不会删除任何 key，直接返回错误信息，生产环境下基本上不会使用。</p>
<p>然后是针对所有 key 的 allkeys-lru、allkeys-lfu 和 allkeys-random。lru 会删除最近最少使用的 key，在纯缓存场景中最常用，能自动保留热点数据；lfu 会删除访问频率最低的 key，更适合长期运行的系统；random 会随机删除一些 key，一般不推荐使用。</p>
<p>其次是针对设置了过期时间的 key，有 volatile-lru、volatile-lfu、volatile-ttl 和 volatile-random。</p>
<p>lru 在混合存储场景中经常使用。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Service</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class HybridStorageService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 重要数据不设置过期时间，临时数据设置过期时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void storeData(String key, Object data, DataImportance importance) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (importance == DataImportance.HIGH) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 重要数据不设置过期时间，在volatile-*策略下不会被淘汰</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            redisTemplate.opsForValue().set(key, data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 临时数据设置过期时间，可以被volatile-*策略淘汰</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            redisTemplate.opsForValue().set(key, data, Duration.ofHours(1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>lfu 适合需要保护某些重要数据不被淘汰的场景；ttl 优先删除即将过期的 key，在用户会话管理系统中推荐使用；random 仍然很少用。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="lru-和-lfu-的区别是什么">LRU 和 LFU 的区别是什么？<a href="#lru-和-lfu-的区别是什么" class="hash-link" aria-label="Direct link to LRU 和 LFU 的区别是什么？" title="Direct link to LRU 和 LFU 的区别是什么？">​</a></h3>
<p>LRU 是 Least Recently Used 的缩写，基于时间维度，淘汰最近最少访问的键。</p>
<p>LFU 是 Least Frequently Used 的缩写，基于次数维度，淘汰访问频率最低的键。</p>
<p>假设缓存中有三个数据 A、B、C，在 LRU 场景下，如果访问顺序是 A→B→C→A，那么此时的 LRU 顺序是B→C→A，如果需要淘汰，会先删除 B。</p>
<p>但在 LFU 场景下，如果 A 被访问了 5 次，B 被访问了 2 次，C 被访问了 1 次，那么无论最近的访问顺序如何，都会优先淘汰 C，因为它的访问频率最低。</p>
<p>LRU 更适合有明显时间局部性的场景，比如在新闻网站中，用户更关心最新的新闻，而昨天的新闻访问量会急剧下降。这种情况下，LRU 能很好地保留用户当前关心的热点内容。</p>
<p>LFU 则更适合有长期访问模式的场景，更强调“热度”，比如在电商平台中，某些商品可能长期保持热销状态，即使它们的访问时间间隔较长，但由于访问频率高，LFU 会优先保留这些商品的信息。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis发生阻塞了怎么解决">Redis发生阻塞了怎么解决？<a href="#redis发生阻塞了怎么解决" class="hash-link" aria-label="Direct link to Redis发生阻塞了怎么解决？" title="Direct link to Redis发生阻塞了怎么解决？">​</a></h3>
<p>Redis 发生阻塞在生产环境中是比较严重的问题，当发现 Redis 变慢时，我会先通过 monitor 命令查看当前正在执行的命令，或者使用 slowlog 命令查看慢查询日志。</p>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># 查看当前正在执行的命令</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">redis-cli MONITOR</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 查看慢查询日志</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">redis-cli SLOWLOG GET 10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 检查客户端连接状况</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">redis-cli CLIENT LIST</span><br></span></code></pre></div></div>
<p>通常情况下，大Key 是导致 Redis 阻塞的主要原因之一。比如说直接 DEL 一个包含几百万个元素的 Set，就会导致 Redis 阻塞几秒钟甚至更久。</p>
<p>这时候可以用 UNLINK 命令替代 DEL 来异步删除，避免阻塞主线程。</p>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># 使用 UNLINK 异步删除大 Key</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">redis-cli UNLINK big_key</span><br></span></code></pre></div></div>
<p>对于非常大的集合，可以使用 SCAN 命令分批删除。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public void safeBatchProcess(String key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ScanOptions options = ScanOptions.scanOptions().count(1000).build();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Cursor&lt;String&gt; cursor = redisTemplate.opsForSet().scan(key, options);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (cursor.hasNext()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String member = cursor.next();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 分批处理，避免阻塞</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        processElement(member);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>另外，当 Redis 使用的内存超过物理内存时，操作系统会将部分内存交换到磁盘，这时候会导致 Redis 响应变慢。我的处理方式是：</p>
<p>使用 free -h 检查内存的使用情况 ；确认 Redis 的 maxmemory 设置是否合理；如果发生了内存交换，立即调整 maxmemory 并清理一些不重要的数据。</p>
<p>大量的客户端连接也可能会导致阻塞，这时候最好检查一下连接池的配置。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Configuration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class RedisConnectionConfig {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public JedisConnectionFactory jedisConnectionFactory() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        JedisPoolConfig poolConfig = new JedisPoolConfig();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        poolConfig.setMaxTotal(200);        // 最大连接数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        poolConfig.setMaxIdle(50);          // 最大空闲连接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        poolConfig.setMinIdle(10);          // 最小空闲连接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        poolConfig.setMaxWaitMillis(3000);  // 获取连接最大等待时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        poolConfig.setTestOnBorrow(true);   // 获取连接时检测有效性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new JedisConnectionFactory(poolConfig);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="redis-应用">Redis 应用<a href="#redis-应用" class="hash-link" aria-label="Direct link to Redis 应用" title="Direct link to Redis 应用">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis如何实现异步消息队列">Redis如何实现异步消息队列？<a href="#redis如何实现异步消息队列" class="hash-link" aria-label="Direct link to Redis如何实现异步消息队列？" title="Direct link to Redis如何实现异步消息队列？">​</a></h3>
<p>Redis 实现异步消息队列是一个很实用的技术方案，最简单的方式是使用 List 配合 LPUSH 和 RPOP 命令。
<img decoding="async" loading="lazy" alt="1756735748176" src="/doc/assets/images/1756735748176-20a5f6c9d31019b2c72cc01681916f05.png" width="661" height="206" class="img_ev3q"></p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Service</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SimpleRedisQueue {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 生产者：向队列发送消息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void sendMessage(String queueName, Object message) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        redisTemplate.opsForList().leftPush(queueName, message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 消费者：从队列获取消息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object receiveMessage(String queueName) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return redisTemplate.opsForList().rightPop(queueName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 阻塞式消费，避免轮询</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object blockingReceive(String queueName, int timeoutSeconds) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;Object&gt; result = redisTemplate.opsForList()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .rightPop(queueName, timeoutSeconds, TimeUnit.SECONDS);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return result != null &amp;&amp; !result.isEmpty() ? result.get(0) : null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>另外就是用 Redis 的 Pub/Sub 来实现简单的消息广播和订阅。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Service</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class RedisPubSubService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 发布消息到指定频道</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void publish(String channel, Object message) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        redisTemplate.convertAndSend(channel, message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 订阅频道</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @PostConstruct</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void subscribe() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        redisTemplate.setMessageListener((message, pattern) -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;Received message: &quot; + message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        redisTemplate.getConnectionFactory().getConnection().subscribe(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new ChannelTopic(&quot;myChannel&quot;).getTopic().getBytes()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>发布者将消息发布到指定的频道，订阅该频道的客户端就能收到消息。
<img decoding="async" loading="lazy" alt="1756735788471" src="/doc/assets/images/1756735788471-063e09fa6698d111d0663f4a7c0ad379.png" width="609" height="373" class="img_ev3q">
但是这两种方式都是不可靠的，因为没有 ACK 机制所以不能保证订阅者一定能收到消息，也不支持消息持久化。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis如何实现延时消息队列">Redis如何实现延时消息队列?<a href="#redis如何实现延时消息队列" class="hash-link" aria-label="Direct link to Redis如何实现延时消息队列?" title="Direct link to Redis如何实现延时消息队列?">​</a></h3>
<p>延时消息队列在实际业务中很常见，比如订单超时取消、定时提醒等场景。Redis 虽然不是专业的消息队列，但可以很好地实现延时队列功能。</p>
<p>核心思路是利用 ZSet 的有序特性，将消息作为 member，把消息的执行时间作为 score。这样消息就会按照执行时间自动排序，我们只需要定期扫描当前时间之前的消息进行处理就可以了。
<img decoding="async" loading="lazy" alt="1756735821861" src="/doc/assets/images/1756735821861-cc6cccc610427cbc57f3c64c1437dcc1.png" width="902" height="171" class="img_ev3q"></p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Service</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DelayedMessageQueue {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 发送延时消息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void sendDelayedMessage(String queueName, Object message, long delaySeconds) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 计算消息的执行时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long executeTime = System.currentTimeMillis() + (delaySeconds * 1000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 将消息加入ZSet，以执行时间作为score</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        redisTemplate.opsForZSet().add(queueName, message, executeTime);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        log.info(&quot;发送延时消息: {}, 延时: {}秒&quot;, message, delaySeconds);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 消费延时消息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Scheduled(fixedDelay = 1000) // 每秒扫描一次</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void consumeDelayedMessages() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String queueName = &quot;delayed:queue&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long currentTime = System.currentTimeMillis();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 获取已到期的消息（score &lt;= 当前时间）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Set&lt;Object&gt; messages = redisTemplate.opsForZSet()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .rangeByScore(queueName, 0, currentTime);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (Object message : messages) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 处理消息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                processMessage(message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 处理成功后从队列中移除</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                redisTemplate.opsForZSet().remove(queueName, message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                log.info(&quot;处理延时消息成功: {}&quot;, message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                log.error(&quot;处理延时消息失败: {}&quot;, message, e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 可以实现重试机制</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                handleFailedMessage(queueName, message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>具体实现上，我会在生产者发送延时消息时，计算消息应该执行的时间戳，然后用 ZADD 命令将消息添加到 ZSet 中。
ZADD delay_queue 1617024000 task1</p>
<p>消费者通过定时任务，使用 ZRANGEBYSCORE 命令获取当前时间之前的所有消息。
ZREMRANGEBYSCORE delay_queue -inf 1617024000</p>
<p>处理完成后再用 ZREM 删除消息。
ZREM delay_queue task1</p>
<p>在技术派实战项目中，我就用这种方式实现了文章定时发布的功能。作者在发布文章时，可以选择一个未来的时间节点，比如说 30 分钟后，系统就会向延时队列发送一条延时消息，然后定时任务就会在 30 分钟后将这条消息从延时队列中取出并发布文章。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis支持事务吗">🌟Redis支持事务吗？<a href="#redis支持事务吗" class="hash-link" aria-label="Direct link to 🌟Redis支持事务吗？" title="Direct link to 🌟Redis支持事务吗？">​</a></h3>
<p>是的，Redis 支持简单的事务，可以将 multi、exec、discard 和 watch 命令打包，然后一次性的按顺序执行。
<img decoding="async" loading="lazy" alt="1756736081892" src="/doc/assets/images/1756736081892-a3a0a4473fdf612e64336dcad6fa4146.png" width="671" height="587" class="img_ev3q">
基本流程是用 multi 开启事务，然后执行一系列命令，最后用 exec 提交。这些命令会被放入队列，在 exec 时批量执行。
当客户端处于非事务状态时，所有发送给 Redis 服务的命令都会立即执行；但当客户端进入事务状态之后，这些命令会被放入一个事务队列中，然后立即返回 QUEUED，表示命令已入队。
<img decoding="async" loading="lazy" alt="1756736097859" src="/doc/assets/images/1756736097859-53ad50eef22f9a678df85027de2a2f3c.png" width="591" height="376" class="img_ev3q">
当 exec 命令执行时，Redis 会将事务队列中的所有命令按先进先出的顺序执行。当事务队列里的命令全部执行完毕后，Redis 会返回一个数组，包含每个命令的执行结果。</p>
<p>discard 命令用于取消一个事务，它会清空事务队列并退出事务状态。</p>
<p>watch 命令用于监视一个或者多个 key，如果这个 key 在事务执行之前 被其他命令改动，那么事务将会被打断。
<img decoding="async" loading="lazy" alt="1756736124117" src="/doc/assets/images/1756736124117-71e5e4e92f316218992f0f488a153a61.png" width="596" height="442" class="img_ev3q">
但 Redis 的事务与 MySQL 的有很大不同，它并不支持回滚，也不支持隔离级别。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说一下-redis-事务的原理">说一下 Redis 事务的原理？<a href="#说一下-redis-事务的原理" class="hash-link" aria-label="Direct link to 说一下 Redis 事务的原理？" title="Direct link to 说一下 Redis 事务的原理？">​</a></h3>
<p>Redis 事务的原理并不复杂，核心就是一个&quot;先排队，后执行&quot;的机制。</p>
<p><img decoding="async" loading="lazy" alt="1756736185947" src="/doc/assets/images/1756736185947-e2a572c7da573b4e7d34b0cfb7842b6b.png" width="1080" height="428" class="img_ev3q">
当执行 MULTI 命令时，Redis 会给这个客户端打一个事务的标记，表示这个客户端后面发送的命令不会被立即执行，而是被放到一个队列里排队等着。
<img decoding="async" loading="lazy" alt="1756736194629" src="/doc/assets/images/1756736194629-c576aabb7d6fc0b0c3f0384ffef85df9.png" width="1080" height="626" class="img_ev3q">
当 Redis 收到 EXEC 命令时，它会把队列里的命令一个个拿出来执行。因为 Redis 是单线程的，所以这个过程不会被其他命令打断，这就保证了Redis 事务的原子性。
<img decoding="async" loading="lazy" alt="1756736205571" src="/doc/assets/images/1756736205571-5356edc58a293a1fd7865bbf7741af26.png" width="1080" height="832" class="img_ev3q">
当执行 WATCH 命令时，Redis 会将 key 添加到全局监视字典中；只要这些 key 在 EXEC 前被其他客户端修改，Redis 就会给相关客户端打上脏标记，EXEC 时发现事务已被干扰就会直接取消整个事务。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 全局监视字典</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dict *watched_keys;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct watchedKey {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    robj *key;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    redisDb *db;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} watchedKey;</span><br></span></code></pre></div></div>
<p>DISCARD 做的事情很简单直接，首先检查客户端是否真的在事务状态，如果不在就报错；如果在事务状态，就清空事务队列并退出事务状态。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void discardCommand(client *c) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!(c-&gt;flags &amp; CLIENT_MULTI)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        addReplyError(c,&quot;DISCARD without MULTI&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    discardTransaction(c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    addReply(c,shared.ok);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis-事务有哪些注意点">Redis 事务有哪些注意点？<a href="#redis-事务有哪些注意点" class="hash-link" aria-label="Direct link to Redis 事务有哪些注意点？" title="Direct link to Redis 事务有哪些注意点？">​</a></h3>
<p>最重要的的一点是，Redis 事务不支持回滚，一旦 EXEC 命令被调用，所有命令都会被执行，即使有些命令可能执行失败。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis事务为什么不支持回滚">Redis事务为什么不支持回滚？<a href="#redis事务为什么不支持回滚" class="hash-link" aria-label="Direct link to Redis事务为什么不支持回滚？" title="Direct link to Redis事务为什么不支持回滚？">​</a></h3>
<p>Redis 的核心设计理念是简单、高效，而不是完整的 ACID 特性。而实现回滚需要在执行过程中保存大量的状态信息，并在发生错误时逆向执行命令以恢复原始状态。这会增加 Redis 的复杂性和性能开销。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis事务满足原子性吗要怎么改进">Redis事务满足原子性吗？要怎么改进？<a href="#redis事务满足原子性吗要怎么改进" class="hash-link" aria-label="Direct link to Redis事务满足原子性吗？要怎么改进？" title="Direct link to Redis事务满足原子性吗？要怎么改进？">​</a></h3>
<p>Redis 的事务不能满足标准的原子性，因为它不支持事务回滚，也就是说，假如某个命令执行失败，整个事务并不会自动回滚到初始状态。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 一个转账事务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">redisTemplate.multi();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">redisTemplate.opsForValue().decrement(&quot;user:1:balance&quot;, 100); // 成功</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">redisTemplate.opsForList().leftPush(&quot;user:1:balance&quot;, &quot;log&quot;);  // 类型错误，失败</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">redisTemplate.opsForValue().increment(&quot;user:2:balance&quot;, 100);  // 还是会执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;Object&gt; results = redisTemplate.exec();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 结果：用户1被扣了钱，用户2也收到了钱，但中间的日志操作失败了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 这符合Redis的原子性定义，但不符合业务期望</span><br></span></code></pre></div></div>
<p>可以使用 Lua 脚本来替代事务，脚本运行期间，Redis 不会处理其他命令，并且我们可以在脚本中处理整个业务逻辑，包括条件检查和错误处理，保证要么执行成功，要么保持最初的状态，不会出现一个命令执行失败、其他命令执行成功的情况。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Service</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ImprovedTransactionService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean atomicTransfer(String fromUser, String toUser, int amount) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String luaScript = </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;local from_key = KEYS[1] &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;local to_key = KEYS[2] &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;local amount = tonumber(ARGV[1]) &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 检查转出账户余额</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;local from_balance = redis.call(&#x27;GET&#x27;, from_key) &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;if not from_balance then return -1 end &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;from_balance = tonumber(from_balance) &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;if from_balance &lt; amount then return -2 end &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 检查转入账户是否存在</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;if redis.call(&#x27;EXISTS&#x27;, to_key) == 0 then return -3 end &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 所有检查通过，执行转账</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;redis.call(&#x27;DECRBY&#x27;, from_key, amount) &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;redis.call(&#x27;INCRBY&#x27;, to_key, amount) &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 记录转账日志</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;local log = from_key .. &#x27;:&#x27; .. to_key .. &#x27;:&#x27; .. amount &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;redis.call(&#x27;LPUSH&#x27;, &#x27;transfer:log&#x27;, log) &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;return 1&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DefaultRedisScript&lt;Long&gt; script = new DefaultRedisScript&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        script.setScriptText(luaScript);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        script.setResultType(Long.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Long result = redisTemplate.execute(script, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Arrays.asList(&quot;user:&quot; + fromUser + &quot;:balance&quot;, &quot;user:&quot; + toUser + &quot;:balance&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            amount);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return result != null &amp;&amp; result == 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis-事务的-acid-特性如何体现">Redis 事务的 ACID 特性如何体现？<a href="#redis-事务的-acid-特性如何体现" class="hash-link" aria-label="Direct link to Redis 事务的 ACID 特性如何体现？" title="Direct link to Redis 事务的 ACID 特性如何体现？">​</a></h3>
<p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务在执行过程中如果某个命令失败了，其他命令还是会继续执行，不会回滚。
<img decoding="async" loading="lazy" alt="1756736388588" src="/doc/assets/images/1756736388588-ef0a8ffce94572e58d525128f03ef7b0.png" width="1080" height="482" class="img_ev3q">
一致性指的是，如果数据在执行事务之前是一致的，那么在事务执行之后，无论事务是否执行成功，数据也应该是一致的。但 Redis 事务并不保证一致性，因为如果事务中的某个命令失败了，其他命令仍然会执行，就会出现数据不一致的情况。</p>
<p>Redis 是单线程执行事务的，并且不会中断，直到执行完所有事务队列中的命令为止。因此，我认为 Redis 的事务具有隔离性的特征。</p>
<p><img decoding="async" loading="lazy" alt="1756736455102" src="/doc/assets/images/1756736455102-94241128d39cd2a423b62da3ab273d16.png" width="1080" height="930" class="img_ev3q">
Redis 事务的持久性完全依赖于 Redis 本身的持久化机制，如果开启了 AOF，那么事务中的命令会作为一个整体记录到 AOF 文件中，当然也要看 AOF 的 fsync 策略。</p>
<p>如果只开启了 RDB，事务中的命令可能会在下次快照前丢失。如果两个都没有开启，肯定是不满足持久性的。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="有lua脚本操作redis的经验吗">有Lua脚本操作Redis的经验吗？<a href="#有lua脚本操作redis的经验吗" class="hash-link" aria-label="Direct link to 有Lua脚本操作Redis的经验吗？" title="Direct link to 有Lua脚本操作Redis的经验吗？">​</a></h3>
<p>Lua 脚本是处理 Redis 复杂操作的首选方案，比如说原子扣减库存、分布式锁、限流等业务场景，都可以通过 Lua 脚本来实现。
<img decoding="async" loading="lazy" alt="1756736515935" src="/doc/assets/images/1756736515935-0b734c9c57624e23a8857a14a80e090b.png" width="1400" height="800" class="img_ev3q"></p>
<p>在秒杀场景下，可以用 Lua 脚本把所有检查逻辑都写在一起：先看库存够不够，再看用户有没有买过，所有条件都满足才扣减库存。因为整个脚本是原子执行的，Redis 在执行期间不会处理其他命令，所以可以彻底解决超卖问题。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 这个秒杀脚本救了我的命</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String luaScript = </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;local stock = redis.call(&#x27;GET&#x27;, KEYS[1]) &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;if not stock or tonumber(stock) &lt; tonumber(ARGV[2]) then &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;    return -1 &quot; +  // 库存不足</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;end &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;if redis.call(&#x27;SISMEMBER&#x27;, KEYS[2], ARGV[1]) == 1 then &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;    return -2 &quot; +  // 重复购买</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;end &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;redis.call(&#x27;DECRBY&#x27;, KEYS[1], ARGV[2]) &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;redis.call(&#x27;SADD&#x27;, KEYS[2], ARGV[1]) &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;return 1&quot;;</span><br></span></code></pre></div></div>
<p>在分布式锁场景下，我一开始用的 SETNX 命令来实现，结果发现如果程序异常退出，锁就死掉了。后来加了过期时间，但又发现可能误删其他线程的锁。最后还是用 Lua 脚本彻底解决了这个问题，确保只有锁的持有者才能释放锁。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 解锁脚本特别重要，必须验证是自己的锁才能删</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private final String UNLOCK_SCRIPT = </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;if redis.call(&#x27;GET&#x27;, KEYS[1]) == ARGV[1] then &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;    return redis.call(&#x27;DEL&#x27;, KEYS[1]) &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;else &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;    return 0 &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;end&quot;;</span><br></span></code></pre></div></div>
<p>甚至还可以用 Lua脚本实现滑动窗口限流器，一次性完成过期数据清理、计数检查、新记录添加三个操作，而且完全原子化。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 滑动窗口限流，逻辑清晰，性能还好</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String luaScript = </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;local key = KEYS[1] &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;local now = tonumber(ARGV[1]) &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;local window = tonumber(ARGV[2]) &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;local limit = tonumber(ARGV[3]) &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 先清理过期记录</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;redis.call(&#x27;ZREMRANGEBYSCORE&#x27;, key, 0, now - window) &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 检查当前请求数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;local current = redis.call(&#x27;ZCARD&#x27;, key) &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;if current &lt; limit then &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;    redis.call(&#x27;ZADD&#x27;, key, now, now) &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;    return 1 &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;else &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;    return 0 &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;end&quot;;</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis的管道pipeline了解吗">Redis的管道Pipeline了解吗？<a href="#redis的管道pipeline了解吗" class="hash-link" aria-label="Direct link to Redis的管道Pipeline了解吗？" title="Direct link to Redis的管道Pipeline了解吗？">​</a></h3>
<p>了解，Pipeline 允许客户端一次性向 Redis 服务器发送多个命令，而不必等待一个命令响应后才能发送下一个。Redis 服务器会按照命令的顺序依次执行，并将所有结果打包返回给客户端。
<img decoding="async" loading="lazy" alt="1756736599196" src="/doc/assets/images/1756736599196-51a73be7944faec9a57d7c15d74f77f5.png" width="776" height="498" class="img_ev3q">
正常情况下，每执行一个 Redis 命令都需要一次网络往返：发送命令 -&gt; 等待响应 -&gt; 发送下一个命令。</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">客户端                    Redis服务器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  |                           |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  |------- SET key1 val1 ----&gt;|</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  |&lt;------ OK ---------------|</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  |------- SET key2 val2 ----&gt;|</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  |&lt;------ OK ---------------|</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  |------- GET key1 --------&gt;|</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  |&lt;------ val1 -------------|</span><br></span></code></pre></div></div>
<p>如果大量请求依次发送，网络延迟会显著增加请求的总执行时间，假如一次 RTT 的时间是 1 毫秒，3 个就是 3 毫秒。有了 Pipeline 后，可以一次性发送 3 个命令，总时间就只需要 1 毫秒。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Service</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class RedisBatchService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void batchInsertUsers(List&lt;User&gt; users) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 不用Pipeline的错误做法 - 很慢</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // for (User user : users) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //     redisTemplate.opsForValue().set(&quot;user:&quot; + user.getId(), user);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 使用Pipeline的正确做法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        redisTemplate.executePipelined(new RedisCallback&lt;Object&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public Object doInRedis(RedisConnection connection) throws DataAccessException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (User user : users) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    String key = &quot;user:&quot; + user.getId();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    byte[] keyBytes = key.getBytes();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    byte[] valueBytes = serialize(user);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    connection.set(keyBytes, valueBytes);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return null; // Pipeline不需要返回值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>当然了，Pipeline 不是越大越好，太大会占用过多内存，通常建议每个 Pipeline 包含 1000 到 5000 个命令。可以根据实际情况调整。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public void smartBatchInsert(List&lt;String&gt; data) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int batchSize = 1000; // 经验值，根据数据大小调整</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; data.size(); i += batchSize) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;String&gt; batch = data.subList(i, Math.min(i + batchSize, data.size()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        redisTemplate.executePipelined(new RedisCallback&lt;Object&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public Object doInRedis(RedisConnection connection) throws DataAccessException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (String item : batch) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    connection.set(item.getBytes(), item.getBytes());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么场景下适合使用-pipeline呢">什么场景下适合使用 Pipeline呢？<a href="#什么场景下适合使用-pipeline呢" class="hash-link" aria-label="Direct link to 什么场景下适合使用 Pipeline呢？" title="Direct link to 什么场景下适合使用 Pipeline呢？">​</a></h3>
<p>需要批量插入、更新或删除数据，或者需要执行大量相似的命令时。比如：系统启动时的缓存预热 -&gt; 批量加载热点数据；比如统计数据的批量更新；比如大批量数据的导入导出；比如批量删除过期或无效的缓存。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="有了解过-pipeline-的底层原理吗">有了解过 Pipeline 的底层原理吗？<a href="#有了解过-pipeline-的底层原理吗" class="hash-link" aria-label="Direct link to 有了解过 Pipeline 的底层原理吗？" title="Direct link to 有了解过 Pipeline 的底层原理吗？">​</a></h3>
<p>有，其实就是缓冲的思想。在技术派实战项目中，我就在 RedisClient 类中封装了一个 PipelineAction 内部类，用来缓存命令。</p>
<p><img decoding="async" loading="lazy" alt="1756736707834" src="/doc/assets/images/1756736707834-a37b7bbf9fcb5d2de3e73eedf113704a.png" width="1482" height="1400" class="img_ev3q">
add 方法将命令包装成 Runnable 对象，放入 List 中。当执行 execute 方法时，再调用 RedisTemplate 的 executePipelined 方法开启管道模式将多个命令发送到 Redis 服务端。</p>
<p><img decoding="async" loading="lazy" alt="1756736745896" src="/doc/assets/images/1756736745896-42df1f5de21fc2fd1b0c9b37ea7bf562.png" width="1472" height="1298" class="img_ev3q">
Redis 服务端从输入缓冲区读到命令后，会按照 RESP 协议进行命令拆解，再依次执行这些命令。执行结果会写入到输出缓冲区，最后再将所有结果一次性返回给客户端。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct client {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sds querybuf;           // 输入缓冲区</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    list *reply;            // 输出缓冲区链表</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned long reply_bytes; // 输出缓冲区大小</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} client;</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis能实现分布式锁吗">🌟Redis能实现分布式锁吗？<a href="#redis能实现分布式锁吗" class="hash-link" aria-label="Direct link to 🌟Redis能实现分布式锁吗？" title="Direct link to 🌟Redis能实现分布式锁吗？">​</a></h3>
<p>分布式锁是一种用于控制多个不同进程在分布式系统中访问共享资源的锁机制。它能确保在同一时刻，只有一个节点可以对资源进行访问，从而避免分布式场景下的并发问题。</p>
<p>可以使用 Redis 的 SETNX 命令实现简单的分布式锁。比如 SET key value NX PX 3000 就创建了一个锁名为 key 的分布式锁，锁的持有者为 value。NX 保证只有在 key 不存在时才能创建成功，EX 设置过期时间用以防止死锁。
<img decoding="async" loading="lazy" alt="1756736787005" src="/doc/assets/images/1756736787005-f7ed82c54be1e1cc418ca367c8ebaa6e.png" width="639" height="431" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis如何保证-setnx-不会发生冲突">Redis如何保证 SETNX 不会发生冲突？<a href="#redis如何保证-setnx-不会发生冲突" class="hash-link" aria-label="Direct link to Redis如何保证 SETNX 不会发生冲突？" title="Direct link to Redis如何保证 SETNX 不会发生冲突？">​</a></h3>
<p>当我们使用 SET key value NX EX 30 这个命令进行加锁时，Redis 会把整个操作当作一个原子指令来执行。因为 Redis 的命令处理是单线程的，所以在同一时刻只能有一个命令在执行。</p>
<p>比如说两个客户端 A 和 B 同时请求同一个锁：</p>
<p>客户端A: SET lock_key uuid_a NX EX 30
客户端B: SET lock_key uuid_b NX EX 30
虽然这两个请求可能几乎同时到达 Redis 服务器，但 Redis 会严格按照到达的先后顺序来处理。假设 A 的请求先到，Redis 会先执行 A 的 SET 命令，这时 lock_key 被设置为 uuid_a。</p>
<p>当处理 B 的请求时，因为 lock_key 已经存在了，NX 条件不满足，所以 B 的 SET 命令会失败，返回 NULL。这样就保证了只有 A 能获取到锁。</p>
<p>关键点在于 NX 的语义：NOT EXISTS，只有在 key 不存在的时候才会设置成功。Redis 在执行这个命令时，会先检查 key 是否存在，如果不存在才会设置值，这整个过程是原子的，不会被其他命令打断。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="setnx有什么问题如何解决">SETNX有什么问题，如何解决？<a href="#setnx有什么问题如何解决" class="hash-link" aria-label="Direct link to SETNX有什么问题，如何解决？" title="Direct link to SETNX有什么问题，如何解决？">​</a></h3>
<p>使用 SETNX 创建分布式锁时，虽然可以通过设置过期时间来避免死锁，但会误删锁。比如线程 A 获取锁后，业务执行时间比较长，锁过期了。这时线程 B 获取到锁，但线程 A 执行完业务逻辑后，会尝试删除锁，这时候删掉的其实是线程 B 的锁。</p>
<p><img decoding="async" loading="lazy" alt="1756736812545" src="/doc/assets/images/1756736812545-6da8a6e681a3cc4bcf5bca40926bf5da.png" width="1298" height="1140" class="img_ev3q"></p>
<p>可以通过锁的自动续期机制来解决锁过期的问题，比如 Redisson 的看门狗机制，在后台启动一个定时任务，每隔一段时间就检查锁是否还被当前线程持有，如果是就自动延长过期时间。这样既避免了死锁，又防止了锁被提前释放。</p>
<p><img decoding="async" loading="lazy" alt="1756736824682" src="/doc/assets/images/1756736824682-6f34a840b4f4d4cf05edb265f4d77022.png" width="896" height="812" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redisson了解多少">Redisson了解多少？<a href="#redisson了解多少" class="hash-link" aria-label="Direct link to Redisson了解多少？" title="Direct link to Redisson了解多少？">​</a></h3>
<p>Redisson 是一个基于 Redis 的 Java 客户端，它不只是对 Redis 的操作进行简单地封装，还提供了很多分布式的数据结构和服务，比如最常用的分布式锁。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">RLock lock = redisson.getLock(&quot;lock&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">lock.lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // do something</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    lock.unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>Redisson 的分布式锁比 SETNX 完善的得多，它的看门狗机制可以让我们在获取锁的时候省去手动设置过期时间的步骤，它在内部封装了一个定时任务，每隔 10 秒会检查一次，如果当前线程还持有锁就自动续期 30 秒。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private Long tryAcquire(long waitTime, long leaseTime, TimeUnit unit, long threadId) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return get(tryAcquireAsync(waitTime, leaseTime, unit, threadId));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private &lt;T&gt; RFuture&lt;Long&gt; tryAcquireAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    RFuture&lt;Long&gt; ttlRemainingFuture;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (leaseTime != -1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 手动设置过期时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ttlRemainingFuture = tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 启用看门狗机制，使用默认的30秒过期时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ttlRemainingFuture = tryLockInnerAsync(waitTime, internalLockLeaseTime,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 处理获取锁成功的情况</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (e != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果获取锁成功且启用看门狗机制</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ttlRemaining == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (leaseTime != -1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                internalLockLeaseTime = unit.toMillis(leaseTime);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                scheduleExpirationRenewal(threadId); // 启动看门狗</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return ttlRemainingFuture;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>另外，Redisson 还提供了分布式限流器 RRateLimiter，基于令牌桶算法实现，用于控制分布式环境下的访问频率。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// API 接口限流</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@RestController</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ApiController {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Autowired</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private RedissonClient redissonClient;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @GetMapping(&quot;/api/data&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ResponseEntity&lt;?&gt; getData() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        RRateLimiter limiter = redissonClient.getRateLimiter(&quot;api.data&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        limiter.trySetRate(RateType.OVERALL, 100, 1, RateIntervalUnit.MINUTES);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (limiter.tryAcquire()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 处理请求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return ResponseEntity.ok(processData());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 限流触发</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return ResponseEntity.status(429).body(&quot;Rate limit exceeded&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="详细说说redisson的看门狗机制">详细说说Redisson的看门狗机制？<a href="#详细说说redisson的看门狗机制" class="hash-link" aria-label="Direct link to 详细说说Redisson的看门狗机制？" title="Direct link to 详细说说Redisson的看门狗机制？">​</a></h3>
<p>Redisson 的看门狗机制是一种自动续期机制，用于解决分布式锁的过期问题。</p>
<p>基本原理是这样的：当调用 lock() 方法加锁时，如果没有显式设置过期时间，Redisson 会默认给锁加一个 30 秒的过期时间，同时启用一个名为“看门狗”的定时任务，每隔 10 秒（默认是过期时间的 1/3），去检查一次锁是否还被当前线程持有，如果是，就自动续期，将过期时间延长到 30 秒。
<img decoding="async" loading="lazy" alt="1756736949971" src="/doc/assets/images/1756736949971-481dc06f1800f2e14e5adf1471cc4626.png" width="1768" height="768" class="img_ev3q"></p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 伪代码展示核心逻辑</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private void renewExpiration() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Timeout task = commandExecutor.getConnectionManager()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .newTimeout(new TimerTask() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void run(Timeout timeout) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 用 Lua 脚本检查并续期</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (redis.call(&quot;get&quot;, lockKey) == currentThreadId) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    redis.call(&quot;expire&quot;, lockKey, 30);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 递归调用，继续下一次续期</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    renewExpiration();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }, 10, TimeUnit.SECONDS);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>续期的 Lua 脚本会检查锁的 value 是否匹配当前线程，如果匹配就延长过期时间。这样就能保证只有锁的真正持有者才能续期。</p>
<p>当调用 unlock() 方法时，看门狗任务会被取消。或者如果业务逻辑执行完但忘记 unlock 了，看门狗也会帮我们自动检查锁，如果锁已经不属于当前线程了，也会自动停止续期。</p>
<p>这样我们就不用担心业务执行时间过长导致锁被提前释放，也避免了手动估算过期时间的麻烦，同时也解决了分布式环境下的死锁问题。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="看门狗机制中的检查锁过程是原子操作吗">看门狗机制中的检查锁过程是原子操作吗？<a href="#看门狗机制中的检查锁过程是原子操作吗" class="hash-link" aria-label="Direct link to 看门狗机制中的检查锁过程是原子操作吗？" title="Direct link to 看门狗机制中的检查锁过程是原子操作吗？">​</a></h3>
<p>是的，Redisson 使用了 Lua 脚本来保证锁检查的原子性。</p>
<p><img decoding="async" loading="lazy" alt="1756736994405" src="/doc/assets/images/1756736994405-da1ff842971e0eecfd5e83ca665e873e.png" width="1490" height="1588" class="img_ev3q"></p>
<p>Redis 在执行 Lua 脚本时，会把整个脚本当作一个命令来处理，期间不会执行其他命令。所以 hexists 检查和 expire 续期是原子执行的。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redlock你了解多少">Redlock你了解多少？<a href="#redlock你了解多少" class="hash-link" aria-label="Direct link to Redlock你了解多少？" title="Direct link to Redlock你了解多少？">​</a></h3>
<p>Redlock 是 Redis 作者 antirez 提出的一种分布式锁算法，用于解决单个 Redis 实例作为分布式锁时存在的单点故障问题。</p>
<p>Redlock 的核心思想是通过在多个完全独立的 Redis 实例上同时获取锁来实现容错。
minLocksAmount 方法返回的 locks.size()/2 + 1，正是 Redlock 算法要求的少数服从多数原则。failedLocksLimit 方法会计算允许失败的锁数量，确保即使部分实例失败，只要成功的实例数量超过一半就认为获取锁成功。</p>
<p>红锁会尝试依次向所有 Redis 实例获取锁，并记录成功获取的锁数量，当数量达到 minLocksAmount 时就认为获取成功，否则释放已获取的锁并返回失败。</p>
<p>虽然 Redlock 存在一些争议，比如说时钟漂移问题、网络分区导致的脑裂问题，但它仍然是一个相对成熟的分布式锁解决方案。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="红锁能不能保证百分百上锁">红锁能不能保证百分百上锁？<a href="#红锁能不能保证百分百上锁" class="hash-link" aria-label="Direct link to 红锁能不能保证百分百上锁？" title="Direct link to 红锁能不能保证百分百上锁？">​</a></h3>
<p>不能，Redlock 无法保证百分百上锁成功，这是由分布式系统的本质特性决定的。</p>
<p>当有网络分区时，客户端可能无法与足够数量的 Redis 实例通信。比如在 5 个 Redis 实例的部署中，如果网络分区导致客户端只能访问到 2 个实例，那么无论如何都无法满足红锁要求的少数服从多数原则，获取锁的时候必然失败。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws InterruptedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (ListIterator&lt;RLock&gt; iterator = locks.listIterator(); iterator.hasNext();) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        RLock lock = iterator.next();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean lockAcquired;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lockAcquired = lock.tryLock(awaitTime, newLeaseTime, TimeUnit.MILLISECONDS);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (RedisResponseTimeoutException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lockAcquired = false; // 网络超时导致失败</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lockAcquired = false; // 其他异常导致失败</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果剩余可尝试的实例数量不足以达到多数派，直接退出</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (locks.size() - acquiredLocks.size() == failedLocksLimit()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 检查是否达到多数派要求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (acquiredLocks.size() &gt;= minLocksAmount(locks)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        unlockInner(acquiredLocks);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return false; // 未达到多数派，获取失败</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>时钟漂移也会影响成功率。即使所有实例都可达，如果各个 Redis 实例之间存在明显的时钟漂移，或者客户端在获取锁的过程中耗时过长，比如网络延迟、GC 停顿等，都可能会导致锁在获取完成前就过期，从而获取失败。</p>
<p>在实际应用中，可以通过重试机制来提高锁的成功率。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">for (int i = 0; i &lt; maxRetries; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (redLock.tryLock(waitTime, leaseTime, TimeUnit.MILLISECONDS)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Thread.sleep(retryDelay);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">return false;</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="项目中有用到分布式锁吗">项目中有用到分布式锁吗？<a href="#项目中有用到分布式锁吗" class="hash-link" aria-label="Direct link to 项目中有用到分布式锁吗？" title="Direct link to 项目中有用到分布式锁吗？">​</a></h3>
<p>在PmHub项目中，我有使用 Redission 的分布式锁来确保流程状态的更新按顺序执行，且不被其他流程服务干扰。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="底层结构">底层结构<a href="#底层结构" class="hash-link" aria-label="Direct link to 底层结构" title="Direct link to 底层结构">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis都有哪些底层数据结构">🌟Redis都有哪些底层数据结构？<a href="#redis都有哪些底层数据结构" class="hash-link" aria-label="Direct link to 🌟Redis都有哪些底层数据结构？" title="Direct link to 🌟Redis都有哪些底层数据结构？">​</a></h3>
<p>Redis 之所以快，除了基于内存读写之外，还有很重要的一点就是它精心设计的底层数据结构。Redis 总共有 8 种核心的底层数据结构，我按照重要程度来说一下。
<img decoding="async" loading="lazy" alt="1756737123972" src="/doc/assets/images/1756737123972-1f756ec1961d3ac469b6165aca30aa98.png" width="1151" height="563" class="img_ev3q"></p>
<p>首先是 SDS，这是 Redis 自己实现的动态字符串，它保留了 C 语言原生的字符串长度，所以获取长度的时间复杂度是 O(1)，在此基础上还支持动态扩容，以及存储二进制数据。
<img decoding="async" loading="lazy" alt="1756737140624" src="/doc/assets/images/1756737140624-0c7ee3b0494db3ec0035694cc9be1596.png" width="655" height="438" class="img_ev3q">
然后是字典，更底层是用数组+链表实现的哈希表。它的设计很巧妙，用了两个哈希表，平时用第一个，rehash 的时候用第二个，这样可以渐进式地进行扩容，不会阻塞太久。
<img decoding="async" loading="lazy" alt="1756737153378" src="/doc/assets/images/1756737153378-a92187a22de53e47f4bfa7e28adcc9fe.png" width="1027" height="796" class="img_ev3q"><br>
<!-- -->接下来压缩列表 ziplist，这个设计很有意思。Redis 为了节省内存，设计了这种紧凑型的数据结构，把所有元素连续存储在一块内存里。但是它有个致命问题叫&quot;连锁更新&quot;，就是当我们修改一个元素的时候，可能会导致后面所有的元素都要重新编码，性能会急剧下降。
<img decoding="async" loading="lazy" alt="1756737167133" src="/doc/assets/images/1756737167133-a0e6d532870a9d1d71c55fd53cc0fab1.png" width="1021" height="600" class="img_ev3q">
为了解决压缩列表的问题，Redis 后来设计了 quicklist。这个设计思路很聪明，它把 ziplist 拆分成小块，然后用双向链表把这些小块串起来。这样既保持了 ziplist 节省内存的优势，又避免了连锁更新的问题，因为每个小块的 ziplist 都不会太大。
<img decoding="async" loading="lazy" alt="1756737184298" src="/doc/assets/images/1756737184298-9d90277481857320a30ba18aef363f82.png" width="884" height="593" class="img_ev3q">
再后来，Redis 又设计了 listpack，这个可以说是 ziplist 的完美替代品。它最大的特点是每个元素只记录自己的长度，不记录前一个元素的长度，这样就彻底解决了连锁更新的问题。Redis 5.0 已经用 listpack 替换了 ziplist。
<img decoding="async" loading="lazy" alt="1756737205785" src="/doc/assets/images/1756737205785-a68694c771c944db2c71a30933666e03.png" width="1960" height="826" class="img_ev3q">
跳表skiplist 主要用在 ZSet 中。它的设计很巧妙，通过多层指针来实现快速查找，平均时间复杂度是 O(log N)。相比红黑树，跳表的实现更简单，而且支持范围查询，这对 Redis 的有序集合来说很重要。</p>
<p>还有整数集合intset，当 Set 中都是整数且元素数量较少时使用，内部是一个有序数组，查找用的二分法。
<img decoding="async" loading="lazy" alt="1756737243177" src="/doc/assets/images/1756737243177-a6c53dc3c78c9856216ead7de105ae72.png" width="1889" height="1039" class="img_ev3q">
最后是双向链表LinkedList，早期版本的 Redis 会在 List 中用到，但 Redis 3.2 后就被 quicklist 替代了，因为纯链表的问题是内存不连续，影响 CPU 缓存性能。
<img decoding="async" loading="lazy" alt="1756737267626" src="/doc/assets/images/1756737267626-6569a94d05d4795a5a0fb88002d665b5.png" width="1938" height="1128" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="简单介绍下链表">简单介绍下链表？<a href="#简单介绍下链表" class="hash-link" aria-label="Direct link to 简单介绍下链表？" title="Direct link to 简单介绍下链表？">​</a></h3>
<p>Redis 的 linkedlist 是⼀个双向⽆环链表结构，和 Java 中的 LinkedList 类似。</p>
<p>节点由 listNode 表示，每个节点都有指向其前置节点和后置节点的指针，头节点的前置和尾节点的后置均指向 null。
<img decoding="async" loading="lazy" alt="1756737308299" src="/doc/assets/images/1756737308299-6c7b2dc89cf110132df9734fbe2d319d.png" width="964" height="708" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="关于整数集合能再详细说说吗">关于整数集合，能再详细说说吗？<a href="#关于整数集合能再详细说说吗" class="hash-link" aria-label="Direct link to 关于整数集合，能再详细说说吗？" title="Direct link to 关于整数集合，能再详细说说吗？">​</a></h3>
<p>整数集合是 Redis 中一个非常精巧的数据结构，当一个 Set 只包含整数元素，并且数量不多时，默认不超过 512 个，Redis 就会用 intset 来存储这些数据。
<img decoding="async" loading="lazy" alt="1756737319518" src="/doc/assets/images/1756737319518-12fb92e62d0733a26bd2440588187e98.png" width="1013" height="342" class="img_ev3q">
intset 最有意思的地方是类型升级机制。它有三种编码方式：16位、32位和 64位，会根据存储的整数大小动态调整。比如原来存的都是小整数，用 16 位编码就够了，但突然插入了一个很大的数，超出了 16 位的范围，这时整个数组会升级到 32 位编码。</p>
<div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">typedef</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">intset</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token class-name">uint32_t</span><span class="token plain"> encoding</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain">   </span><span class="token comment" style="color:#999988;font-style:italic">// 编码方式：16位、32位或64位</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token class-name">uint32_t</span><span class="token plain"> length</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain">     </span><span class="token comment" style="color:#999988;font-style:italic">// 元素数量</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token class-name">int8_t</span><span class="token plain"> contents</span><span class="token punctuation" style="color:#393A34">[</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain">   </span><span class="token comment" style="color:#999988;font-style:italic">// 保存元素的数组</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"> intset</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre></div></div>
<p>当然了，这种升级是有代价的，因为需要重新分配内存并复制数据，并且是不可逆的，但它的好处是可以节省内存空间，特别是在存储大量小整数时。</p>
<p>另外，所有元素在数组中按照从小到大的顺序排列，这样就可以使用二分查找来定位元素，时间复杂度为 O(log N)</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="说一下zset-的底层原理">说一下zset 的底层原理？<a href="#说一下zset-的底层原理" class="hash-link" aria-label="Direct link to 说一下zset 的底层原理？" title="Direct link to 说一下zset 的底层原理？">​</a></h3>
<p>ZSet 是 Redis 最复杂的数据类型，它有两种底层实现方式：压缩列表和跳表。
<img decoding="async" loading="lazy" alt="1756737371705" src="/doc/assets/images/1756737371705-d9238a202b3393ad03f61e2d35abf235.png" width="616" height="352" class="img_ev3q">
当保存的元素数量少于 128 个，且保存的所有元素大小都小于 64 字节时，Redis 会采用压缩列表的编码方式；否则就用跳表。</p>
<p>当然，这两个条件都可以通过参数进行调整。</p>
<p>选择压缩列表作为底层实现时，每个元素会使用两个紧挨在一起的节点来保存：第一个节点保存元素的成员，第二个节点保存元素的分值。
<img decoding="async" loading="lazy" alt="1756737423334" src="/doc/assets/images/1756737423334-7243b99a2b2bf79ca74ee056cd9b9b39.png" width="669" height="240" class="img_ev3q">
所有元素按分值从小到大有序排列，小的放在靠近表头的位置，大的放在靠近表尾的位置。</p>
<p>但跳表的缺点是查找只能按顺序进行，时间复杂度为 O(N)，而且在最坏的情况下，插入和删除操作还可能会引起连锁更新。</p>
<p>当元素数量较多或元素较大时，Redis 会使用 skiplist 的编码方式；这个设计非常的巧妙，同时使用了两种数据结构：</p>
<div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">typedef</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">zset</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    zskiplist </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">zsl</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">// 跳跃表</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dict </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">dict</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain">      </span><span class="token comment" style="color:#999988;font-style:italic">// 字典</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"> zset</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre></div></div>
<p>跳表按分数有序保存所有元素，且支持范围查询（如 ZRANGE、ZRANGEBYSCORE），平均时间复杂度为 O(log N)。而哈希表则用来存储成员和分值的映射关系，查找时间复杂度为 O(1)。
<img decoding="async" loading="lazy" alt="1756737460637" src="/doc/assets/images/1756737460637-b3f8e5881d9e9145300a4b0e15e9a76f.png" width="1031" height="741" class="img_ev3q">
虽然同时使用两种结构，但它们会通过指针来共享相同元素的成员和分值，因此不会浪费额外的内存</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="你知道为什么redis-70要用listpack来替代ziplist吗">你知道为什么Redis 7.0要用listpack来替代ziplist吗？<a href="#你知道为什么redis-70要用listpack来替代ziplist吗" class="hash-link" aria-label="Direct link to 你知道为什么Redis 7.0要用listpack来替代ziplist吗？" title="Direct link to 你知道为什么Redis 7.0要用listpack来替代ziplist吗？">​</a></h3>
<p>答：主要是为了解决压缩列表的一个核心问题——连锁更新。在压缩列表中，每个节点都需要记录前一个节点的长度信息。
<img decoding="async" loading="lazy" alt="1756737494710" src="/doc/assets/images/1756737494710-495c5662e3682334dd6a4d89d83282b3.png" width="1200" height="581" class="img_ev3q">
当插入或删除一个节点时，如果这个操作导致某个节点的长度发生了变化，那么后续的节点可能都需要更新它们存储的&quot;前一个节点长度&quot;字段。最坏的情况下，一次操作可能触发整个链表的更新，时间复杂度会从 O(1)退化到 O(n²)。</p>
<p>而 listpack 的设计理念完全不同。它让每个节点只记录自己的长度信息，不再依赖前一个节点的长度。这样就从根本上避免了连锁更新的问题。
<img decoding="async" loading="lazy" alt="1756737539886" src="/doc/assets/images/1756737539886-821d713ab4e9aed88965cbc9f43cec08.png" width="2000" height="562" class="img_ev3q">
listpack 中的节点不再保存其前一个节点的长度，而是保存当前节点的编码类型、数据和长度。</p>
<p><img decoding="async" loading="lazy" alt="1756737550793" src="/doc/assets/images/1756737550793-1dadbac60115c8e7b531fa0686a5f101.png" width="2000" height="786" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="连锁更新是怎么发生的">连锁更新是怎么发生的？<a href="#连锁更新是怎么发生的" class="hash-link" aria-label="Direct link to 连锁更新是怎么发生的？" title="Direct link to 连锁更新是怎么发生的？">​</a></h3>
<p>比如说我们有一个压缩列表，其中有几个节点的长度都是 253 个字节。在 ziplist 的编码中，如果前一个节点的长度小于 254 字节，我们只需要 1 个字节来存储这个长度信息。
<img decoding="async" loading="lazy" alt="1756737573634" src="/doc/assets/images/1756737573634-9c0e52555e0525b77bb3cf54471596f4.png" width="1280" height="797" class="img_ev3q">
但如果在这些节点前面插入一个长度为 254 字节的节点，那么原来只需要 1 个字节存储长度的节点现在需要 5 个字节来存储长度信息。这就会导致后续所有节点的长度信息都需要更新。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis-为什么不用-c-语言的原生字符串">Redis 为什么不用 C 语言的原生字符串？<a href="#redis-为什么不用-c-语言的原生字符串" class="hash-link" aria-label="Direct link to Redis 为什么不用 C 语言的原生字符串？" title="Direct link to Redis 为什么不用 C 语言的原生字符串？">​</a></h3>
<p>第一，C 语言的字符串其实就是字符数组，以 \0 结尾，这意味着如果数据本身包含 \0 字节，就会被误认为字符串结束。但 Redis 需要存储各种类型的数据，包括图片、序列化对象等二进制数据，这些数据中很可能包含 \0。<br>
<!-- -->第二，如果需要获取字符串长度，C 语言只能调用 strlen() 函数，时间复杂度是 O(N)，因为要遍历整个字符串直到遇到 \0。</p>
<p>第三，C 语言的字符串不会自动检查边界，如果往一个字符数组里写入超过其容量的数据，就会出现缓冲区溢出。</p>
<p>第四，C 语言的字符串不支持动态扩容，如果需要修改内容，就必须重新分配内存并复制数据，开销很大。</p>
<p>Redis 设计的 SDS 完美解决了这些问题，获取长度可以直接通过 len 字段，时间复杂度为 O(1)；free 字段会记录剩余空间，因此 Redis 可以根据预分配策略动态扩容，不用在追加数据时重新分配内存；并且不依赖于 \0 结尾，可以存储任意二进制数据。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="你研究过-redis-的字典源码吗">你研究过 Redis 的字典源码吗？<a href="#你研究过-redis-的字典源码吗" class="hash-link" aria-label="Direct link to 你研究过 Redis 的字典源码吗？" title="Direct link to 你研究过 Redis 的字典源码吗？">​</a></h3>
<p>是的，有研究过。Redis 的字典分为三层，最外层是一个 dict 结构，包含两个哈希表 ht[0] 和 ht[1]，用于存储键值对。每个哈希表由一个数组和链表组成，数组用于快速定位，链表用于解决哈希冲突。
<img decoding="async" loading="lazy" alt="1756741114121" src="/doc/assets/images/1756741114121-53d72a35f96fc688228fe17c262483da.png" width="1179" height="581" class="img_ev3q"></p>
<div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">// 最外层的字典结构</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">typedef</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">dict</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dictht ht</span><span class="token punctuation" style="color:#393A34">[</span><span class="token number" style="color:#36acaa">2</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain">       </span><span class="token comment" style="color:#999988;font-style:italic">// 两个哈希表！这是关键</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">long</span><span class="token plain"> rehashidx</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain">     </span><span class="token comment" style="color:#999988;font-style:italic">// rehash索引，-1表示没有进行rehash</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">// ...</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"> dict</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// 哈希表结构</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">typedef</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">dictht</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dictEntry </span><span class="token operator" style="color:#393A34">*</span><span class="token operator" style="color:#393A34">*</span><span class="token plain">table</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">// 哈希表数组</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">unsigned</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">long</span><span class="token plain"> size</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">// 哈希表大小</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">unsigned</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">long</span><span class="token plain"> sizemask</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">// 哈希表大小掩码，用于计算索引值</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">unsigned</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">long</span><span class="token plain"> used</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">// 该哈希表已有节点的数量</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"> dictht</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// 哈希表节点</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">typedef</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">dictEntry</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">key</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain">              </span><span class="token comment" style="color:#999988;font-style:italic">// 键</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain">                 </span><span class="token comment" style="color:#999988;font-style:italic">// 值</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">dictEntry</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">next</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">// 指向下个哈希表节点，形成链表</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"> dictEntry</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre></div></div>
<p>字典最核心的特点是渐进式 rehash，这是我觉得最精彩的部分。传统的哈希表扩容都是一次性完成的，但 Redis 不是这样的。</p>
<p>当负载因子触发 rehash 条件时，Redis 会为哈希表1 分配新的空间，通常是哈希表 0 的两倍大小，然后将 rehashidx 设置为 0。</p>
<p>接下来的关键是，Redis 不会一次性把所有数据从哈希表0 迁移到哈希表1，而是每次操作字典时，顺便迁移哈希表0 中 rehashidx 位置上的所有键值对。迁移完一个槽位后，rehashidx 递增，直到整个哈希表0 迁移完毕。
<img decoding="async" loading="lazy" alt="1756741159057" src="/doc/assets/images/1756741159057-c230636ae9eaf3b69589ee730c01a7df.png" width="3378" height="2989" class="img_ev3q">
这种设计的巧妙之处在于把 rehash 的开销分摊到了每次操作中。假设有一个几百万键的哈希表，如果一次性 rehash 可能需要几百毫秒，这对单线程的 Redis 来说是灾难性的。但通过渐进式 rehash，每次操作只增加很少的额外开销，用户基本感觉不到延迟。</p>
<p>在 rehash 期间，查找操作会先查 哈希表 0，没找到再查哈希表 1；但是新插入的数据只会放到哈希表 1 中。这样既可以保证数据的完整性，又能避免数据的重复。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="遇到哈希冲突怎么办">遇到哈希冲突怎么办？<a href="#遇到哈希冲突怎么办" class="hash-link" aria-label="Direct link to 遇到哈希冲突怎么办？" title="Direct link to 遇到哈希冲突怎么办？">​</a></h3>
<p>Redis 是通过链地址法来解决哈希冲突的，每个哈希表的槽位实际上是一个链表的头指针，当多个键的哈希值映射到同一个槽位时，这些键会以链表的形式串联起来。
<img decoding="async" loading="lazy" alt="1756741208371" src="/doc/assets/images/1756741208371-be532883482f42d03d1c25a24a447c41.png" width="789" height="329" class="img_ev3q">
具体实现上，Redis 会通过哈希表节点的 next 指针，指向下一个具有相同哈希值的节点。当发生冲突时，新的键值对会插入到链表的头部，时间复杂度是 O(1)。查找时需要遍历整个链表，最坏的情况下时间复杂度为 O(n)，但通常链表都比较短。</p>
<p>另外，Redis 设计的哈希函数在分布上也比较均匀，能够有效减少哈希冲突的发生。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/* MurmurHash2, by Austin Appleby</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Note - This code makes a few assumptions about how your machine behaves -</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 1. We can read a 4-byte value from any address without crashing</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 2. sizeof(int) == 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * And it has a few limitations -</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 1. It will not work incrementally.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 2. It will not produce the same results on little-endian and big-endian</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *    machines.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unsigned int dictGenHashFunction(const void *key, int len) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* &#x27;m&#x27; and &#x27;r&#x27; are mixing constants generated offline.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       They&#x27;re not really &#x27;magic&#x27;, they just happen to work well.  */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    uint32_t seed = dict_hash_function_seed;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const uint32_t m = 0x5bd1e995;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const int r = 24;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* Initialize the hash to a &#x27;random&#x27; value */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    uint32_t h = seed ^ len;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* Mix 4 bytes at a time into the hash */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const unsigned char *data = (const unsigned char *)key;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while(len &gt;= 4) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        uint32_t k = *(uint32_t*)data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        k *= m;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        k ^= k &gt;&gt; r;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        k *= m;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        h *= m;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        h ^= k;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        data += 4;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        len -= 4;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* Handle the last few bytes of the input array  */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    switch(len) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case 3: h ^= data[2] &lt;&lt; 16;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case 2: h ^= data[1] &lt;&lt; 8;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case 1: h ^= data[0]; h *= m;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* Do a few final mixes of the hash to ensure the last few</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       * bytes are well-incorporated. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    h ^= h &gt;&gt; 13;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    h *= m;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    h ^= h &gt;&gt; 15;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return (unsigned int)h;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="你了解跳表吗">🌟你了解跳表吗？<a href="#你了解跳表吗" class="hash-link" aria-label="Direct link to 🌟你了解跳表吗？" title="Direct link to 🌟你了解跳表吗？">​</a></h3>
<p>跳表是一种非常巧妙的数据结构，它在有序链表的基础上建立了多层索引，最底层包含所有数据，每往上一层，节点数量就减少一半。
<img decoding="async" loading="lazy" alt="1756741244328" src="/doc/assets/images/1756741244328-3996092cf952e85fb852e8743269e527.png" width="927" height="148" class="img_ev3q">
它的核心思想是&quot;用空间换时间&quot;，通过多层索引来跳过大量节点，从而提高查找效率。</p>
<p><img decoding="async" loading="lazy" alt="1756741261042" src="/doc/assets/images/1756741261042-0b3ef3f0cd19f799fc82b7f40a7e7d61.png" width="1122" height="457" class="img_ev3q">
每个节点有 50% 的概率只在第 1 层出现，25% 的概率在第 2 层出现，依此类推。查找的时候从最高层开始水平移动，当下一个节点值大于目标时，就向下跳一层，直到找到目标节点。
<img decoding="async" loading="lazy" alt="1756741300958" src="/doc/assets/images/1756741300958-68f7f3c660ced59922489297ca98a879.png" width="1432" height="754" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="怎么往跳表插入节点呢">怎么往跳表插入节点呢？<a href="#怎么往跳表插入节点呢" class="hash-link" aria-label="Direct link to 怎么往跳表插入节点呢？" title="Direct link to 怎么往跳表插入节点呢？">​</a></h3>
<p>首先是找到插入位置，从最高层的头节点开始，在每一层都找到应该插入位置的前驱节点，用一个 update 数组把这些前驱节点记录下来。这个查找过程和普通查找一样，在每层向右移动直到下个节点的值大于要插入的值，然后下降到下一层。</p>
<div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">// 记录每层的插入位置</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">zskiplistNode </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">update</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">ZSKIPLIST_MAXLEVEL</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">zskiplistNode </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">x</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> i</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> level</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// 从最高层开始查找</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">x </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> zsl</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">header</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">for</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">i </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> zsl</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">level</span><span class="token operator" style="color:#393A34">-</span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> i </span><span class="token operator" style="color:#393A34">&gt;=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> i</span><span class="token operator" style="color:#393A34">--</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">// 在当前层水平移动，找到插入位置</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">while</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">x</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">level</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">forward </span><span class="token operator" style="color:#393A34">&amp;&amp;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">x</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">level</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">forward</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">score </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain"> score </span><span class="token operator" style="color:#393A34">||</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">x</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">level</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">forward</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">score </span><span class="token operator" style="color:#393A34">==</span><span class="token plain"> score </span><span class="token operator" style="color:#393A34">&amp;&amp;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             </span><span class="token function" style="color:#d73a49">sdscmp</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">x</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">level</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">forward</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">ele</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> ele</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        x </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> x</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">level</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">forward</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    update</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> x</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">// 记录每层的前驱节点</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre></div></div>
<p>接下来随机生成新节点的层数。通常用一个循环，每次有 50% 的概率继续往上，直到随机失败或达到最大层数限制。</p>
<div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">// Redis 中的随机层数生成</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">zslRandomLevel</span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">void</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> level </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">while</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">(</span><span class="token function" style="color:#d73a49">random</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token operator" style="color:#393A34">&amp;</span><span class="token number" style="color:#36acaa">0xFFFF</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">ZSKIPLIST_P </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0xFFFF</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        level </span><span class="token operator" style="color:#393A34">+=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">return</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">level </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain"> ZSKIPLIST_MAXLEVEL</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">?</span><span class="token plain"> level </span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> ZSKIPLIST_MAXLEVEL</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// 生成新节点的层数</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">level </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">zslRandomLevel</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre></div></div>
<p>创建新节点后，从底层开始到新节点的最高层，在每一层都进行标准的链表插入操作。这一步要利用之前记录的 update 数组，将新节点插入到正确位置，然后更新前后指针的连接关系。</p>
<div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">// 更新前进指针</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">for</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">i </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> i </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain"> level</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> i</span><span class="token operator" style="color:#393A34">++</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">level</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">forward </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> update</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">level</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">forward</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    update</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">level</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">forward </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> x</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">// 更新跨度信息</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">level</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">span </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> update</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">level</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">span </span><span class="token operator" style="color:#393A34">-</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">rank</span><span class="token punctuation" style="color:#393A34">[</span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">-</span><span class="token plain"> rank</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    update</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">level</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">span </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">rank</span><span class="token punctuation" style="color:#393A34">[</span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">-</span><span class="token plain"> rank</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">+</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// 更新未涉及层的跨度</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">for</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">i </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> level</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> i </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain"> zsl</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">level</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> i</span><span class="token operator" style="color:#393A34">++</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    update</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">level</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">span</span><span class="token operator" style="color:#393A34">++</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// 更新后退指针</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">x</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">backward </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">update</span><span class="token punctuation" style="color:#393A34">[</span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">==</span><span class="token plain"> zsl</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">header</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">?</span><span class="token plain"> </span><span class="token constant" style="color:#36acaa">NULL</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> update</span><span class="token punctuation" style="color:#393A34">[</span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">x</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">level</span><span class="token punctuation" style="color:#393A34">[</span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">forward</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">level</span><span class="token punctuation" style="color:#393A34">[</span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">forward</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">backward </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> x</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">else</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    zsl</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">tail </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> x</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">// 更新跳表长度</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">zsl</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">length</span><span class="token operator" style="color:#393A34">++</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre></div></div>
<p>我们来模拟一个跳表的插入过程，假设插入的数据依次是 22、19、7、3、37、11、26。</p>
<p><img decoding="async" loading="lazy" alt="1756741370982" src="/doc/assets/images/1756741370982-d6edfd176c1fde9f0e650d8a0439eafd.png" width="1141" height="1338" class="img_ev3q">
那假如我们在一个已经分布了 1、14、27、31、44、56、63、70、80、91 的跳表中插入一个 67 的节点，插入过程是这样的：</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="zset为什么要使用跳表呢">zset为什么要使用跳表呢？<a href="#zset为什么要使用跳表呢" class="hash-link" aria-label="Direct link to zset为什么要使用跳表呢？" title="Direct link to zset为什么要使用跳表呢？">​</a></h3>
<p>第一，跳表天然就是有序的数据结构，查找、插入和删除都能保持 O(log n) 的时间复杂度。</p>
<p>第二，跳表支持范围查询，找到起始位置后可以直接沿着底层链表顺序遍历，满足 ZRANGE 按排名获取元素，或者 ZRANGEBYSCORE 按分值范围获取元素。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="跳表是如何定义的呢">跳表是如何定义的呢？<a href="#跳表是如何定义的呢" class="hash-link" aria-label="Direct link to 跳表是如何定义的呢？" title="Direct link to 跳表是如何定义的呢？">​</a></h3>
<p>跳表本质上是一个多层链表，底层是一个包含所有元素的有序链表，上一层作为索引层，包含了下一层的部分节点；层数通过随机算法确定，理论上可以无限高。
<img decoding="async" loading="lazy" alt="1756741424469" src="/doc/assets/images/1756741424469-703b88b417a4384d5c3324a2a6de90ef.png" width="1502" height="643" class="img_ev3q">
跳表节点包含分值 score、成员对象 obj、一个后退指针 backward，以及一个层级数组 level。每个层级包含 forward 前进指针和 span 跨度信息。</p>
<div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">typedef</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">skiplistNode</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">double</span><span class="token plain"> score</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain">                    </span><span class="token comment" style="color:#999988;font-style:italic">// 分值（用于排序）</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    robj </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">obj</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain">                      </span><span class="token comment" style="color:#999988;font-style:italic">// 数据对象</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">skiplistNode</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">backward</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain">   </span><span class="token comment" style="color:#999988;font-style:italic">// 后退指针</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">skiplistLevel</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">skiplistNode</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">forward</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">// 前进指针</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">unsigned</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> span</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain">           </span><span class="token comment" style="color:#999988;font-style:italic">// 跨度（到下个节点的距离）</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"> level</span><span class="token punctuation" style="color:#393A34">[</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain">                      </span><span class="token comment" style="color:#999988;font-style:italic">// 层级数组</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"> skiplistNode</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre></div></div>
<p>跳表本身包含头尾节点指针、节点总数 length 和当前最大层数 level。</p>
<div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">typedef</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">skiplist</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">skiplistNode</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">header</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">tail</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">// 头尾节点</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">unsigned</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">long</span><span class="token plain"> length</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain">               </span><span class="token comment" style="color:#999988;font-style:italic">// 节点数量</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> level</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain">                         </span><span class="token comment" style="color:#999988;font-style:italic">// 最大层数</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"> skiplist</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="span-跨度有什么用">span 跨度有什么用？<a href="#span-跨度有什么用" class="hash-link" aria-label="Direct link to span 跨度有什么用？" title="Direct link to span 跨度有什么用？">​</a></h3>
<p>span 记录了当前节点到下一节点之间，底层到底跨越了几个节点，它的主要作用是快速找到 ZSet 中某个分值的排名。
<img decoding="async" loading="lazy" alt="1756741736509" src="/doc/assets/images/1756741736509-7e01d05805fa0cc8a73790d9d11beb63.png" width="1430" height="440" class="img_ev3q">
比如说我们执行 ZRANK 命令时，如果没有 span，就需要从头节点开始遍历每个节点，直到找到目标分值，这样时间复杂度是 O(n)。
但有了 span，我们在从高层往低层搜索的时候，可以直接跳过一些节点，快速定位到目标分值所在的范围。这样就能把时间复杂度降到 O(log n)。</p>
<div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">long</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">skiplistGetRank</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">skiplist </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">zsl</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">double</span><span class="token plain"> score</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> robj </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">obj</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    skiplistNode </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">x </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> zsl</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">header</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">unsigned</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">long</span><span class="token plain"> rank </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">// 从最高层开始查找</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">for</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> i </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> zsl</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">level </span><span class="token operator" style="color:#393A34">-</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> i </span><span class="token operator" style="color:#393A34">&gt;=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> i</span><span class="token operator" style="color:#393A34">--</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">while</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">x</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">level</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">forward </span><span class="token operator" style="color:#393A34">&amp;&amp;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">x</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">level</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">forward</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">score </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain"> score </span><span class="token operator" style="color:#393A34">||</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">x</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">level</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">forward</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">score </span><span class="token operator" style="color:#393A34">==</span><span class="token plain"> score </span><span class="token operator" style="color:#393A34">&amp;&amp;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 </span><span class="token function" style="color:#d73a49">compareStringObjects</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">x</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">level</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">forward</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">obj</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> obj</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            rank </span><span class="token operator" style="color:#393A34">+=</span><span class="token plain"> x</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">level</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">span</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">// 累加跨度</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            x </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> x</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">level</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">forward</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token comment" style="color:#999988;font-style:italic">// 找到目标节点</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">x</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">level</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">forward </span><span class="token operator" style="color:#393A34">&amp;&amp;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            x</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">level</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">forward</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">score </span><span class="token operator" style="color:#393A34">==</span><span class="token plain"> score </span><span class="token operator" style="color:#393A34">&amp;&amp;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><span class="token function" style="color:#d73a49">equalStringObjects</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">x</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">level</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">forward</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">obj</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> obj</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            rank </span><span class="token operator" style="color:#393A34">+=</span><span class="token plain"> x</span><span class="token operator" style="color:#393A34">-&gt;</span><span class="token plain">level</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">span</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><span class="token keyword" style="color:#00009f">return</span><span class="token plain"> rank</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">return</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="为什么跳表的范围查询效率比字典高">为什么跳表的范围查询效率比字典高？<a href="#为什么跳表的范围查询效率比字典高" class="hash-link" aria-label="Direct link to 为什么跳表的范围查询效率比字典高？" title="Direct link to 为什么跳表的范围查询效率比字典高？">​</a></h3>
<p>字典是通过哈希函数将键值对分散存储的，元素在内存中是无序分布的，没有任何顺序关系。而跳表本身就是有序的数据结构，所有元素按照分值从小到大排列。
<img decoding="async" loading="lazy" alt="1756741793308" src="/doc/assets/images/1756741793308-d93ef6c25106875796d064e498ee9eae.png" width="1512" height="468" class="img_ev3q">
当需要进行范围查询时，字典必须遍历所有元素，逐个检查每个元素是否在指定范围内，时间复杂度是 O(n)。比如要找分值在 60 到 80 之间的所有元素，字典只能把整个哈希表扫描一遍，因为它无法知道符合条件的元素在哪里。</p>
<p>而跳表的范围查询就高效多了。首先用 O(log n) 时间找到范围的起始位置，然后沿着底层的有序链表顺序遍历，直到超出范围为止。总时间复杂度是 O(log n + k)，其中 k 是结果集的大小。这种效率差异在数据量大的时候非常明显。
<img decoding="async" loading="lazy" alt="1756741810158" src="/doc/assets/images/1756741810158-8ee51d7dadb205192088b4054bbdffb5.png" width="1185" height="723" class="img_ev3q">
这也是为什么 Redis 的 zset 要用跳表而不是纯哈希表的重要原因，因为 zset 经常需要 ZRANGE、ZRANGEBYSCORE 这类范围操作。实际上 Redis 的 zset 是跳表和哈希表的组合：跳表保证有序性支持范围查询，哈希表保证 O(1) 的单点查找效率，两者互补。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="压缩列表了解吗">压缩列表了解吗？<a href="#压缩列表了解吗" class="hash-link" aria-label="Direct link to 压缩列表了解吗？" title="Direct link to 压缩列表了解吗？">​</a></h3>
<p>答：压缩列表是 Redis 为了节省内存而设计的一种紧凑型数据结构，它会把所有数据连续存储在一块内存当中。</p>
<p>整个结构包含头部信息，如总的字节数、尾部偏移量、节点数量，以及连续的节点数据。
<img decoding="async" loading="lazy" alt="1756741838018" src="/doc/assets/images/1756741838018-062e6e3b7f6f6c01eaf243fa8e853145.png" width="1097" height="98" class="img_ev3q">
当 list、hash 和 set 的数据量较小且值都不大时，底层会使用压缩列表来实现。</p>
<p>通常情况在，每个节点包含三个部分：前一个节点的长度、编码类型和实际的数据。
<img decoding="async" loading="lazy" alt="1756741863693" src="/doc/assets/images/1756741863693-1d6adb0fc6203842b9c10f1a5b263c85.png" width="1526" height="482" class="img_ev3q">
前一个节点的长度是为了支持从后往前遍历；当前一个节点的长度小于 254 字节时，使用 1 字节存储；否则用 5 字节存储，第一个字节设置为 254，后四个字节存储实际长度。</p>
<p><img decoding="async" loading="lazy" alt="1756741886579" src="/doc/assets/images/1756741886579-865e89ef37489391abbc154ce228322f.png" width="1706" height="1330" class="img_ev3q">
编码类型会根据数据的实际情况选择最紧凑的存储方式。</p>
<p><img decoding="async" loading="lazy" alt="1756741899345" src="/doc/assets/images/1756741899345-e3d0d588e2909299176d5e0ac5c1f9ce.png" width="972" height="177" class="img_ev3q">
但压缩列表有个致命问题，就是连锁更新。当插入或删除节点导致某个节点长度发生变化时，可能会影响后续所有节点存储的“前一个节点长度”字段，最坏情况下时间复杂度会退化到 O(n²)。</p>
<p><img decoding="async" loading="lazy" alt="1756741915311" src="/doc/assets/images/1756741915311-be8185babc51bfb179671d49a7bb664a.png" width="815" height="1075" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="ziplist-的节点数量会超过-65535-吗">ziplist 的节点数量会超过 65535 吗？<a href="#ziplist-的节点数量会超过-65535-吗" class="hash-link" aria-label="Direct link to ziplist 的节点数量会超过 65535 吗？" title="Direct link to ziplist 的节点数量会超过 65535 吗？">​</a></h3>
<p>不会。</p>
<p>Zllen 字段的类型是 uint16_t，最大值为 65535，也就是 2 的 16次方，所以压缩列表的节点数量不会超过 65535。</p>
<p>当节点数量小于 65535 时，该字段会存储实际的数量；否则该字段就固定为 65535，实际存储的数量需要逐个遍历节点来计算。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="ziplist-的编码类型了解多少">ziplist 的编码类型了解多少？<a href="#ziplist-的编码类型了解多少" class="hash-link" aria-label="Direct link to ziplist 的编码类型了解多少？" title="Direct link to ziplist 的编码类型了解多少？">​</a></h3>
<p>ziplist 的编码类型设计得很精巧，主要分为字符串编码和整数编码两大类，目的是用最少的字节存储数据。</p>
<p>比如 0 到 12 这些小整数直接编码在 type 字段中，只需要 1 个字节。
编码	长度	描述
11000000	1字节	int16_t类型整数，2 字节
11010000	1字节	int32_t类型整数，4 字节
11100000	1字节	int64_t类型整数，8 字节
11110000	1字节	24位有符号整数 ，3 字节
1111xxxx	1字节	数据范围在[0-12]，数据包含在编码中
<img decoding="async" loading="lazy" alt="1756742267322" src="/doc/assets/images/1756742267322-3b1808807a7c7b56ea7b32c9170f906a.png" width="4558" height="3310" class="img_ev3q">
对于字符串编码，根据字符串长度有三种格式。长度小于 63 字节的用 00 开头的单字节编码，剩余 6 位存储长度。长度在 63 到 16383 之间的用 01 开头的双字节编码，剩余 14 位存储长度。超过 16383 字节的用 10 开头，后面跟 4 字节存储长度。</p>
<p>编码	长度	描述
00pppppp	1字节	0-63 字节的字符串
01pppppp qqqqqqqq	2字节	64-16383字节的字符串
10______ qqqqqqqq rrrrrrrr ssssssss tttttttt	5字节	16384-4294967295字节的字符串</p>
<p><img decoding="async" loading="lazy" alt="1756742290634" src="/doc/assets/images/1756742290634-7964d58408eb8a6506be7038ad773b42.png" width="2628" height="1760" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="quicklist-了解吗">quicklist 了解吗？<a href="#quicklist-了解吗" class="hash-link" aria-label="Direct link to quicklist 了解吗？" title="Direct link to quicklist 了解吗？">​</a></h3>
<p>quicklist 是 Redis 在 3.2 版本时引入的，专门用于 List 的底层实现，它实际上是一个混合型数据结构，结合了压缩列表和双向链表的优点。
<img decoding="async" loading="lazy" alt="1756742307399" src="/doc/assets/images/1756742307399-1257b26ce3e40a38828389064cff7d62.png" width="1340" height="786" class="img_ev3q"></p>
<p>在早期的版本中，List 会根据元素的数量和大小采用两种不同的底层数据结构，当元素较少或者较小时，会使用压缩列表；否则用双向链表。</p>
<p>但这种设计有个问题，就是当 List 中的元素数量较多时，压缩列表会因为连锁更新导致性能下降，而双向链表又会占用更多内存。</p>
<p>quicklist 通过将 List 拆分为多个小的 ziplist，再通过指针链接成一个双向链表，巧妙的解决了这个问题。
<img decoding="async" loading="lazy" alt="1756742317904" src="/doc/assets/images/1756742317904-51511c61d50dd8e910348e304fa2fcf7.png" width="1131" height="389" class="img_ev3q">
默认情况下，每个 ziplist 可以存储 8KB 的数据，假如每个元素的大小恰好是 1KB，那么一个 quicklist 就可以存储 8 个元素。80 个这样的元素就会被分成 10 个 ziplist。</p>
<p>这样既保留了压缩列表的内存紧凑性，又减少了双向链表指针的数量，进一步降低了内存开销。</p>
<p><img decoding="async" loading="lazy" alt="1756742328433" src="/doc/assets/images/1756742328433-8554a5e374d5a09c39a74b2760405fec.png" width="1199" height="610" class="img_ev3q">
除此之外，quicklist 还有一个重要的特性，就是它的可配置性，可以通过填充因子控制每个 ziplist 节点的大小。当填充因子为正数时，它还可以限制每个 ziplist 最多包含的元素数量。</p>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># 填充因子，默认 -2（8KB）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">list-max-ziplist-size 10</span><br></span></code></pre></div></div>
<p>如果想进一步节省内存，quicklist 还支持对中间节点进行 LZF 压缩，压缩深度为 1 时，表示除了首尾各 1 个节点不压缩外，其他节点都压缩。</p>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># 压缩深度，默认 0（不压缩）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">list-compress-depth 1</span><br></span></code></pre></div></div>
<p><img decoding="async" loading="lazy" alt="1756742378091" src="/doc/assets/images/1756742378091-b1dfeb6bbdb3c30aacd2481eb6d581f2.png" width="1280" height="1032" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="lzf-压缩算法了解吗">LZF 压缩算法了解吗？<a href="#lzf-压缩算法了解吗" class="hash-link" aria-label="Direct link to LZF 压缩算法了解吗？" title="Direct link to LZF 压缩算法了解吗？">​</a></h3>
<p>LZF 是一种快速的无损压缩算法，主要用于减少数据存储空间。它的核心思想是通过查找重复数据来实现压缩，通过一个滑动窗口来查找重复的字节序列，并将这些序列替换为更短的引用。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="补充">补充<a href="#补充" class="hash-link" aria-label="Direct link to 补充" title="Direct link to 补充">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="假如-redis-里面有-1-亿个-key其中有-10w-个-key-是以某个固定的已知的前缀开头的如何将它们全部找出来">假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如何将它们全部找出来？<a href="#假如-redis-里面有-1-亿个-key其中有-10w-个-key-是以某个固定的已知的前缀开头的如何将它们全部找出来" class="hash-link" aria-label="Direct link to 假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如何将它们全部找出来？" title="Direct link to 假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如何将它们全部找出来？">​</a></h3>
<p>我会使用 SCAN 命令配合 MATCH 参数来解决。</p>
<p>比如要找以 user: 开头的 key，可以执行 SCAN 0 MATCH user:* COUNT 1000。</p>
<p>SCAN 的优势在于它是基于游标的增量迭代，每次只返回一小批结果，不会阻塞服务器。可以从游标 0 开始，每次处理返回的 key 列表，然后用返回的下一个游标继续扫描，直到游标回到 0 表示扫描完成。
千万不要用 KEYS 命令，因为 KEYS 会阻塞 Redis 服务器直到遍历完所有 key，在生产环境中对 1 亿个 key 执行 KEYS 是非常危险的。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis在秒杀场景下可以扮演什么角色">Redis在秒杀场景下可以扮演什么角色？<a href="#redis在秒杀场景下可以扮演什么角色" class="hash-link" aria-label="Direct link to Redis在秒杀场景下可以扮演什么角色？" title="Direct link to Redis在秒杀场景下可以扮演什么角色？">​</a></h3>
<p>秒杀是一种非常特殊的业务场景，它的特点是在极短时间内会有大量用户涌入系统，对系统的并发处理能力、响应速度和数据一致性都提出了极高的要求。在这种场景下，Redis 作为一种高性能的内存数据库，能够发挥多方面的关键作用。</p>
<p>比如说在秒杀开始前，我们可以将商品信息、库存数据等预先加载到 Redis 中，这样大量的用户读请求就可以直接从 Redis 中获取响应，而不必每次都去访问数据库，这样就能大大减轻数据库的访问压力。
<img decoding="async" loading="lazy" alt="1756742466906" src="/doc/assets/images/1756742466906-81cb79f42727396c149d1b0e861ae69c.png" width="1346" height="853" class="img_ev3q">
其次，Redis 在库存控制方面具有得天独厚的优势。秒杀最核心的问题之一就是容易发生超卖。Redis 提供的原子操作如 DECR、DECRBY 等命令，可以确保在高并发环境下库存计数的准确性。
<img decoding="async" loading="lazy" alt="1756742482775" src="/doc/assets/images/1756742482775-c6a33c4272cb9ef84de99916d2656d45.png" width="640" height="377" class="img_ev3q">
更复杂的逻辑，可以通过 Lua 脚本来实现，因为 Lua 脚本在 Redis 中是原子执行的，所以可以包含复杂的判断和操作逻辑，比如先检查库存是否充足，再进行扣减，这整个过程是不会被其他操作打断的。</p>
<p>第三点，Redis 的分布式锁可以确保多个用户同时抢购同一件商品时的操作是互斥的，保证数据一致性的同时，还可以用来防止用户重复下单。
<img decoding="async" loading="lazy" alt="1756742496498" src="/doc/assets/images/1756742496498-d51ff7db116a48a564c93803b9fda9db.png" width="1217" height="1036" class="img_ev3q">
第四点，限流削峰。秒杀开始的瞬间，可能会有成千上万的请求同时到达，如果不加控制，很容易导致系统崩溃。Redis 可以实现多种限流算法，比如简单的计数器限流、令牌桶或漏桶算法等。
<img decoding="async" loading="lazy" alt="1756742511336" src="/doc/assets/images/1756742511336-6bcd548ea46c40719f4cb56c296d2604.png" width="659" height="502" class="img_ev3q">
通过限流算法我们可以控制单位时间内系统能够处理的请求数量，超出部分可以排队或者直接拒绝，从而保护系统的稳定运行。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis具体如何实现削峰呢">Redis具体如何实现削峰呢？<a href="#redis具体如何实现削峰呢" class="hash-link" aria-label="Direct link to Redis具体如何实现削峰呢？" title="Direct link to Redis具体如何实现削峰呢？">​</a></h3>
<p>削峰的本质是将瞬时的高流量请求缓冲起来，通过排队、限流等机制，使系统以一个可承受的速度来处理请求。</p>
<p>那第一步就是缓存预热。在秒杀活动开始前，先把商品信息这些热点数据提前加载到 Redis 中。这样用户访问商品页面时，可以直接从 Redis 读取，数据库基本上不会有压力。
<img decoding="async" loading="lazy" alt="1756742532824" src="/doc/assets/images/1756742532824-39aa87a179967c12da5179086dc15880.png" width="1126" height="484" class="img_ev3q">
第二步是引入消息队列，特别是下单这种写操作，不能让用户等太久，但后端处理订单、扣库存这些操作又比较重。所以可以用 Redis 的 List 做了个队列，或者直接用 RocketMQ 这种标准的消息中间件，用户下单后立即返回&quot;订单提交成功&quot;，然后把订单数据丢到队列里，后台服务慢慢消费。这样既保证了用户体验，又避免了系统被瞬时写请求压垮。
<img decoding="async" loading="lazy" alt="1756742547294" src="/doc/assets/images/1756742547294-b3c0365a2eec8b428535df0e8a668e5a.png" width="1134" height="682" class="img_ev3q">
第三步，可以在秒杀活动中加入答题环节，只有答对题目的用户才能参与秒杀活动，这样可以最大程度减少无效请求。
<img decoding="async" loading="lazy" alt="1756742563119" src="/doc/assets/images/1756742563119-39b9c80d10192f4e63c4ac4ddecf6b6d.png" width="1208" height="299" class="img_ev3q"></p>
<p>一个比较完整的秒杀削峰处理方案：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Service</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SeckillServiceImpl implements SeckillService {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Autowired</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private RedisTemplate&lt;String, String&gt; redisTemplate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Autowired</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private OrderService orderService;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Autowired</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private CommodityService commodityService;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 秒杀请求入口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Result seckill(Long userId, Long commodityId) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 1. 用户请求频率限制</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!countRateLimit(&quot;user:&quot; + userId, 5, 60)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return Result.error(&quot;请求过于频繁&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 2. 商品是否在秒杀时间内</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!isInSeckillTime(commodityId)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return Result.error(&quot;秒杀未开始或已结束&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 3. 是否还有库存(快速失败)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String stockKey = &quot;seckill:stock:&quot; + commodityId;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Integer stock = Integer.valueOf(redisTemplate.opsForValue().get(stockKey));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (stock != null &amp;&amp; stock &lt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return Result.error(&quot;商品已售罄&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 4. 全局限流</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!acquireToken(&quot;global&quot;, 1000, 100)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 系统负载过高，将请求放入队列延迟处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            enqueueDelayedRequest(userId, commodityId);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return Result.success(&quot;秒杀请求已受理，排队处理中&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 5. 检查用户是否已购买</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (hasUserBought(userId, commodityId)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return Result.error(&quot;您已经购买过该商品&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 6. 将请求放入队列，返回排队状态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String requestId = generateRequestId(userId, commodityId);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        enqueueRequest(userId, commodityId, requestId);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Result.success(&quot;秒杀请求已提交，请等待结果&quot;, requestId);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 异步处理秒杀请求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Scheduled(fixedRate = 50) // 每50ms处理一批</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void processSeckillQueue() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String queueKey = &quot;seckill:queue&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 批量处理，控制处理速度</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; 10; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String requestJson = redisTemplate.opsForList().leftPop(queueKey);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (requestJson == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            SeckillRequest request = JSON.parseObject(requestJson, SeckillRequest.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 执行秒杀核心逻辑</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                boolean success = doSeckill(request.getUserId(), request.getCommodityId());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 更新请求状态，便于用户查询</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                String statusKey = &quot;seckill:status:&quot; + request.getRequestId();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                redisTemplate.opsForValue().set(statusKey, success ? &quot;SUCCESS&quot; : &quot;FAILED&quot;, 1, TimeUnit.HOURS);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                log.error(&quot;处理秒杀请求失败&quot;, e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 记录失败状态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                String statusKey = &quot;seckill:status:&quot; + request.getRequestId();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                redisTemplate.opsForValue().set(statusKey, &quot;ERROR&quot;, 1, TimeUnit.HOURS);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 秒杀核心逻辑</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private boolean doSeckill(Long userId, Long commodityId) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 使用Lua脚本保证原子性操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String script = </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;-- 检查库存\n&quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;local stockKey = KEYS[1]\n&quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;local stock = tonumber(redis.call(&#x27;get&#x27;, stockKey))\n&quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;if stock == nil or stock &lt;= 0 then\n&quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;    return 0\n&quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;end\n&quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;\n&quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;-- 检查是否重复购买\n&quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;local boughtKey = KEYS[2]\n&quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;local hasBought = redis.call(&#x27;sismember&#x27;, boughtKey, ARGV[1])\n&quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;if hasBought == 1 then\n&quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;    return -1\n&quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;end\n&quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;\n&quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;-- 扣减库存并记录购买\n&quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;redis.call(&#x27;decr&#x27;, stockKey)\n&quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;redis.call(&#x27;sadd&#x27;, boughtKey, ARGV[1])\n&quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;\n&quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;-- 返回成功\n&quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;return 1&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String stockKey = &quot;seckill:stock:&quot; + commodityId;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String boughtKey = &quot;seckill:bought:&quot; + commodityId;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Long result = (Long) redisTemplate.execute(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new DefaultRedisScript&lt;&gt;(script, Long.class),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Arrays.asList(stockKey, boughtKey),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            userId.toString()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (result == 1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 创建订单(可以进一步异步化)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            createOrder(userId, commodityId);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 其他辅助方法...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="redis如何做限流呢">Redis如何做限流呢？<a href="#redis如何做限流呢" class="hash-link" aria-label="Direct link to Redis如何做限流呢？" title="Direct link to Redis如何做限流呢？">​</a></h3>
<p>限流是为了控制系统的请求速率，防止系统被过多的请求压垮。</p>
<p>Redis 实现限流最简单的方法是基于计数器的固定窗口限流。比如限制用户每分钟最多访问 100 次，我们就用 INCR 命令给每个用户设个计数器，key 是 rate_limit:用户ID:分钟时间戳，每次请求就加 1，同时设置 60 秒过期。如果计数超过 100 就拒绝请求。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 伪代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String key = &quot;rate_limit:&quot; + userId;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 尝试获取当前计数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Long count = redis.get(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 如果key不存在，设置为1并设置过期时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (count == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    redis.setex(key, 60, &quot;1&quot;); // 60秒窗口期</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return true; // 允许访问</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 如果计数未超过限制</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (count &lt; maxRequests) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    redis.incr(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return true; // 允许访问</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">return false; // 拒绝访问</span><br></span></code></pre></div></div>
<p>这种方法简单粗暴，但有个问题就是临界时间会有突刺，比如用户在第 59 秒访问了 100 次，第 61 秒又访问 100 次，相当于 2 秒内访问了 200 次。</p>
<p>第二种就是滑动窗口限流，通过 Redis 的 ZSET 来实现，把每次请求的时间戳作为 score 存进去，然后用 ZREMRANGEBYSCORE 删除窗口外的旧数据，再用 ZCARD 统计当前窗口内的请求数。这样限流就比较均匀了。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 伪代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String key = &quot;sliding_window:&quot; + userId;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">long now = System.currentTimeMillis();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 添加当前请求到有序集合，score为当前时间戳</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">redis.zadd(key, now, String.valueOf(now));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 移除时间窗口之前的请求数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">redis.zremrangeByScore(key, 0, now - windowSize);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 设置key过期时间，避免冷用户持续占用内存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">redis.expire(key, windowSize / 1000 + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 获取当前窗口的请求数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Long count = redis.zcard(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">return count &lt;= maxRequests;</span><br></span></code></pre></div></div>
<p>在实际开发中，通常会采用令牌桶算法，它就像在帝都/魔都买车，摇到号才有资格，没摇到就只能等下一次（😁）。</p>
<p>可以在 Redis 里存两个值，一个是令牌数量，一个是上次更新时间。每次请求时用 Lua 脚本计算应该补充多少令牌，然后判断是否有足够的令牌。
<img decoding="async" loading="lazy" alt="1756742625281" src="/doc/assets/images/1756742625281-d73e4830bf9b6089c857146bf2313f4e.png" width="1990" height="1074" class="img_ev3q"></p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">-- Redis Lua脚本实现令牌桶算法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">local key = KEYS[1]  -- 限流的key</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">local max_permits = tonumber(ARGV[1])  -- 最大令牌数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">local permits_per_second = tonumber(ARGV[2])  -- 每秒产生的令牌数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">local required_permits = tonumber(ARGV[3])  -- 请求的令牌数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-- 获取当前时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">local time = redis.call(&#x27;time&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">local now_micros = tonumber(time[1]) * 1000000 + tonumber(time[2])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-- 获取上次更新的时间和当前存储的令牌数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">local last_micros = tonumber(redis.call(&#x27;hget&#x27;, key, &#x27;last_micros&#x27;) or 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">local stored_permits = tonumber(redis.call(&#x27;hget&#x27;, key, &#x27;stored_permits&#x27;) or 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-- 计算时间间隔内新产生的令牌数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">local interval_micros = now_micros - last_micros</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">local new_permits = interval_micros * permits_per_second / 1000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">stored_permits = math.min(max_permits, stored_permits + new_permits)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-- 判断令牌是否足够</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">local result = 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if stored_permits &gt;= required_permits then</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -- 令牌足够，更新令牌数和时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stored_permits = stored_permits - required_permits</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    result = 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-- 更新Redis中的数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">redis.call(&#x27;hset&#x27;, key, &#x27;last_micros&#x27;, now_micros)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">redis.call(&#x27;hset&#x27;, key, &#x27;stored_permits&#x27;, stored_permits)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">redis.call(&#x27;expire&#x27;, key, 10)  -- 设置过期时间，避免长期占用内存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">return result</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="客户端宕机后-redis-服务端如何感知到">客户端宕机后 Redis 服务端如何感知到？<a href="#客户端宕机后-redis-服务端如何感知到" class="hash-link" aria-label="Direct link to 客户端宕机后 Redis 服务端如何感知到？" title="Direct link to 客户端宕机后 Redis 服务端如何感知到？">​</a></h3>
<p>TCP 的 keepalive 是 Redis 用来检测客户端连接状态的主要机制，默认值为 300 秒。
当客户端与服务器在指定时间内没有任何数据交互时，Redis 服务器会发送 TCP ACK 探测包，如果连续多次没有收到响应，TCP 协议栈会通知 Redis 服务端连接已断开，之后，Redis 服务端会清理相关的连接资源，释放连接。
另外还有一个 timeout 参数，用来控制客户端连接的空闲超时时间。</p>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># 表示600秒内没有任何命令则断开连接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">config set timeout 600</span><br></span></code></pre></div></div>
<p>默认值为 0，表示永不断开连接；当设置为非零值时，如果客户端在指定时间内没有发送任何命令，服务端会主动断开连接。</p>
<p>Redis 服务器会定期检查空闲连接是否超时，检查频率由 hz 参数控制；这将有助于释放那些客户端异常退出但 TCP 连接未正常关闭的资源。</p>
<p>不同的连接池也会有自己的连接检测机制，比如 Jedis 连接池可以通过设置 testOnBorrow 和 testWhileIdle 来启用连接检测。</p>
<div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># 是否启用连接池</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">spring.redis.jedis.pool.enabled=true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 连接池最大连接数（使用负值表示没有限制）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">spring.redis.jedis.pool.max-active=200</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 连接池最大空闲连接数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">spring.redis.jedis.pool.max-idle=200</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 连接池最小空闲连接数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">spring.redis.jedis.pool.min-idle=50</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">spring.redis.jedis.pool.max-wait=3000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 空闲连接检查间隔（毫秒）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">spring.redis.jedis.pool.time-between-eviction-runs=60000</span><br></span></code></pre></div></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-tags-row"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a rel="tag" class="tag_zVej tagRegular_sFm0" href="/doc/docs/tags/interview">INTERVIEW</a></li><li class="tag_QGVx"><a rel="tag" class="tag_zVej tagRegular_sFm0" href="/doc/docs/tags/redis">REDIS</a></li></ul></div></div><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/REDIS/redis_review.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/doc/docs/INTERVIEW/NGINX/NGINX-REVIEW"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">NGINX-REVIEW</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/doc/docs/INTERVIEW/SPRING/SPRING-REVIEW"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">SPRING-REVIEW</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#说说什么是-redis" class="table-of-contents__link toc-highlight">🌟说说什么是 Redis?</a></li><li><a href="#redis-和-mysql-的区别" class="table-of-contents__link toc-highlight">Redis 和 MySQL 的区别？</a></li><li><a href="#项目里哪里用到了-redis" class="table-of-contents__link toc-highlight">项目里哪里用到了 Redis？</a></li><li><a href="#部署过-redis-吗" class="table-of-contents__link toc-highlight">部署过 Redis 吗？</a></li><li><a href="#redis-的高可用方案有部署过吗" class="table-of-contents__link toc-highlight">Redis 的高可用方案有部署过吗？</a></li><li><a href="#redis-可以用来干什么" class="table-of-contents__link toc-highlight">.Redis 可以用来干什么？</a></li><li><a href="#redis有哪些数据类型" class="table-of-contents__link toc-highlight">Redis有哪些数据类型？</a></li><li><a href="#详细介绍下哈希" class="table-of-contents__link toc-highlight">详细介绍下哈希？</a></li><li><a href="#详细介绍下集合" class="table-of-contents__link toc-highlight">详细介绍下集合？</a></li><li><a href="#详细介绍下有序集合" class="table-of-contents__link toc-highlight">详细介绍下有序集合？</a></li><li><a href="#详细介绍下bitmap" class="table-of-contents__link toc-highlight">详细介绍下Bitmap？</a></li><li><a href="#详细介绍下hyperloglog" class="table-of-contents__link toc-highlight">详细介绍下HyperLogLog？</a></li><li><a href="#详细介绍下geo" class="table-of-contents__link toc-highlight">详细介绍下GEO？</a></li><li><a href="#为什么使用-hash-类型而不使用-string-类型序列化存储" class="table-of-contents__link toc-highlight">为什么使用 hash 类型而不使用 string 类型序列化存储？</a></li><li><a href="#redis-为什么快呢" class="table-of-contents__link toc-highlight">🌟Redis 为什么快呢？</a></li><li><a href="#能详细说一下io多路复用吗" class="table-of-contents__link toc-highlight">能详细说一下IO多路复用吗？</a></li><li><a href="#请说说-selectpollepollkqueue-和-iocp-的区别" class="table-of-contents__link toc-highlight">请说说 select、poll、epoll、kqueue 和 IOCP 的区别？</a></li><li><a href="#举个例子说一下-io-多路复用" class="table-of-contents__link toc-highlight">举个例子说一下 IO 多路复用？</a></li><li><a href="#举例子说一下阻塞-io和-io-多路复用的差别" class="table-of-contents__link toc-highlight">举例子说一下阻塞 IO和 IO 多路复用的差别？</a></li><li><a href="#selectpoll-和-epoll-的实现原理" class="table-of-contents__link toc-highlight">select、poll 和 epoll 的实现原理？</a></li><li><a href="#redis为什么早期选择单线程" class="table-of-contents__link toc-highlight">Redis为什么早期选择单线程？</a></li><li><a href="#redis-60-使用多线程是怎么回事" class="table-of-contents__link toc-highlight">Redis 6.0 使用多线程是怎么回事?</a></li><li><a href="#说说-redis-的常用命令补充" class="table-of-contents__link toc-highlight">说说 Redis 的常用命令（补充）</a></li><li><a href="#详细说说-set-命令" class="table-of-contents__link toc-highlight">详细说说 set 命令？</a></li><li><a href="#单线程的redis-qps-能到多少补充" class="table-of-contents__link toc-highlight">单线程的Redis QPS 能到多少？(补充)</a></li><li><a href="#持久化" class="table-of-contents__link toc-highlight">持久化</a><ul><li><a href="#redis的持久化方式有哪些" class="table-of-contents__link toc-highlight">🌟Redis的持久化方式有哪些？</a></li><li><a href="#详细说一下-rdb" class="table-of-contents__link toc-highlight">详细说一下 RDB？</a></li><li><a href="#什么情况下会自动触发-rdb-持久化" class="table-of-contents__link toc-highlight">什么情况下会自动触发 RDB 持久化？</a></li><li><a href="#详细说一下-aof" class="table-of-contents__link toc-highlight">详细说一下 AOF？</a></li><li><a href="#aof-的刷盘策略了解吗" class="table-of-contents__link toc-highlight">AOF 的刷盘策略了解吗？</a></li><li><a href="#说说aof的重写机制" class="table-of-contents__link toc-highlight">说说AOF的重写机制？</a></li><li><a href="#aof-重写的具体过程是怎样的" class="table-of-contents__link toc-highlight">AOF 重写的具体过程是怎样的？</a></li><li><a href="#aof-文件存储的是什么类型的数据" class="table-of-contents__link toc-highlight">AOF 文件存储的是什么类型的数据？</a></li><li><a href="#aof重写期间命令可能会写入两次会造成什么影响" class="table-of-contents__link toc-highlight">AOF重写期间命令可能会写入两次，会造成什么影响？</a></li><li><a href="#rdb-和-aof-各自有什么优缺点" class="table-of-contents__link toc-highlight">RDB 和 AOF 各自有什么优缺点？</a></li><li><a href="#rdb-和-aof-如何选择" class="table-of-contents__link toc-highlight">RDB 和 AOF 如何选择？</a></li><li><a href="#redis如何恢复数据" class="table-of-contents__link toc-highlight">Redis如何恢复数据？</a></li><li><a href="#redis-40-的混合持久化了解吗" class="table-of-contents__link toc-highlight">🌟Redis 4.0 的混合持久化了解吗？</a></li><li><a href="#你在开发中是怎么配置-rdb-和-aof-的" class="table-of-contents__link toc-highlight">你在开发中是怎么配置 RDB 和 AOF 的？</a></li><li><a href="#对于单纯的缓存场景或者本地开发我会只启用-rdb关闭-aof" class="table-of-contents__link toc-highlight">对于单纯的缓存场景，或者本地开发，我会只启用 RDB，关闭 AOF：</a></li><li><a href="#而对于金融类等高一致性的系统我通常会在关键时间窗口动态将-appendfsync-设置为-always" class="table-of-contents__link toc-highlight">而对于金融类等高一致性的系统，我通常会在关键时间窗口动态将 appendfsync 设置为 always：</a></li></ul></li><li><a href="#高可用" class="table-of-contents__link toc-highlight">高可用</a><ul><li><a href="#主从复制了解吗" class="table-of-contents__link toc-highlight">主从复制了解吗？</a></li><li><a href="#主从复制的主要作用是什么" class="table-of-contents__link toc-highlight">主从复制的主要作用是什么?</a></li><li><a href="#什么情况下会出现主从复制数据不一致" class="table-of-contents__link toc-highlight">什么情况下会出现主从复制数据不一致？</a></li><li><a href="#redis主从有几种常见的拓扑结构" class="table-of-contents__link toc-highlight">Redis主从有几种常见的拓扑结构？</a></li><li><a href="#redis的主从复制原理了解吗" class="table-of-contents__link toc-highlight">Redis的主从复制原理了解吗？</a></li><li><a href="#详细说说全量同步和增量同步" class="table-of-contents__link toc-highlight">详细说说全量同步和增量同步？</a></li><li><a href="#主从复制存在哪些问题呢" class="table-of-contents__link toc-highlight">主从复制存在哪些问题呢？</a></li><li><a href="#redis哨兵机制了解吗" class="table-of-contents__link toc-highlight">Redis哨兵机制了解吗？</a></li><li><a href="#redis哨兵的工作原理知道吗" class="table-of-contents__link toc-highlight">Redis哨兵的工作原理知道吗？</a></li><li><a href="#redis领导者选举了解吗" class="table-of-contents__link toc-highlight">Redis领导者选举了解吗？</a></li><li><a href="#新的主节点是怎样被挑选出来的" class="table-of-contents__link toc-highlight">新的主节点是怎样被挑选出来的？</a></li><li><a href="#redis集群了解吗" class="table-of-contents__link toc-highlight">Redis集群了解吗？</a></li><li><a href="#请详细说一说redis-cluster补充" class="table-of-contents__link toc-highlight">请详细说一说Redis Cluster？（补充）</a></li><li><a href="#集群中数据如何分区" class="table-of-contents__link toc-highlight">集群中数据如何分区？</a></li><li><a href="#能说说-redis-集群的原理吗" class="table-of-contents__link toc-highlight">能说说 Redis 集群的原理吗？</a></li><li><a href="#部署-redis-集群至少需要几个物理节点" class="table-of-contents__link toc-highlight">部署 Redis 集群至少需要几个物理节点？</a></li><li><a href="#说说redis集群的动态伸缩" class="table-of-contents__link toc-highlight">说说Redis集群的动态伸缩？</a></li><li><a href="#moved-和-ask-重定向的区别" class="table-of-contents__link toc-highlight">MOVED 和 ASK 重定向的区别？</a></li></ul></li><li><a href="#缓存设计" class="table-of-contents__link toc-highlight">缓存设计</a><ul><li><a href="#什么是缓存击穿" class="table-of-contents__link toc-highlight">🌟什么是缓存击穿？</a></li><li><a href="#什么是缓存穿透" class="table-of-contents__link toc-highlight">什么是缓存穿透？</a></li><li><a href="#什么是缓存雪崩" class="table-of-contents__link toc-highlight">什么是缓存雪崩？</a></li><li><a href="#能说说布隆过滤器吗" class="table-of-contents__link toc-highlight">🌟能说说布隆过滤器吗？</a></li><li><a href="#布隆过滤器存在误判吗" class="table-of-contents__link toc-highlight">布隆过滤器存在误判吗？</a></li><li><a href="#布隆过滤器支持删除吗" class="table-of-contents__link toc-highlight">布隆过滤器支持删除吗？</a></li><li><a href="#为什么不能用哈希表而是用布隆过滤器" class="table-of-contents__link toc-highlight">为什么不能用哈希表而是用布隆过滤器？</a></li><li><a href="#如何保证缓存和数据库的数据致性" class="table-of-contents__link toc-highlight">🌟如何保证缓存和数据库的数据⼀致性？</a></li><li><a href="#那再来说说为什么要删除缓存而不是更新缓存" class="table-of-contents__link toc-highlight">那再来说说为什么要删除缓存而不是更新缓存？</a></li><li><a href="#那再说说为什么要先更新数据库再删除缓存" class="table-of-contents__link toc-highlight">那再说说为什么要先更新数据库，再删除缓存？</a></li><li><a href="#那假如对缓存数据库一致性要求很高该怎么办呢" class="table-of-contents__link toc-highlight">那假如对缓存数据库一致性要求很高，该怎么办呢？</a></li><li><a href="#如何保证本地缓存和分布式缓存的一致" class="table-of-contents__link toc-highlight">如何保证本地缓存和分布式缓存的一致？</a></li><li><a href="#如果在项目中多个地方都要使用到二级缓存的逻辑如何设计这一块" class="table-of-contents__link toc-highlight">如果在项目中多个地方都要使用到二级缓存的逻辑，如何设计这一块？</a></li><li><a href="#本地缓存和-redis-的区别了解吗" class="table-of-contents__link toc-highlight">本地缓存和 Redis 的区别了解吗？</a></li><li><a href="#什么是热key" class="table-of-contents__link toc-highlight">什么是热Key？</a></li><li><a href="#那怎么监控热key-呢" class="table-of-contents__link toc-highlight">那怎么监控热Key 呢？</a></li><li><a href="#那怎么处理热key-呢" class="table-of-contents__link toc-highlight">那怎么处理热Key 呢？</a></li><li><a href="#怎么处理大-key-呢" class="table-of-contents__link toc-highlight">怎么处理大 Key 呢？</a></li><li><a href="#缓存预热怎么做呢" class="table-of-contents__link toc-highlight">缓存预热怎么做呢？</a></li><li><a href="#无底洞问题听说过吗如何解决" class="table-of-contents__link toc-highlight">无底洞问题听说过吗？如何解决？</a></li></ul></li><li><a href="#redis-运维" class="table-of-contents__link toc-highlight">Redis 运维</a><ul><li><a href="#redis-报内存不足怎么处理" class="table-of-contents__link toc-highlight">Redis 报内存不足怎么处理？</a></li><li><a href="#redis-key过期策略有哪些" class="table-of-contents__link toc-highlight">Redis key过期策略有哪些？</a></li><li><a href="#redis有哪些内存淘汰策略" class="table-of-contents__link toc-highlight">🌟Redis有哪些内存淘汰策略？</a></li><li><a href="#lru-和-lfu-的区别是什么" class="table-of-contents__link toc-highlight">LRU 和 LFU 的区别是什么？</a></li><li><a href="#redis发生阻塞了怎么解决" class="table-of-contents__link toc-highlight">Redis发生阻塞了怎么解决？</a></li></ul></li><li><a href="#redis-应用" class="table-of-contents__link toc-highlight">Redis 应用</a><ul><li><a href="#redis如何实现异步消息队列" class="table-of-contents__link toc-highlight">Redis如何实现异步消息队列？</a></li><li><a href="#redis如何实现延时消息队列" class="table-of-contents__link toc-highlight">Redis如何实现延时消息队列?</a></li><li><a href="#redis支持事务吗" class="table-of-contents__link toc-highlight">🌟Redis支持事务吗？</a></li><li><a href="#说一下-redis-事务的原理" class="table-of-contents__link toc-highlight">说一下 Redis 事务的原理？</a></li><li><a href="#redis-事务有哪些注意点" class="table-of-contents__link toc-highlight">Redis 事务有哪些注意点？</a></li><li><a href="#redis事务为什么不支持回滚" class="table-of-contents__link toc-highlight">Redis事务为什么不支持回滚？</a></li><li><a href="#redis事务满足原子性吗要怎么改进" class="table-of-contents__link toc-highlight">Redis事务满足原子性吗？要怎么改进？</a></li><li><a href="#redis-事务的-acid-特性如何体现" class="table-of-contents__link toc-highlight">Redis 事务的 ACID 特性如何体现？</a></li><li><a href="#有lua脚本操作redis的经验吗" class="table-of-contents__link toc-highlight">有Lua脚本操作Redis的经验吗？</a></li><li><a href="#redis的管道pipeline了解吗" class="table-of-contents__link toc-highlight">Redis的管道Pipeline了解吗？</a></li><li><a href="#什么场景下适合使用-pipeline呢" class="table-of-contents__link toc-highlight">什么场景下适合使用 Pipeline呢？</a></li><li><a href="#有了解过-pipeline-的底层原理吗" class="table-of-contents__link toc-highlight">有了解过 Pipeline 的底层原理吗？</a></li><li><a href="#redis能实现分布式锁吗" class="table-of-contents__link toc-highlight">🌟Redis能实现分布式锁吗？</a></li><li><a href="#redis如何保证-setnx-不会发生冲突" class="table-of-contents__link toc-highlight">Redis如何保证 SETNX 不会发生冲突？</a></li><li><a href="#setnx有什么问题如何解决" class="table-of-contents__link toc-highlight">SETNX有什么问题，如何解决？</a></li><li><a href="#redisson了解多少" class="table-of-contents__link toc-highlight">Redisson了解多少？</a></li><li><a href="#详细说说redisson的看门狗机制" class="table-of-contents__link toc-highlight">详细说说Redisson的看门狗机制？</a></li><li><a href="#看门狗机制中的检查锁过程是原子操作吗" class="table-of-contents__link toc-highlight">看门狗机制中的检查锁过程是原子操作吗？</a></li><li><a href="#redlock你了解多少" class="table-of-contents__link toc-highlight">Redlock你了解多少？</a></li><li><a href="#红锁能不能保证百分百上锁" class="table-of-contents__link toc-highlight">红锁能不能保证百分百上锁？</a></li><li><a href="#项目中有用到分布式锁吗" class="table-of-contents__link toc-highlight">项目中有用到分布式锁吗？</a></li></ul></li><li><a href="#底层结构" class="table-of-contents__link toc-highlight">底层结构</a><ul><li><a href="#redis都有哪些底层数据结构" class="table-of-contents__link toc-highlight">🌟Redis都有哪些底层数据结构？</a></li><li><a href="#简单介绍下链表" class="table-of-contents__link toc-highlight">简单介绍下链表？</a></li><li><a href="#关于整数集合能再详细说说吗" class="table-of-contents__link toc-highlight">关于整数集合，能再详细说说吗？</a></li><li><a href="#说一下zset-的底层原理" class="table-of-contents__link toc-highlight">说一下zset 的底层原理？</a></li><li><a href="#你知道为什么redis-70要用listpack来替代ziplist吗" class="table-of-contents__link toc-highlight">你知道为什么Redis 7.0要用listpack来替代ziplist吗？</a></li><li><a href="#连锁更新是怎么发生的" class="table-of-contents__link toc-highlight">连锁更新是怎么发生的？</a></li><li><a href="#redis-为什么不用-c-语言的原生字符串" class="table-of-contents__link toc-highlight">Redis 为什么不用 C 语言的原生字符串？</a></li><li><a href="#你研究过-redis-的字典源码吗" class="table-of-contents__link toc-highlight">你研究过 Redis 的字典源码吗？</a></li><li><a href="#遇到哈希冲突怎么办" class="table-of-contents__link toc-highlight">遇到哈希冲突怎么办？</a></li><li><a href="#你了解跳表吗" class="table-of-contents__link toc-highlight">🌟你了解跳表吗？</a></li><li><a href="#怎么往跳表插入节点呢" class="table-of-contents__link toc-highlight">怎么往跳表插入节点呢？</a></li><li><a href="#zset为什么要使用跳表呢" class="table-of-contents__link toc-highlight">zset为什么要使用跳表呢？</a></li><li><a href="#跳表是如何定义的呢" class="table-of-contents__link toc-highlight">跳表是如何定义的呢？</a></li><li><a href="#span-跨度有什么用" class="table-of-contents__link toc-highlight">span 跨度有什么用？</a></li><li><a href="#为什么跳表的范围查询效率比字典高" class="table-of-contents__link toc-highlight">为什么跳表的范围查询效率比字典高？</a></li><li><a href="#压缩列表了解吗" class="table-of-contents__link toc-highlight">压缩列表了解吗？</a></li><li><a href="#ziplist-的节点数量会超过-65535-吗" class="table-of-contents__link toc-highlight">ziplist 的节点数量会超过 65535 吗？</a></li><li><a href="#ziplist-的编码类型了解多少" class="table-of-contents__link toc-highlight">ziplist 的编码类型了解多少？</a></li><li><a href="#quicklist-了解吗" class="table-of-contents__link toc-highlight">quicklist 了解吗？</a></li><li><a href="#lzf-压缩算法了解吗" class="table-of-contents__link toc-highlight">LZF 压缩算法了解吗？</a></li></ul></li><li><a href="#补充" class="table-of-contents__link toc-highlight">补充</a><ul><li><a href="#假如-redis-里面有-1-亿个-key其中有-10w-个-key-是以某个固定的已知的前缀开头的如何将它们全部找出来" class="table-of-contents__link toc-highlight">假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如何将它们全部找出来？</a></li><li><a href="#redis在秒杀场景下可以扮演什么角色" class="table-of-contents__link toc-highlight">Redis在秒杀场景下可以扮演什么角色？</a></li><li><a href="#redis具体如何实现削峰呢" class="table-of-contents__link toc-highlight">Redis具体如何实现削峰呢？</a></li><li><a href="#redis如何做限流呢" class="table-of-contents__link toc-highlight">Redis如何做限流呢？</a></li><li><a href="#客户端宕机后-redis-服务端如何感知到" class="table-of-contents__link toc-highlight">客户端宕机后 Redis 服务端如何感知到？</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/doc/docs/intro">Tutorial</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://x.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">X<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/doc/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>